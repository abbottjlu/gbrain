(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var KERNEL_ADJMATRIX_UPDATE = exports.KERNEL_ADJMATRIX_UPDATE = function () {
    function KERNEL_ADJMATRIX_UPDATE() {
        _classCallCheck(this, KERNEL_ADJMATRIX_UPDATE);
    }

    _createClass(KERNEL_ADJMATRIX_UPDATE, null, [{
        key: "getSrc",
        value: function getSrc(geometryLength) {
            return ["x", ["adjacencyMatrix"],
            // head
            "",

            // source
            "vec4 adjMat = adjacencyMatrix[x]; \n            vec4 adjMatB = adjacencyMatrixB[x];\n\n            float linkLayerNum = adjMat.x;\n            float linkWeight = adjMat.z;\n            float linkTypeParent = adjMat.w;\n            \n            if(linkTypeParent == 0.5 && linkLayerNum > 0.0) {\n                float id = adjMatB.z;\n                float idInv = adjMatB.w;\n            \n                vec2 xGeometryCurrentChild = get_global_id(id, bufferNodesWidth, " + geometryLength.toFixed(1) + ");\n                vec2 xGeometryParent = get_global_id(idInv, bufferNodesWidth, " + geometryLength.toFixed(1) + ");\n\n                float childGOutputA = dataB[xGeometryCurrentChild].z;\n                float parentGErrorA = dataB[xGeometryParent].w;\n                \n                float childGOutputB = dataF[xGeometryCurrentChild].x;\n                float parentGErrorB = dataF[xGeometryParent].y;\n                \n                float childGOutputC = dataF[xGeometryCurrentChild].z;\n                float parentGErrorC = dataF[xGeometryParent].w;\n                \n                float childGOutputD = dataG[xGeometryCurrentChild].x;\n                float parentGErrorD = dataG[xGeometryParent].y;\n                \n                float childGOutputE = dataG[xGeometryCurrentChild].z;\n                float parentGErrorE = dataG[xGeometryParent].w;\n                \n                float childGOutputF = dataH[xGeometryCurrentChild].x;\n                float parentGErrorF = dataH[xGeometryParent].y;\n                \n                float childGOutputG = dataH[xGeometryCurrentChild].z;\n                float parentGErrorG = dataH[xGeometryParent].w;\n            \n                float lr = learningRate;\n                float l2_decay = 0.01;\n                float gpu_batch_size = 7.0;\n                float br = gpu_batch_repeats;\n                \n                float derivA = (childGOutputA < 0.0) ? 0.01 : childGOutputA;\n                float derivB = (childGOutputB < 0.0) ? 0.01 : childGOutputB;\n                float derivC = (childGOutputC < 0.0) ? 0.01 : childGOutputC;\n                float derivD = (childGOutputD < 0.0) ? 0.01 : childGOutputD;\n                float derivE = (childGOutputE < 0.0) ? 0.01 : childGOutputE;\n                float derivF = (childGOutputF < 0.0) ? 0.01 : childGOutputF;\n                float derivG = (childGOutputG < 0.0) ? 0.01 : childGOutputG;\n                \n                if(linkLayerNum == layerCount-1.0) {\n                    derivA = childGOutputA;\n                    derivB = childGOutputA;\n                    derivC = childGOutputA;\n                    derivD = childGOutputA;\n                    derivE = childGOutputA;\n                    derivF = childGOutputA;\n                    derivG = childGOutputA;\n                }\n                \n                linkWeight += (-lr*parentGErrorA*derivA)/(gpu_batch_size*br);\n                linkWeight += (-lr*parentGErrorB*derivB)/(gpu_batch_size*br);\n                linkWeight += (-lr*parentGErrorC*derivC)/(gpu_batch_size*br);\n                linkWeight += (-lr*parentGErrorD*derivD)/(gpu_batch_size*br);\n                linkWeight += (-lr*parentGErrorE*derivE)/(gpu_batch_size*br);\n                linkWeight += (-lr*parentGErrorF*derivF)/(gpu_batch_size*br);\n                linkWeight += (-lr*parentGErrorG*derivG)/(gpu_batch_size*br);\n            }\n            \n            return [vec4(linkLayerNum, 0.0, linkWeight, linkTypeParent)];\n            "];
        }
    }]);

    return KERNEL_ADJMATRIX_UPDATE;
}();

global.KERNEL_ADJMATRIX_UPDATE = KERNEL_ADJMATRIX_UPDATE;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZ2JyYWluL0tFUk5FTF9BREpNQVRSSVhfVVBEQVRFLmNsYXNzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7aWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICB9cmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtyZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfTtcbn0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuXG52YXIgS0VSTkVMX0FESk1BVFJJWF9VUERBVEUgPSBleHBvcnRzLktFUk5FTF9BREpNQVRSSVhfVVBEQVRFID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtFUk5FTF9BREpNQVRSSVhfVVBEQVRFKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS0VSTkVMX0FESk1BVFJJWF9VUERBVEUpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhLRVJORUxfQURKTUFUUklYX1VQREFURSwgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcImdldFNyY1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3JjKGdlb21ldHJ5TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1wieFwiLCBbXCJhZGphY2VuY3lNYXRyaXhcIl0sXG4gICAgICAgICAgICAvLyBoZWFkXG4gICAgICAgICAgICBcIlwiLFxuXG4gICAgICAgICAgICAvLyBzb3VyY2VcbiAgICAgICAgICAgIFwidmVjNCBhZGpNYXQgPSBhZGphY2VuY3lNYXRyaXhbeF07IFxcbiAgICAgICAgICAgIHZlYzQgYWRqTWF0QiA9IGFkamFjZW5jeU1hdHJpeEJbeF07XFxuXFxuICAgICAgICAgICAgZmxvYXQgbGlua0xheWVyTnVtID0gYWRqTWF0Lng7XFxuICAgICAgICAgICAgZmxvYXQgbGlua1dlaWdodCA9IGFkak1hdC56O1xcbiAgICAgICAgICAgIGZsb2F0IGxpbmtUeXBlUGFyZW50ID0gYWRqTWF0Lnc7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgaWYobGlua1R5cGVQYXJlbnQgPT0gMC41ICYmIGxpbmtMYXllck51bSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgICBmbG9hdCBpZCA9IGFkak1hdEIuejtcXG4gICAgICAgICAgICAgICAgZmxvYXQgaWRJbnYgPSBhZGpNYXRCLnc7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIHZlYzIgeEdlb21ldHJ5Q3VycmVudENoaWxkID0gZ2V0X2dsb2JhbF9pZChpZCwgYnVmZmVyTm9kZXNXaWR0aCwgXCIgKyBnZW9tZXRyeUxlbmd0aC50b0ZpeGVkKDEpICsgXCIpO1xcbiAgICAgICAgICAgICAgICB2ZWMyIHhHZW9tZXRyeVBhcmVudCA9IGdldF9nbG9iYWxfaWQoaWRJbnYsIGJ1ZmZlck5vZGVzV2lkdGgsIFwiICsgZ2VvbWV0cnlMZW5ndGgudG9GaXhlZCgxKSArIFwiKTtcXG5cXG4gICAgICAgICAgICAgICAgZmxvYXQgY2hpbGRHT3V0cHV0QSA9IGRhdGFCW3hHZW9tZXRyeUN1cnJlbnRDaGlsZF0uejtcXG4gICAgICAgICAgICAgICAgZmxvYXQgcGFyZW50R0Vycm9yQSA9IGRhdGFCW3hHZW9tZXRyeVBhcmVudF0udztcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGZsb2F0IGNoaWxkR091dHB1dEIgPSBkYXRhRlt4R2VvbWV0cnlDdXJyZW50Q2hpbGRdLng7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHBhcmVudEdFcnJvckIgPSBkYXRhRlt4R2VvbWV0cnlQYXJlbnRdLnk7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBmbG9hdCBjaGlsZEdPdXRwdXRDID0gZGF0YUZbeEdlb21ldHJ5Q3VycmVudENoaWxkXS56O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHRXJyb3JDID0gZGF0YUZbeEdlb21ldHJ5UGFyZW50XS53O1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgZmxvYXQgY2hpbGRHT3V0cHV0RCA9IGRhdGFHW3hHZW9tZXRyeUN1cnJlbnRDaGlsZF0ueDtcXG4gICAgICAgICAgICAgICAgZmxvYXQgcGFyZW50R0Vycm9yRCA9IGRhdGFHW3hHZW9tZXRyeVBhcmVudF0ueTtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGZsb2F0IGNoaWxkR091dHB1dEUgPSBkYXRhR1t4R2VvbWV0cnlDdXJyZW50Q2hpbGRdLno7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHBhcmVudEdFcnJvckUgPSBkYXRhR1t4R2VvbWV0cnlQYXJlbnRdLnc7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBmbG9hdCBjaGlsZEdPdXRwdXRGID0gZGF0YUhbeEdlb21ldHJ5Q3VycmVudENoaWxkXS54O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHRXJyb3JGID0gZGF0YUhbeEdlb21ldHJ5UGFyZW50XS55O1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgZmxvYXQgY2hpbGRHT3V0cHV0RyA9IGRhdGFIW3hHZW9tZXRyeUN1cnJlbnRDaGlsZF0uejtcXG4gICAgICAgICAgICAgICAgZmxvYXQgcGFyZW50R0Vycm9yRyA9IGRhdGFIW3hHZW9tZXRyeVBhcmVudF0udztcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgZmxvYXQgbHIgPSBsZWFybmluZ1JhdGU7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGwyX2RlY2F5ID0gMC4wMTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgZ3B1X2JhdGNoX3NpemUgPSA3LjA7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGJyID0gZ3B1X2JhdGNoX3JlcGVhdHM7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBmbG9hdCBkZXJpdkEgPSAoY2hpbGRHT3V0cHV0QSA8IDAuMCkgPyAwLjAxIDogY2hpbGRHT3V0cHV0QTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgZGVyaXZCID0gKGNoaWxkR091dHB1dEIgPCAwLjApID8gMC4wMSA6IGNoaWxkR091dHB1dEI7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGRlcml2QyA9IChjaGlsZEdPdXRwdXRDIDwgMC4wKSA/IDAuMDEgOiBjaGlsZEdPdXRwdXRDO1xcbiAgICAgICAgICAgICAgICBmbG9hdCBkZXJpdkQgPSAoY2hpbGRHT3V0cHV0RCA8IDAuMCkgPyAwLjAxIDogY2hpbGRHT3V0cHV0RDtcXG4gICAgICAgICAgICAgICAgZmxvYXQgZGVyaXZFID0gKGNoaWxkR091dHB1dEUgPCAwLjApID8gMC4wMSA6IGNoaWxkR091dHB1dEU7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGRlcml2RiA9IChjaGlsZEdPdXRwdXRGIDwgMC4wKSA/IDAuMDEgOiBjaGlsZEdPdXRwdXRGO1xcbiAgICAgICAgICAgICAgICBmbG9hdCBkZXJpdkcgPSAoY2hpbGRHT3V0cHV0RyA8IDAuMCkgPyAwLjAxIDogY2hpbGRHT3V0cHV0RztcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGlmKGxpbmtMYXllck51bSA9PSBsYXllckNvdW50LTEuMCkge1xcbiAgICAgICAgICAgICAgICAgICAgZGVyaXZBID0gY2hpbGRHT3V0cHV0QTtcXG4gICAgICAgICAgICAgICAgICAgIGRlcml2QiA9IGNoaWxkR091dHB1dEE7XFxuICAgICAgICAgICAgICAgICAgICBkZXJpdkMgPSBjaGlsZEdPdXRwdXRBO1xcbiAgICAgICAgICAgICAgICAgICAgZGVyaXZEID0gY2hpbGRHT3V0cHV0QTtcXG4gICAgICAgICAgICAgICAgICAgIGRlcml2RSA9IGNoaWxkR091dHB1dEE7XFxuICAgICAgICAgICAgICAgICAgICBkZXJpdkYgPSBjaGlsZEdPdXRwdXRBO1xcbiAgICAgICAgICAgICAgICAgICAgZGVyaXZHID0gY2hpbGRHT3V0cHV0QTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgbGlua1dlaWdodCArPSAoLWxyKnBhcmVudEdFcnJvckEqZGVyaXZBKS8oZ3B1X2JhdGNoX3NpemUqYnIpO1xcbiAgICAgICAgICAgICAgICBsaW5rV2VpZ2h0ICs9ICgtbHIqcGFyZW50R0Vycm9yQipkZXJpdkIpLyhncHVfYmF0Y2hfc2l6ZSpicik7XFxuICAgICAgICAgICAgICAgIGxpbmtXZWlnaHQgKz0gKC1scipwYXJlbnRHRXJyb3JDKmRlcml2QykvKGdwdV9iYXRjaF9zaXplKmJyKTtcXG4gICAgICAgICAgICAgICAgbGlua1dlaWdodCArPSAoLWxyKnBhcmVudEdFcnJvckQqZGVyaXZEKS8oZ3B1X2JhdGNoX3NpemUqYnIpO1xcbiAgICAgICAgICAgICAgICBsaW5rV2VpZ2h0ICs9ICgtbHIqcGFyZW50R0Vycm9yRSpkZXJpdkUpLyhncHVfYmF0Y2hfc2l6ZSpicik7XFxuICAgICAgICAgICAgICAgIGxpbmtXZWlnaHQgKz0gKC1scipwYXJlbnRHRXJyb3JGKmRlcml2RikvKGdwdV9iYXRjaF9zaXplKmJyKTtcXG4gICAgICAgICAgICAgICAgbGlua1dlaWdodCArPSAoLWxyKnBhcmVudEdFcnJvckcqZGVyaXZHKS8oZ3B1X2JhdGNoX3NpemUqYnIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICByZXR1cm4gW3ZlYzQobGlua0xheWVyTnVtLCAwLjAsIGxpbmtXZWlnaHQsIGxpbmtUeXBlUGFyZW50KV07XFxuICAgICAgICAgICAgXCJdO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEtFUk5FTF9BREpNQVRSSVhfVVBEQVRFO1xufSgpO1xuXG5nbG9iYWwuS0VSTkVMX0FESk1BVFJJWF9VUERBVEUgPSBLRVJORUxfQURKTUFUUklYX1VQREFURTsiXX0=
