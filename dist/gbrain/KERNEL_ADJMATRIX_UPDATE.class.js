(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var KERNEL_ADJMATRIX_UPDATE = exports.KERNEL_ADJMATRIX_UPDATE = function () {
    function KERNEL_ADJMATRIX_UPDATE() {
        _classCallCheck(this, KERNEL_ADJMATRIX_UPDATE);
    }

    _createClass(KERNEL_ADJMATRIX_UPDATE, null, [{
        key: "getSrc",
        value: function getSrc(geometryLength) {
            return ["x", ["adjacencyMatrix", "adjacencyMatrixB", "adjacencyMatrixC", "adjacencyMatrixD"],
            // head
            "",

            // source
            "vec4 adjMat = adjacencyMatrix[x]; \n            vec4 adjMatB = adjacencyMatrixB[x];\n            vec4 adjMatC = adjacencyMatrixC[x];\n            vec4 adjMatD = adjacencyMatrixD[x];\n\n            float linkLayerNum = adjMat.x;\n            float weightQuadSum = adjMat.y;\n            float linkWeight = adjMat.z;\n            float linkTypeParent = adjMat.w;\n            \n            float multiplier = adjMatD.z;\n            float weightAbsSum = adjMatB.x;\n            float costA = adjMatB.y;\n            float costB = adjMatC.x;\n            float costC = adjMatC.y;\n            float costD = adjMatC.z;\n            float costE = adjMatC.w;\n            float costF = adjMatD.x;\n            float costG = adjMatD.y;\n            \n            if(multiplier != 1.0) {\n                linkWeight = multiplier;\n            } else if(currentTrainLayer == -10.0) { \n                costA = 0.0;\n                costB = 0.0;\n                costC = 0.0;\n                costD = 0.0;\n                costE = 0.0;\n                costF = 0.0;\n                costG = 0.0;\n            } else if(linkTypeParent == 0.5 && linkLayerNum >= 0.0) {\n                float id = adjMatB.z;\n                float idInv = adjMatB.w;\n            \n                vec2 xGeometryCurrentChild = get_global_id(id, bufferNodesWidth, " + geometryLength.toFixed(1) + ");\n                vec2 xGeometryParent = get_global_id(idInv, bufferNodesWidth, " + geometryLength.toFixed(1) + (");\n\n\n                float childBiasNode = dataB[xGeometryCurrentChild].x;\n                \n                float childGOutputA = dataB[xGeometryCurrentChild].z;\n                float childGOutputB = dataF[xGeometryCurrentChild].x;\n                float childGOutputC = dataF[xGeometryCurrentChild].z;\n                float childGOutputD = dataG[xGeometryCurrentChild].x;\n                float childGOutputE = dataG[xGeometryCurrentChild].z;\n                float childGOutputF = dataH[xGeometryCurrentChild].x;\n                float childGOutputG = dataH[xGeometryCurrentChild].z;\n                \n                \n                float parentGOutputA = dataB[xGeometryParent].z;\n                float parentGOutputB = dataF[xGeometryParent].x;\n                float parentGOutputC = dataF[xGeometryParent].z;\n                float parentGOutputD = dataG[xGeometryParent].x;\n                float parentGOutputE = dataG[xGeometryParent].z;\n                float parentGOutputF = dataH[xGeometryParent].x;\n                float parentGOutputG = dataH[xGeometryParent].z;\n                \n                float parentGDeltaA = dataB[xGeometryParent].y;\n                float parentGDeltaB = dataB[xGeometryParent].w;\n                float parentGDeltaC = dataF[xGeometryParent].y;\n                float parentGDeltaD = dataF[xGeometryParent].w;\n                float parentGDeltaE = dataG[xGeometryParent].y;\n                float parentGDeltaF = dataG[xGeometryParent].w;\n                float parentGDeltaG = dataH[xGeometryParent].y;\n                \n                \n                \n                float lr = learningRate;\n                float l1_decay = 0.0;\n                float l2_decay = 0.01;\n                float gpu_batch_size = 7.0;     \n                \n                if(currentTrainLayer == linkLayerNum) {\n                    if(weightQuadSum != 0.0) {                        \n                        float parentGOutputDerivA = 1.0;                    \n                        float parentGOutputDerivB = 1.0;\n                        float parentGOutputDerivC = 1.0;\n                        float parentGOutputDerivD = 1.0;\n                        float parentGOutputDerivE = 1.0;\n                        float parentGOutputDerivF = 1.0;\n                        float parentGOutputDerivG = 1.0;\n                        if(linkLayerNum < layerCount-2.0) {\n                            parentGOutputDerivA = (parentGOutputA <= 0.0) ? 0.01 : 1.0;                    \n                            parentGOutputDerivB = (parentGOutputB <= 0.0) ? 0.01 : 1.0;\n                            parentGOutputDerivC = (parentGOutputC <= 0.0) ? 0.01 : 1.0;\n                            parentGOutputDerivD = (parentGOutputD <= 0.0) ? 0.01 : 1.0;\n                            parentGOutputDerivE = (parentGOutputE <= 0.0) ? 0.01 : 1.0;\n                            parentGOutputDerivF = (parentGOutputF <= 0.0) ? 0.01 : 1.0;\n                            parentGOutputDerivG = (parentGOutputG <= 0.0) ? 0.01 : 1.0;\n                        }\n                        \n                        float dA = parentGDeltaA*parentGOutputDerivA;\n                        float dB = parentGDeltaB*parentGOutputDerivB;\n                        float dC = parentGDeltaC*parentGOutputDerivC;\n                        float dD = parentGDeltaD*parentGOutputDerivD;\n                        float dE = parentGDeltaE*parentGOutputDerivE;\n                        float dF = parentGDeltaF*parentGOutputDerivF;\n                        float dG = parentGDeltaG*parentGOutputDerivG;\n                        \n                        float wT = 0.0;\n                        wT += dA*childGOutputA;\n                        wT += dB*childGOutputB;\n                        wT += dC*childGOutputC;\n                        wT += dD*childGOutputD;\n                        wT += dE*childGOutputE;\n                        wT += dF*childGOutputF;\n                        wT += dG*childGOutputG;\n                        wT /= (gpu_batch_size*batch_repeats);\n                    \n                        costA = dA*linkWeight;\n                        costB = dB*linkWeight;\n                        costC = dC*linkWeight;\n                        costD = dD*linkWeight;\n                        costE = dE*linkWeight;\n                        costF = dF*linkWeight;\n                        costG = dG*linkWeight;\n                        \n                        linkWeight += -lr*(" + " wT);\n                        weightQuadSum = 0.0;\n                        weightAbsSum = 0.0;                        \n                    } else {\n                        weightQuadSum += linkWeight*linkWeight;\n                        weightAbsSum += abs(linkWeight);\n                    }\n                }\n            }\n            \n            return [vec4(linkLayerNum, weightQuadSum, linkWeight, linkTypeParent), vec4(weightAbsSum, costA, adjMatB.z, adjMatB.w), vec4(costB, costC, costD, costE), vec4(costF, costG, 0.0, 0.0)];\n            ")];
        }
    }]);

    return KERNEL_ADJMATRIX_UPDATE;
}();

global.KERNEL_ADJMATRIX_UPDATE = KERNEL_ADJMATRIX_UPDATE;
module.exports.KERNEL_ADJMATRIX_UPDATE = KERNEL_ADJMATRIX_UPDATE;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZ2JyYWluL0tFUk5FTF9BREpNQVRSSVhfVVBEQVRFLmNsYXNzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBLRVJORUxfQURKTUFUUklYX1VQREFURSA9IGV4cG9ydHMuS0VSTkVMX0FESk1BVFJJWF9VUERBVEUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gS0VSTkVMX0FESk1BVFJJWF9VUERBVEUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLRVJORUxfQURKTUFUUklYX1VQREFURSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEtFUk5FTF9BREpNQVRSSVhfVVBEQVRFLCBudWxsLCBbe1xuICAgICAgICBrZXk6IFwiZ2V0U3JjXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTcmMoZ2VvbWV0cnlMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXCJ4XCIsIFtcImFkamFjZW5jeU1hdHJpeFwiLCBcImFkamFjZW5jeU1hdHJpeEJcIiwgXCJhZGphY2VuY3lNYXRyaXhDXCIsIFwiYWRqYWNlbmN5TWF0cml4RFwiXSxcbiAgICAgICAgICAgIC8vIGhlYWRcbiAgICAgICAgICAgIFwiXCIsXG5cbiAgICAgICAgICAgIC8vIHNvdXJjZVxuICAgICAgICAgICAgXCJ2ZWM0IGFkak1hdCA9IGFkamFjZW5jeU1hdHJpeFt4XTsgXFxuICAgICAgICAgICAgdmVjNCBhZGpNYXRCID0gYWRqYWNlbmN5TWF0cml4Qlt4XTtcXG4gICAgICAgICAgICB2ZWM0IGFkak1hdEMgPSBhZGphY2VuY3lNYXRyaXhDW3hdO1xcbiAgICAgICAgICAgIHZlYzQgYWRqTWF0RCA9IGFkamFjZW5jeU1hdHJpeERbeF07XFxuXFxuICAgICAgICAgICAgZmxvYXQgbGlua0xheWVyTnVtID0gYWRqTWF0Lng7XFxuICAgICAgICAgICAgZmxvYXQgd2VpZ2h0UXVhZFN1bSA9IGFkak1hdC55O1xcbiAgICAgICAgICAgIGZsb2F0IGxpbmtXZWlnaHQgPSBhZGpNYXQuejtcXG4gICAgICAgICAgICBmbG9hdCBsaW5rVHlwZVBhcmVudCA9IGFkak1hdC53O1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG11bHRpcGxpZXIgPSBhZGpNYXRELno7XFxuICAgICAgICAgICAgZmxvYXQgd2VpZ2h0QWJzU3VtID0gYWRqTWF0Qi54O1xcbiAgICAgICAgICAgIGZsb2F0IGNvc3RBID0gYWRqTWF0Qi55O1xcbiAgICAgICAgICAgIGZsb2F0IGNvc3RCID0gYWRqTWF0Qy54O1xcbiAgICAgICAgICAgIGZsb2F0IGNvc3RDID0gYWRqTWF0Qy55O1xcbiAgICAgICAgICAgIGZsb2F0IGNvc3REID0gYWRqTWF0Qy56O1xcbiAgICAgICAgICAgIGZsb2F0IGNvc3RFID0gYWRqTWF0Qy53O1xcbiAgICAgICAgICAgIGZsb2F0IGNvc3RGID0gYWRqTWF0RC54O1xcbiAgICAgICAgICAgIGZsb2F0IGNvc3RHID0gYWRqTWF0RC55O1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGlmKG11bHRpcGxpZXIgIT0gMS4wKSB7XFxuICAgICAgICAgICAgICAgIGxpbmtXZWlnaHQgPSBtdWx0aXBsaWVyO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZihjdXJyZW50VHJhaW5MYXllciA9PSAtMTAuMCkgeyBcXG4gICAgICAgICAgICAgICAgY29zdEEgPSAwLjA7XFxuICAgICAgICAgICAgICAgIGNvc3RCID0gMC4wO1xcbiAgICAgICAgICAgICAgICBjb3N0QyA9IDAuMDtcXG4gICAgICAgICAgICAgICAgY29zdEQgPSAwLjA7XFxuICAgICAgICAgICAgICAgIGNvc3RFID0gMC4wO1xcbiAgICAgICAgICAgICAgICBjb3N0RiA9IDAuMDtcXG4gICAgICAgICAgICAgICAgY29zdEcgPSAwLjA7XFxuICAgICAgICAgICAgfSBlbHNlIGlmKGxpbmtUeXBlUGFyZW50ID09IDAuNSAmJiBsaW5rTGF5ZXJOdW0gPj0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGlkID0gYWRqTWF0Qi56O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBpZEludiA9IGFkak1hdEIudztcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgdmVjMiB4R2VvbWV0cnlDdXJyZW50Q2hpbGQgPSBnZXRfZ2xvYmFsX2lkKGlkLCBidWZmZXJOb2Rlc1dpZHRoLCBcIiArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyBcIik7XFxuICAgICAgICAgICAgICAgIHZlYzIgeEdlb21ldHJ5UGFyZW50ID0gZ2V0X2dsb2JhbF9pZChpZEludiwgYnVmZmVyTm9kZXNXaWR0aCwgXCIgKyBnZW9tZXRyeUxlbmd0aC50b0ZpeGVkKDEpICsgKFwiKTtcXG5cXG5cXG4gICAgICAgICAgICAgICAgZmxvYXQgY2hpbGRCaWFzTm9kZSA9IGRhdGFCW3hHZW9tZXRyeUN1cnJlbnRDaGlsZF0ueDtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGZsb2F0IGNoaWxkR091dHB1dEEgPSBkYXRhQlt4R2VvbWV0cnlDdXJyZW50Q2hpbGRdLno7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGNoaWxkR091dHB1dEIgPSBkYXRhRlt4R2VvbWV0cnlDdXJyZW50Q2hpbGRdLng7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGNoaWxkR091dHB1dEMgPSBkYXRhRlt4R2VvbWV0cnlDdXJyZW50Q2hpbGRdLno7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGNoaWxkR091dHB1dEQgPSBkYXRhR1t4R2VvbWV0cnlDdXJyZW50Q2hpbGRdLng7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGNoaWxkR091dHB1dEUgPSBkYXRhR1t4R2VvbWV0cnlDdXJyZW50Q2hpbGRdLno7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGNoaWxkR091dHB1dEYgPSBkYXRhSFt4R2VvbWV0cnlDdXJyZW50Q2hpbGRdLng7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGNoaWxkR091dHB1dEcgPSBkYXRhSFt4R2VvbWV0cnlDdXJyZW50Q2hpbGRdLno7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgZmxvYXQgcGFyZW50R091dHB1dEEgPSBkYXRhQlt4R2VvbWV0cnlQYXJlbnRdLno7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHBhcmVudEdPdXRwdXRCID0gZGF0YUZbeEdlb21ldHJ5UGFyZW50XS54O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHT3V0cHV0QyA9IGRhdGFGW3hHZW9tZXRyeVBhcmVudF0uejtcXG4gICAgICAgICAgICAgICAgZmxvYXQgcGFyZW50R091dHB1dEQgPSBkYXRhR1t4R2VvbWV0cnlQYXJlbnRdLng7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHBhcmVudEdPdXRwdXRFID0gZGF0YUdbeEdlb21ldHJ5UGFyZW50XS56O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHT3V0cHV0RiA9IGRhdGFIW3hHZW9tZXRyeVBhcmVudF0ueDtcXG4gICAgICAgICAgICAgICAgZmxvYXQgcGFyZW50R091dHB1dEcgPSBkYXRhSFt4R2VvbWV0cnlQYXJlbnRdLno7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHRGVsdGFBID0gZGF0YUJbeEdlb21ldHJ5UGFyZW50XS55O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHRGVsdGFCID0gZGF0YUJbeEdlb21ldHJ5UGFyZW50XS53O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHRGVsdGFDID0gZGF0YUZbeEdlb21ldHJ5UGFyZW50XS55O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHRGVsdGFEID0gZGF0YUZbeEdlb21ldHJ5UGFyZW50XS53O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHRGVsdGFFID0gZGF0YUdbeEdlb21ldHJ5UGFyZW50XS55O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHRGVsdGFGID0gZGF0YUdbeEdlb21ldHJ5UGFyZW50XS53O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHRGVsdGFHID0gZGF0YUhbeEdlb21ldHJ5UGFyZW50XS55O1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBmbG9hdCBsciA9IGxlYXJuaW5nUmF0ZTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgbDFfZGVjYXkgPSAwLjA7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGwyX2RlY2F5ID0gMC4wMTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgZ3B1X2JhdGNoX3NpemUgPSA3LjA7ICAgICBcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRUcmFpbkxheWVyID09IGxpbmtMYXllck51bSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYod2VpZ2h0UXVhZFN1bSAhPSAwLjApIHsgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHT3V0cHV0RGVyaXZBID0gMS4wOyAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcGFyZW50R091dHB1dERlcml2QiA9IDEuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHT3V0cHV0RGVyaXZDID0gMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBhcmVudEdPdXRwdXREZXJpdkQgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcGFyZW50R091dHB1dERlcml2RSA9IDEuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHT3V0cHV0RGVyaXZGID0gMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBhcmVudEdPdXRwdXREZXJpdkcgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobGlua0xheWVyTnVtIDwgbGF5ZXJDb3VudC0yLjApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50R091dHB1dERlcml2QSA9IChwYXJlbnRHT3V0cHV0QSA8PSAwLjApID8gMC4wMSA6IDEuMDsgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRHT3V0cHV0RGVyaXZCID0gKHBhcmVudEdPdXRwdXRCIDw9IDAuMCkgPyAwLjAxIDogMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRHT3V0cHV0RGVyaXZDID0gKHBhcmVudEdPdXRwdXRDIDw9IDAuMCkgPyAwLjAxIDogMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRHT3V0cHV0RGVyaXZEID0gKHBhcmVudEdPdXRwdXREIDw9IDAuMCkgPyAwLjAxIDogMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRHT3V0cHV0RGVyaXZFID0gKHBhcmVudEdPdXRwdXRFIDw9IDAuMCkgPyAwLjAxIDogMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRHT3V0cHV0RGVyaXZGID0gKHBhcmVudEdPdXRwdXRGIDw9IDAuMCkgPyAwLjAxIDogMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRHT3V0cHV0RGVyaXZHID0gKHBhcmVudEdPdXRwdXRHIDw9IDAuMCkgPyAwLjAxIDogMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkQSA9IHBhcmVudEdEZWx0YUEqcGFyZW50R091dHB1dERlcml2QTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkQiA9IHBhcmVudEdEZWx0YUIqcGFyZW50R091dHB1dERlcml2QjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkQyA9IHBhcmVudEdEZWx0YUMqcGFyZW50R091dHB1dERlcml2QztcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkRCA9IHBhcmVudEdEZWx0YUQqcGFyZW50R091dHB1dERlcml2RDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkRSA9IHBhcmVudEdEZWx0YUUqcGFyZW50R091dHB1dERlcml2RTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkRiA9IHBhcmVudEdEZWx0YUYqcGFyZW50R091dHB1dERlcml2RjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkRyA9IHBhcmVudEdEZWx0YUcqcGFyZW50R091dHB1dERlcml2RztcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB3VCA9IDAuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICB3VCArPSBkQSpjaGlsZEdPdXRwdXRBO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHdUICs9IGRCKmNoaWxkR091dHB1dEI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgd1QgKz0gZEMqY2hpbGRHT3V0cHV0QztcXG4gICAgICAgICAgICAgICAgICAgICAgICB3VCArPSBkRCpjaGlsZEdPdXRwdXREO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHdUICs9IGRFKmNoaWxkR091dHB1dEU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgd1QgKz0gZEYqY2hpbGRHT3V0cHV0RjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB3VCArPSBkRypjaGlsZEdPdXRwdXRHO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHdUIC89IChncHVfYmF0Y2hfc2l6ZSpiYXRjaF9yZXBlYXRzKTtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvc3RBID0gZEEqbGlua1dlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3N0QiA9IGRCKmxpbmtXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29zdEMgPSBkQypsaW5rV2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvc3REID0gZEQqbGlua1dlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3N0RSA9IGRFKmxpbmtXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29zdEYgPSBkRipsaW5rV2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvc3RHID0gZEcqbGlua1dlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rV2VpZ2h0ICs9IC1sciooXCIgKyBcIiB3VCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0UXVhZFN1bSA9IDAuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRBYnNTdW0gPSAwLjA7ICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodFF1YWRTdW0gKz0gbGlua1dlaWdodCpsaW5rV2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodEFic1N1bSArPSBhYnMobGlua1dlaWdodCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgcmV0dXJuIFt2ZWM0KGxpbmtMYXllck51bSwgd2VpZ2h0UXVhZFN1bSwgbGlua1dlaWdodCwgbGlua1R5cGVQYXJlbnQpLCB2ZWM0KHdlaWdodEFic1N1bSwgY29zdEEsIGFkak1hdEIueiwgYWRqTWF0Qi53KSwgdmVjNChjb3N0QiwgY29zdEMsIGNvc3RELCBjb3N0RSksIHZlYzQoY29zdEYsIGNvc3RHLCAwLjAsIDAuMCldO1xcbiAgICAgICAgICAgIFwiKV07XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gS0VSTkVMX0FESk1BVFJJWF9VUERBVEU7XG59KCk7XG5cbmdsb2JhbC5LRVJORUxfQURKTUFUUklYX1VQREFURSA9IEtFUk5FTF9BREpNQVRSSVhfVVBEQVRFO1xubW9kdWxlLmV4cG9ydHMuS0VSTkVMX0FESk1BVFJJWF9VUERBVEUgPSBLRVJORUxfQURKTUFUUklYX1VQREFURTsiXX0=
