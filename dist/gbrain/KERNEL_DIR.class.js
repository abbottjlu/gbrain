(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
                    value: true
});
exports.KERNEL_DIR = undefined;

var _createClass = function () {
                    function defineProperties(target, props) {
                                        for (var i = 0; i < props.length; i++) {
                                                            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
                                        }
                    }return function (Constructor, protoProps, staticProps) {
                                        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
                    };
}();

var _graphUtil = require("./graphUtil");

function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                                        throw new TypeError("Cannot call a class as a function");
                    }
}

var KERNEL_DIR = exports.KERNEL_DIR = function () {
                    function KERNEL_DIR() {
                                        _classCallCheck(this, KERNEL_DIR);
                    }

                    _createClass(KERNEL_DIR, null, [{
                                        key: "getSrc",
                                        value: function getSrc(customCode, geometryLength, efferentStart, efferentNodesCount) {
                                                            var outputArr = ["dir", "posXYZW", "dataB", "dataF", "dataG", "dataH"];
                                                            var returnStr = 'return [vec4(currentDir, 1.0), vec4(currentPos.x, currentPos.y, currentPos.z, 1.0), currentDataB, currentDataF, currentDataG, currentDataH];';

                                                            return ["x", outputArr,
                                                            // head
                                                            _graphUtil.GraphUtils.adjMatrix_ForceLayout_GLSLFunctionString(geometryLength, efferentStart, efferentNodesCount),

                                                            // source
                                                            "float nodeId = data[x].x;\n                    float numOfConnections = data[x].y;\n                    vec2 xGeometry = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n                    vec3 currentPos = posXYZW[xGeometry].xyz;\n                    vec3 currentDir = dir[xGeometry].xyz;\n\n\n                    vec4 currentDataB = dataB[xGeometry];\n                    vec4 currentDataF = dataF[xGeometry];\n                    vec4 currentDataG = dataG[xGeometry];\n                    vec4 currentDataH = dataH[xGeometry];\n\n                    currentDir = vec3(0.0, 0.0, 0.0);\n\n                    idAdjMatrixResponse adjM = idAdjMatrix_ForceLayout(nodeId, currentPos, currentDir, numOfConnections);\n                    currentDir += adjM.force;\n\n                    if(currentTrainLayer == -3.0) {\n                        currentDataB = vec4(currentDataB.x, currentDataB.y, adjM.netFOutputA, adjM.netErrorWeightA);\n                        currentDataF = vec4(adjM.netFOutputB, adjM.netErrorWeightB, adjM.netFOutputC, adjM.netErrorWeightC);\n                        currentDataG = vec4(adjM.netFOutputD, adjM.netErrorWeightD, adjM.netFOutputE, adjM.netErrorWeightE);\n                        currentDataH = vec4(adjM.netFOutputF, adjM.netErrorWeightF, adjM.netFOutputG, adjM.netErrorWeightG);\n                    }\n\n                    " + (customCode !== undefined ? customCode : '') + "\n\n                    if(enableDrag == 1.0) {\n                        if(nodeId == idToDrag) {\n                            currentPos = vec3(MouseDragTranslationX, MouseDragTranslationY, MouseDragTranslationZ);\n                        }\n                    }\n\n                    currentPos += currentDir;\n                    if(only2d == 1.0) {\n                        currentPos.y = 0.0;\n                    }\n\n                    " + returnStr];
                                        }
                    }]);

                    return KERNEL_DIR;
}();

global.KERNEL_DIR = KERNEL_DIR;
module.exports.KERNEL_DIR = KERNEL_DIR;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./graphUtil":2}],2:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var GraphUtils = exports.GraphUtils = function () {
    function GraphUtils() {
        _classCallCheck(this, GraphUtils);
    }

    _createClass(GraphUtils, null, [{
        key: "nodesDrawMode",
        value: function nodesDrawMode(geometryLength) {
            if (geometryLength === 1) return "vec4(color.rgb, 1.0)";else return "vec4(tex.rgb*color.rgb, tex.a)";
        }
    }, {
        key: "adjMatrix_ForceLayout_GLSLFunctionString",
        value: function adjMatrix_ForceLayout_GLSLFunctionString(geometryLength, efferentStart, efferentNodesCount) {
            return '' + "struct CalculationResponse {\n            vec3 atraction;\n            float acumAtraction;\n            vec3 repulsion;\n            float netChildInputSumA;\n            float netParentErrorWeightA;\n            float netChildInputSumB;\n            float netParentErrorWeightB;\n            float netChildInputSumC;\n            float netParentErrorWeightC;\n            float netChildInputSumD;\n            float netParentErrorWeightD;\n            float netChildInputSumE;\n            float netParentErrorWeightE;\n            float netChildInputSumF;\n            float netParentErrorWeightF;\n            float netChildInputSumG;\n            float netParentErrorWeightG;\n        };" + "CalculationResponse calculate(float nodeId,\n                                        vec4 pixAdjMatACurrent, vec4 pixAdjMatAOpposite,\n                                        vec4 pixAdjMatBCurrent, vec4 pixAdjMatBOpposite,\n                                        vec2 xGeomCurrent, vec2 xGeomOpposite,\n                                        vec3 currentPos, vec3 currentDir,\n                                        vec3 atraction, float acumAtraction, vec3 repulsion,\n                                        float netChildInputSumA, float netParentErrorWeightA,\n                                        float netChildInputSumB, float netParentErrorWeightB,\n                                        float netChildInputSumC, float netParentErrorWeightC,\n                                        float netChildInputSumD, float netParentErrorWeightD,\n                                        float netChildInputSumE, float netParentErrorWeightE,\n                                        float netChildInputSumF, float netParentErrorWeightF,\n                                        float netChildInputSumG, float netParentErrorWeightG) {" +
            // pixAdjMatACurrent
            "float currentWeight = pixAdjMatACurrent.z;\n            float currentIsParent = pixAdjMatACurrent.w;" +

            // pixAdjMatAOpposite
            "float oppositeWeight = pixAdjMatAOpposite.z;\n            float oppositeIsParent = pixAdjMatAOpposite.w;" +

            // pixAdjMatBCurrent
            "float currentLinkMultiplier = pixAdjMatBCurrent.x;\n            float currentActivationFn = pixAdjMatBCurrent.y;" +

            // pixAdjMatBOpposite
            "float oppositeLinkMultiplier = pixAdjMatBOpposite.x;\n            float oppositeActivationFn = pixAdjMatBOpposite.y;" +

            // dataB Current
            //'float currentBiasNode = dataB[xGeomCurrent].x;'+
            //'float currentNetOutput = dataB[xGeomCurrent].z;'+
            //'float currentNetError = dataB[xGeomCurrent].w;'+

            // dataB Opposite
            //'float oppositeBiasNode = dataB[xGeomOpposite].x;'+
            "float oppositeNetOutputA = dataB[xGeomOpposite].z;\n            float oppositeNetErrorA = dataB[xGeomOpposite].w;\n\n            float oppositeNetOutputB = dataF[xGeomOpposite].x;\n            float oppositeNetErrorB = dataF[xGeomOpposite].y;\n        \n            float oppositeNetOutputC = dataF[xGeomOpposite].z;\n            float oppositeNetErrorC = dataF[xGeomOpposite].w;\n        \n            float oppositeNetOutputD = dataG[xGeomOpposite].x;\n            float oppositeNetErrorD = dataG[xGeomOpposite].y;\n        \n            float oppositeNetOutputE = dataG[xGeomOpposite].z;\n            float oppositeNetErrorE = dataG[xGeomOpposite].w;\n        \n            float oppositeNetOutputF = dataH[xGeomOpposite].x;\n            float oppositeNetErrorF = dataH[xGeomOpposite].y;\n        \n            float oppositeNetOutputG = dataH[xGeomOpposite].z;\n            float oppositeNetErrorG = dataH[xGeomOpposite].w;" +

            // pos & dir Current
            //'vec3 currentPos = posXYZW[xGeomCurrent].xyz;\n'+
            //'vec3 currentDir = dir[xGeomCurrent].xyz;\n'+

            // pos & dir Opposite
            "vec3 oppositePos = posXYZW[xGeomOpposite].xyz;\n            vec3 oppositeDir = dir[xGeomOpposite].xyz;" +

            // dir / dist to opposite
            'vec3 dirToOpposite = (oppositePos-currentPos);\n' + 'vec3 dirToOppositeN = normalize(dirToOpposite);\n' + 'float dist = distance(oppositePos, currentPos);\n' + // near=0.0 ; far=1.0
            'float distN = max(0.0,dist)/100000.0;' + 'float m1 = 0.0;' + // 400000.0
            'float m2 = 0.0;' + // 48.0
            'if(currentIsParent == 1.0) {' + 'netChildInputSumA += oppositeNetOutputA*oppositeWeight;' + 'netChildInputSumB += oppositeNetOutputB*oppositeWeight;' + 'netChildInputSumC += oppositeNetOutputC*oppositeWeight;' + 'netChildInputSumD += oppositeNetOutputD*oppositeWeight;' + 'netChildInputSumE += oppositeNetOutputE*oppositeWeight;' + 'netChildInputSumF += oppositeNetOutputF*oppositeWeight;' + 'netChildInputSumG += oppositeNetOutputG*oppositeWeight;' + 'atraction += dirToOppositeN*max(1.0, distN*abs(oppositeWeight)*(m1/2.0));\n' + 'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(oppositeWeight)*(m2/2.0));\n' + 'acumAtraction += 1.0;\n' + '} else if(currentIsParent == 0.5) {' + 'netParentErrorWeightA += oppositeNetErrorA*currentWeight;' + 'netParentErrorWeightB += oppositeNetErrorB*currentWeight;' + 'netParentErrorWeightC += oppositeNetErrorC*currentWeight;' + 'netParentErrorWeightD += oppositeNetErrorD*currentWeight;' + 'netParentErrorWeightE += oppositeNetErrorE*currentWeight;' + 'netParentErrorWeightF += oppositeNetErrorF*currentWeight;' + 'netParentErrorWeightG += oppositeNetErrorG*currentWeight;' + 'atraction += dirToOppositeN*max(1.0, distN*abs(currentWeight)*m1);\n' + 'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*m2);\n' + 'acumAtraction += 1.0;\n' + '}' + 'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*(m2/8.0));\n' + 'acumAtraction += 1.0;\n' + ("return CalculationResponse(atraction, acumAtraction, repulsion,\n                                        netChildInputSumA, netParentErrorWeightA,\n                                        netChildInputSumB, netParentErrorWeightB,\n                                        netChildInputSumC, netParentErrorWeightC,\n                                        netChildInputSumD, netParentErrorWeightD,\n                                        netChildInputSumE, netParentErrorWeightE,\n                                        netChildInputSumF, netParentErrorWeightF,\n                                        netChildInputSumG, netParentErrorWeightG);\n        }\n        struct idAdjMatrixResponse {\n            vec3 force;\n            float netFOutputA;\n            float netErrorWeightA;\n            float netFOutputB;\n            float netErrorWeightB;\n            float netFOutputC;\n            float netErrorWeightC;\n            float netFOutputD;\n            float netErrorWeightD;\n            float netFOutputE;\n            float netErrorWeightE;\n            float netFOutputF;\n            float netErrorWeightF;\n            float netFOutputG;\n            float netErrorWeightG;\n        };\n        float tanh(float val) {\n            float tmp = exp(val);\n            float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n            return tanH;\n        }\n        float sigm(float val) {\n            return (1.0 / (1.0 + exp(-val)));\n        }\n        idAdjMatrixResponse idAdjMatrix_ForceLayout(float nodeId, vec3 currentPos, vec3 currentDir, float numOfConnections) {\n            vec3 atraction = vec3(0.0, 0.0, 0.0);\n            float acumAtraction = 1.0;\n            vec3 repulsion = vec3(0.0, 0.0, 0.0);\n\n            vec3 force = vec3(0.0, 0.0, 0.0);\n\n\n            float netChildInputSumA = 0.0;\n            float foutputA = 0.0;\n            float netParentErrorWeightA = 0.0;\n            \n            float netChildInputSumB = 0.0;\n            float foutputB = 0.0;\n            float netParentErrorWeightB = 0.0;\n            \n            float netChildInputSumC = 0.0;\n            float foutputC = 0.0;\n            float netParentErrorWeightC = 0.0;\n            \n            float netChildInputSumD = 0.0;\n            float foutputD = 0.0;\n            float netParentErrorWeightD = 0.0;\n            \n            float netChildInputSumE = 0.0;\n            float foutputE = 0.0;\n            float netParentErrorWeightE = 0.0;\n            \n            float netChildInputSumF = 0.0;\n            float foutputF = 0.0;\n            float netParentErrorWeightF = 0.0;\n            \n            float netChildInputSumG = 0.0;\n            float foutputG = 0.0;\n            float netParentErrorWeightG = 0.0;\n            \n\n            if(nodeId < nodesCount) {\n                float currentActivationFn = 0.0;\n                vec2 xGeomCurrent = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n                for(int n=0; n < 4096; n++) {\n                    if(float(n) >= nodesCount) {break;}\n                    if(float(n) != nodeId) {\n                        vec2 xGeomOpposite = get_global_id(float(n), uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n                        vec2 xAdjMatCurrent = get_global_id(vec2(float(n), nodeId), widthAdjMatrix);\n                        vec2 xAdjMatOpposite = get_global_id(vec2(nodeId, float(n)), widthAdjMatrix);\n\n                        vec4 pixAdjMatACurrent = adjacencyMatrix[xAdjMatCurrent];\n                        vec4 pixAdjMatAOpposite = adjacencyMatrix[xAdjMatOpposite];\n\n                        vec4 pixAdjMatBCurrent = adjacencyMatrixB[xAdjMatCurrent];\n                        vec4 pixAdjMatBOpposite = adjacencyMatrixB[xAdjMatOpposite];\n\n\n                        CalculationResponse calcResponse = calculate(nodeId,\n                                                                    pixAdjMatACurrent, pixAdjMatAOpposite,\n                                                                    pixAdjMatBCurrent, pixAdjMatBOpposite,\n                                                                    xGeomCurrent, xGeomOpposite,\n                                                                    currentPos, currentDir,\n                                                                    atraction, acumAtraction, repulsion,\n                                                                    netChildInputSumA, netParentErrorWeightA,\n                                                                    netChildInputSumB, netParentErrorWeightB,\n                                                                    netChildInputSumC, netParentErrorWeightC,\n                                                                    netChildInputSumD, netParentErrorWeightD,\n                                                                    netChildInputSumE, netParentErrorWeightE,\n                                                                    netChildInputSumF, netParentErrorWeightF,\n                                                                    netChildInputSumG, netParentErrorWeightG);\n                        atraction = calcResponse.atraction;\n                        acumAtraction = calcResponse.acumAtraction;\n                        repulsion = calcResponse.repulsion;\n                        \n                        netChildInputSumA = calcResponse.netChildInputSumA;\n                        netParentErrorWeightA = calcResponse.netParentErrorWeightA;\n                        \n                        netChildInputSumB = calcResponse.netChildInputSumB;\n                        netParentErrorWeightB = calcResponse.netParentErrorWeightB;\n                        \n                        netChildInputSumC = calcResponse.netChildInputSumC;\n                        netParentErrorWeightC = calcResponse.netParentErrorWeightC;\n                        \n                        netChildInputSumD = calcResponse.netChildInputSumD;\n                        netParentErrorWeightD = calcResponse.netParentErrorWeightD;\n                        \n                        netChildInputSumE = calcResponse.netChildInputSumE;\n                        netParentErrorWeightE = calcResponse.netParentErrorWeightE;\n                        \n                        netChildInputSumF = calcResponse.netChildInputSumF;\n                        netParentErrorWeightF = calcResponse.netParentErrorWeightF;\n                        \n                        netChildInputSumG = calcResponse.netChildInputSumG;\n                        netParentErrorWeightG = calcResponse.netParentErrorWeightG;\n                    }\n                }\n                force += (atraction/acumAtraction);\n                force += (repulsion/acumAtraction);\n                \n                " + GraphUtils.efferentNodesStr(efferentStart, efferentNodesCount) + "\n            }\n\n            return idAdjMatrixResponse(vec3(force),\n                                        foutputA, netParentErrorWeightA,\n                                        foutputB, netParentErrorWeightB,\n                                        foutputC, netParentErrorWeightC,\n                                        foutputD, netParentErrorWeightD,\n                                        foutputE, netParentErrorWeightE,\n                                        foutputF, netParentErrorWeightF,\n                                        foutputG, netParentErrorWeightG);\n        }");
        }
    }, {
        key: "efferentNodesStr",
        value: function efferentNodesStr(efferentStart, efferentNodesCount) {
            var str = "\n            if(nodeId < afferentNodesCount) {\n                for(float n=0.0; n < 1024.0; n+=1.0) {\n                    if(n >= afferentNodesCount) {\n                        break;\n                    }\n                    if(nodeId == n) {\n                        foutputA = afferentNodesA[int(n)];\n                        foutputB = afferentNodesB[int(n)];\n                        foutputC = afferentNodesC[int(n)];\n                        foutputD = afferentNodesD[int(n)];\n                        foutputE = afferentNodesE[int(n)];\n                        foutputF = afferentNodesF[int(n)];\n                        foutputG = afferentNodesG[int(n)];\n                        break;\n                    }\n                }\n            } else {\n                foutputA = max(0.0, netChildInputSumA); " + "\n                foutputB = max(0.0, netChildInputSumB);\n                foutputC = max(0.0, netChildInputSumC);\n                foutputD = max(0.0, netChildInputSumD);\n                foutputE = max(0.0, netChildInputSumE);\n                foutputF = max(0.0, netChildInputSumF);\n                foutputG = max(0.0, netChildInputSumG);\n            }";

            str += "\n        if(nodeId == " + efferentStart.toFixed(1) + (") {\n            netParentErrorWeightA = (efferentNodesA[0] != 0.0) ? netChildInputSumA-efferentNodesA[0] : 0.0;\n            " + "\n            netParentErrorWeightB = (efferentNodesB[0] != 0.0) ? netChildInputSumB-efferentNodesB[0] : 0.0;\n            " + "\n            netParentErrorWeightC = (efferentNodesC[0] != 0.0) ? netChildInputSumC-efferentNodesC[0] : 0.0;\n            " + "\n            netParentErrorWeightD = (efferentNodesD[0] != 0.0) ? netChildInputSumD-efferentNodesD[0] : 0.0;\n            " + "\n            netParentErrorWeightE = (efferentNodesE[0] != 0.0) ? netChildInputSumE-efferentNodesE[0] : 0.0;\n            " + "\n            netParentErrorWeightF = (efferentNodesF[0] != 0.0) ? netChildInputSumF-efferentNodesF[0] : 0.0;\n            " + "\n            netParentErrorWeightG = (efferentNodesG[0] != 0.0) ? netChildInputSumG-efferentNodesG[0] : 0.0;\n            " + "\n        }");
            for (var n = efferentStart + 1; n < efferentStart + efferentNodesCount; n++) {
                str += "\n            else if(nodeId == " + n.toFixed(1) + ") {\n                netParentErrorWeightA = (efferentNodesA[" + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumA-efferentNodesA[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightB = (efferentNodesB[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumB-efferentNodesB[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightC = (efferentNodesC[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumC-efferentNodesC[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightD = (efferentNodesD[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumD-efferentNodesD[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightE = (efferentNodesE[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumE-efferentNodesE[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightF = (efferentNodesF[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumF-efferentNodesF[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightG = (efferentNodesG[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumG-efferentNodesG[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n            }");
            }str += "\n        else {\n            if(foutputA <= 0.0) {\n                netParentErrorWeightA = 0.0;\n            }\n            if(foutputB <= 0.0) {\n                netParentErrorWeightB = 0.0;\n            }\n            if(foutputC <= 0.0) {\n                netParentErrorWeightC = 0.0;\n            }\n            if(foutputD <= 0.0) {\n                netParentErrorWeightD = 0.0;\n            }\n            if(foutputE <= 0.0) {\n                netParentErrorWeightE = 0.0;\n            }\n            if(foutputF <= 0.0) {\n                netParentErrorWeightF = 0.0;\n            }\n            if(foutputG <= 0.0) {\n                netParentErrorWeightG = 0.0;\n            }\n        }";

            return str;
        }
    }]);

    return GraphUtils;
}();

global.GraphUtils = GraphUtils;
module.exports.GraphUtils = GraphUtils;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZ2JyYWluL0tFUk5FTF9ESVIuY2xhc3MuanMiLCJzcmMvZ2JyYWluL2dyYXBoVXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuS0VSTkVMX0RJUiA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO2lmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfXJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtyZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIH07XG59KCk7XG5cbnZhciBfZ3JhcGhVdGlsID0gcmVxdWlyZShcIi4vZ3JhcGhVdGlsXCIpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxufVxuXG52YXIgS0VSTkVMX0RJUiA9IGV4cG9ydHMuS0VSTkVMX0RJUiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gS0VSTkVMX0RJUigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS0VSTkVMX0RJUik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfY3JlYXRlQ2xhc3MoS0VSTkVMX0RJUiwgbnVsbCwgW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiZ2V0U3JjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNyYyhjdXN0b21Db2RlLCBnZW9tZXRyeUxlbmd0aCwgZWZmZXJlbnRTdGFydCwgZWZmZXJlbnROb2Rlc0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0QXJyID0gW1wiZGlyXCIsIFwicG9zWFlaV1wiLCBcImRhdGFCXCIsIFwiZGF0YUZcIiwgXCJkYXRhR1wiLCBcImRhdGFIXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVyblN0ciA9ICdyZXR1cm4gW3ZlYzQoY3VycmVudERpciwgMS4wKSwgdmVjNChjdXJyZW50UG9zLngsIGN1cnJlbnRQb3MueSwgY3VycmVudFBvcy56LCAxLjApLCBjdXJyZW50RGF0YUIsIGN1cnJlbnREYXRhRiwgY3VycmVudERhdGFHLCBjdXJyZW50RGF0YUhdOyc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJ4XCIsIG91dHB1dEFycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ncmFwaFV0aWwuR3JhcGhVdGlscy5hZGpNYXRyaXhfRm9yY2VMYXlvdXRfR0xTTEZ1bmN0aW9uU3RyaW5nKGdlb21ldHJ5TGVuZ3RoLCBlZmZlcmVudFN0YXJ0LCBlZmZlcmVudE5vZGVzQ291bnQpLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxvYXQgbm9kZUlkID0gZGF0YVt4XS54O1xcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbnVtT2ZDb25uZWN0aW9ucyA9IGRhdGFbeF0ueTtcXG4gICAgICAgICAgICAgICAgICAgIHZlYzIgeEdlb21ldHJ5ID0gZ2V0X2dsb2JhbF9pZChub2RlSWQsIHVCdWZmZXJXaWR0aCwgXCIgKyBnZW9tZXRyeUxlbmd0aC50b0ZpeGVkKDEpICsgXCIpO1xcblxcblxcbiAgICAgICAgICAgICAgICAgICAgdmVjMyBjdXJyZW50UG9zID0gcG9zWFlaV1t4R2VvbWV0cnldLnh5ejtcXG4gICAgICAgICAgICAgICAgICAgIHZlYzMgY3VycmVudERpciA9IGRpclt4R2VvbWV0cnldLnh5ejtcXG5cXG5cXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgY3VycmVudERhdGFCID0gZGF0YUJbeEdlb21ldHJ5XTtcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgY3VycmVudERhdGFGID0gZGF0YUZbeEdlb21ldHJ5XTtcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgY3VycmVudERhdGFHID0gZGF0YUdbeEdlb21ldHJ5XTtcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgY3VycmVudERhdGFIID0gZGF0YUhbeEdlb21ldHJ5XTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREaXIgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgaWRBZGpNYXRyaXhSZXNwb25zZSBhZGpNID0gaWRBZGpNYXRyaXhfRm9yY2VMYXlvdXQobm9kZUlkLCBjdXJyZW50UG9zLCBjdXJyZW50RGlyLCBudW1PZkNvbm5lY3Rpb25zKTtcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREaXIgKz0gYWRqTS5mb3JjZTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRUcmFpbkxheWVyID09IC0zLjApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0YUIgPSB2ZWM0KGN1cnJlbnREYXRhQi54LCBjdXJyZW50RGF0YUIueSwgYWRqTS5uZXRGT3V0cHV0QSwgYWRqTS5uZXRFcnJvcldlaWdodEEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREYXRhRiA9IHZlYzQoYWRqTS5uZXRGT3V0cHV0QiwgYWRqTS5uZXRFcnJvcldlaWdodEIsIGFkak0ubmV0Rk91dHB1dEMsIGFkak0ubmV0RXJyb3JXZWlnaHRDKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0YUcgPSB2ZWM0KGFkak0ubmV0Rk91dHB1dEQsIGFkak0ubmV0RXJyb3JXZWlnaHRELCBhZGpNLm5ldEZPdXRwdXRFLCBhZGpNLm5ldEVycm9yV2VpZ2h0RSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERhdGFIID0gdmVjNChhZGpNLm5ldEZPdXRwdXRGLCBhZGpNLm5ldEVycm9yV2VpZ2h0RiwgYWRqTS5uZXRGT3V0cHV0RywgYWRqTS5uZXRFcnJvcldlaWdodEcpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgXCIgKyAoY3VzdG9tQ29kZSAhPT0gdW5kZWZpbmVkID8gY3VzdG9tQ29kZSA6ICcnKSArIFwiXFxuXFxuICAgICAgICAgICAgICAgICAgICBpZihlbmFibGVEcmFnID09IDEuMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5vZGVJZCA9PSBpZFRvRHJhZykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gdmVjMyhNb3VzZURyYWdUcmFuc2xhdGlvblgsIE1vdXNlRHJhZ1RyYW5zbGF0aW9uWSwgTW91c2VEcmFnVHJhbnNsYXRpb25aKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zICs9IGN1cnJlbnREaXI7XFxuICAgICAgICAgICAgICAgICAgICBpZihvbmx5MmQgPT0gMS4wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcy55ID0gMC4wO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgXCIgKyByZXR1cm5TdHJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBLRVJORUxfRElSO1xufSgpO1xuXG5nbG9iYWwuS0VSTkVMX0RJUiA9IEtFUk5FTF9ESVI7XG5tb2R1bGUuZXhwb3J0cy5LRVJORUxfRElSID0gS0VSTkVMX0RJUjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7aWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICB9cmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtyZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfTtcbn0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuXG52YXIgR3JhcGhVdGlscyA9IGV4cG9ydHMuR3JhcGhVdGlscyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmFwaFV0aWxzKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JhcGhVdGlscyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEdyYXBoVXRpbHMsIG51bGwsIFt7XG4gICAgICAgIGtleTogXCJub2Rlc0RyYXdNb2RlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBub2Rlc0RyYXdNb2RlKGdlb21ldHJ5TGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnlMZW5ndGggPT09IDEpIHJldHVybiBcInZlYzQoY29sb3IucmdiLCAxLjApXCI7ZWxzZSByZXR1cm4gXCJ2ZWM0KHRleC5yZ2IqY29sb3IucmdiLCB0ZXguYSlcIjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFkak1hdHJpeF9Gb3JjZUxheW91dF9HTFNMRnVuY3Rpb25TdHJpbmdcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkak1hdHJpeF9Gb3JjZUxheW91dF9HTFNMRnVuY3Rpb25TdHJpbmcoZ2VvbWV0cnlMZW5ndGgsIGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgXCJzdHJ1Y3QgQ2FsY3VsYXRpb25SZXNwb25zZSB7XFxuICAgICAgICAgICAgdmVjMyBhdHJhY3Rpb247XFxuICAgICAgICAgICAgZmxvYXQgYWN1bUF0cmFjdGlvbjtcXG4gICAgICAgICAgICB2ZWMzIHJlcHVsc2lvbjtcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEE7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUI7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRCO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1DO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QztcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEQ7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUU7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRFO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1GO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RjtcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRztcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEc7XFxuICAgICAgICB9O1wiICsgXCJDYWxjdWxhdGlvblJlc3BvbnNlIGNhbGN1bGF0ZShmbG9hdCBub2RlSWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0QUN1cnJlbnQsIHZlYzQgcGl4QWRqTWF0QU9wcG9zaXRlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEJDdXJyZW50LCB2ZWM0IHBpeEFkak1hdEJPcHBvc2l0ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMiB4R2VvbUN1cnJlbnQsIHZlYzIgeEdlb21PcHBvc2l0ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyBjdXJyZW50UG9zLCB2ZWMzIGN1cnJlbnREaXIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgYXRyYWN0aW9uLCBmbG9hdCBhY3VtQXRyYWN0aW9uLCB2ZWMzIHJlcHVsc2lvbixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUEsIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUIsIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUMsIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUQsIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUUsIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUYsIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUcsIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0Rykge1wiICtcbiAgICAgICAgICAgIC8vIHBpeEFkak1hdEFDdXJyZW50XG4gICAgICAgICAgICBcImZsb2F0IGN1cnJlbnRXZWlnaHQgPSBwaXhBZGpNYXRBQ3VycmVudC56O1xcbiAgICAgICAgICAgIGZsb2F0IGN1cnJlbnRJc1BhcmVudCA9IHBpeEFkak1hdEFDdXJyZW50Lnc7XCIgK1xuXG4gICAgICAgICAgICAvLyBwaXhBZGpNYXRBT3Bwb3NpdGVcbiAgICAgICAgICAgIFwiZmxvYXQgb3Bwb3NpdGVXZWlnaHQgPSBwaXhBZGpNYXRBT3Bwb3NpdGUuejtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUlzUGFyZW50ID0gcGl4QWRqTWF0QU9wcG9zaXRlLnc7XCIgK1xuXG4gICAgICAgICAgICAvLyBwaXhBZGpNYXRCQ3VycmVudFxuICAgICAgICAgICAgXCJmbG9hdCBjdXJyZW50TGlua011bHRpcGxpZXIgPSBwaXhBZGpNYXRCQ3VycmVudC54O1xcbiAgICAgICAgICAgIGZsb2F0IGN1cnJlbnRBY3RpdmF0aW9uRm4gPSBwaXhBZGpNYXRCQ3VycmVudC55O1wiICtcblxuICAgICAgICAgICAgLy8gcGl4QWRqTWF0Qk9wcG9zaXRlXG4gICAgICAgICAgICBcImZsb2F0IG9wcG9zaXRlTGlua011bHRpcGxpZXIgPSBwaXhBZGpNYXRCT3Bwb3NpdGUueDtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUFjdGl2YXRpb25GbiA9IHBpeEFkak1hdEJPcHBvc2l0ZS55O1wiICtcblxuICAgICAgICAgICAgLy8gZGF0YUIgQ3VycmVudFxuICAgICAgICAgICAgLy8nZmxvYXQgY3VycmVudEJpYXNOb2RlID0gZGF0YUJbeEdlb21DdXJyZW50XS54OycrXG4gICAgICAgICAgICAvLydmbG9hdCBjdXJyZW50TmV0T3V0cHV0ID0gZGF0YUJbeEdlb21DdXJyZW50XS56OycrXG4gICAgICAgICAgICAvLydmbG9hdCBjdXJyZW50TmV0RXJyb3IgPSBkYXRhQlt4R2VvbUN1cnJlbnRdLnc7JytcblxuICAgICAgICAgICAgLy8gZGF0YUIgT3Bwb3NpdGVcbiAgICAgICAgICAgIC8vJ2Zsb2F0IG9wcG9zaXRlQmlhc05vZGUgPSBkYXRhQlt4R2VvbU9wcG9zaXRlXS54OycrXG4gICAgICAgICAgICBcImZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0QSA9IGRhdGFCW3hHZW9tT3Bwb3NpdGVdLno7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckEgPSBkYXRhQlt4R2VvbU9wcG9zaXRlXS53O1xcblxcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0QiA9IGRhdGFGW3hHZW9tT3Bwb3NpdGVdLng7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckIgPSBkYXRhRlt4R2VvbU9wcG9zaXRlXS55O1xcbiAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRDID0gZGF0YUZbeEdlb21PcHBvc2l0ZV0uejtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yQyA9IGRhdGFGW3hHZW9tT3Bwb3NpdGVdLnc7XFxuICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEQgPSBkYXRhR1t4R2VvbU9wcG9zaXRlXS54O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0RXJyb3JEID0gZGF0YUdbeEdlb21PcHBvc2l0ZV0ueTtcXG4gICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0RSA9IGRhdGFHW3hHZW9tT3Bwb3NpdGVdLno7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckUgPSBkYXRhR1t4R2VvbU9wcG9zaXRlXS53O1xcbiAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRGID0gZGF0YUhbeEdlb21PcHBvc2l0ZV0ueDtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yRiA9IGRhdGFIW3hHZW9tT3Bwb3NpdGVdLnk7XFxuICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEcgPSBkYXRhSFt4R2VvbU9wcG9zaXRlXS56O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0RXJyb3JHID0gZGF0YUhbeEdlb21PcHBvc2l0ZV0udztcIiArXG5cbiAgICAgICAgICAgIC8vIHBvcyAmIGRpciBDdXJyZW50XG4gICAgICAgICAgICAvLyd2ZWMzIGN1cnJlbnRQb3MgPSBwb3NYWVpXW3hHZW9tQ3VycmVudF0ueHl6O1xcbicrXG4gICAgICAgICAgICAvLyd2ZWMzIGN1cnJlbnREaXIgPSBkaXJbeEdlb21DdXJyZW50XS54eXo7XFxuJytcblxuICAgICAgICAgICAgLy8gcG9zICYgZGlyIE9wcG9zaXRlXG4gICAgICAgICAgICBcInZlYzMgb3Bwb3NpdGVQb3MgPSBwb3NYWVpXW3hHZW9tT3Bwb3NpdGVdLnh5ejtcXG4gICAgICAgICAgICB2ZWMzIG9wcG9zaXRlRGlyID0gZGlyW3hHZW9tT3Bwb3NpdGVdLnh5ejtcIiArXG5cbiAgICAgICAgICAgIC8vIGRpciAvIGRpc3QgdG8gb3Bwb3NpdGVcbiAgICAgICAgICAgICd2ZWMzIGRpclRvT3Bwb3NpdGUgPSAob3Bwb3NpdGVQb3MtY3VycmVudFBvcyk7XFxuJyArICd2ZWMzIGRpclRvT3Bwb3NpdGVOID0gbm9ybWFsaXplKGRpclRvT3Bwb3NpdGUpO1xcbicgKyAnZmxvYXQgZGlzdCA9IGRpc3RhbmNlKG9wcG9zaXRlUG9zLCBjdXJyZW50UG9zKTtcXG4nICsgLy8gbmVhcj0wLjAgOyBmYXI9MS4wXG4gICAgICAgICAgICAnZmxvYXQgZGlzdE4gPSBtYXgoMC4wLGRpc3QpLzEwMDAwMC4wOycgKyAnZmxvYXQgbTEgPSAwLjA7JyArIC8vIDQwMDAwMC4wXG4gICAgICAgICAgICAnZmxvYXQgbTIgPSAwLjA7JyArIC8vIDQ4LjBcbiAgICAgICAgICAgICdpZihjdXJyZW50SXNQYXJlbnQgPT0gMS4wKSB7JyArICduZXRDaGlsZElucHV0U3VtQSArPSBvcHBvc2l0ZU5ldE91dHB1dEEqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtQiArPSBvcHBvc2l0ZU5ldE91dHB1dEIqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtQyArPSBvcHBvc2l0ZU5ldE91dHB1dEMqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtRCArPSBvcHBvc2l0ZU5ldE91dHB1dEQqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtRSArPSBvcHBvc2l0ZU5ldE91dHB1dEUqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtRiArPSBvcHBvc2l0ZU5ldE91dHB1dEYqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtRyArPSBvcHBvc2l0ZU5ldE91dHB1dEcqb3Bwb3NpdGVXZWlnaHQ7JyArICdhdHJhY3Rpb24gKz0gZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgZGlzdE4qYWJzKG9wcG9zaXRlV2VpZ2h0KSoobTEvMi4wKSk7XFxuJyArICdyZXB1bHNpb24gKz0gLWRpclRvT3Bwb3NpdGVOKm1heCgxLjAsICgxLjAtZGlzdE4pKmFicyhvcHBvc2l0ZVdlaWdodCkqKG0yLzIuMCkpO1xcbicgKyAnYWN1bUF0cmFjdGlvbiArPSAxLjA7XFxuJyArICd9IGVsc2UgaWYoY3VycmVudElzUGFyZW50ID09IDAuNSkgeycgKyAnbmV0UGFyZW50RXJyb3JXZWlnaHRBICs9IG9wcG9zaXRlTmV0RXJyb3JBKmN1cnJlbnRXZWlnaHQ7JyArICduZXRQYXJlbnRFcnJvcldlaWdodEIgKz0gb3Bwb3NpdGVOZXRFcnJvckIqY3VycmVudFdlaWdodDsnICsgJ25ldFBhcmVudEVycm9yV2VpZ2h0QyArPSBvcHBvc2l0ZU5ldEVycm9yQypjdXJyZW50V2VpZ2h0OycgKyAnbmV0UGFyZW50RXJyb3JXZWlnaHREICs9IG9wcG9zaXRlTmV0RXJyb3JEKmN1cnJlbnRXZWlnaHQ7JyArICduZXRQYXJlbnRFcnJvcldlaWdodEUgKz0gb3Bwb3NpdGVOZXRFcnJvckUqY3VycmVudFdlaWdodDsnICsgJ25ldFBhcmVudEVycm9yV2VpZ2h0RiArPSBvcHBvc2l0ZU5ldEVycm9yRipjdXJyZW50V2VpZ2h0OycgKyAnbmV0UGFyZW50RXJyb3JXZWlnaHRHICs9IG9wcG9zaXRlTmV0RXJyb3JHKmN1cnJlbnRXZWlnaHQ7JyArICdhdHJhY3Rpb24gKz0gZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgZGlzdE4qYWJzKGN1cnJlbnRXZWlnaHQpKm0xKTtcXG4nICsgJ3JlcHVsc2lvbiArPSAtZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgKDEuMC1kaXN0TikqYWJzKGN1cnJlbnRXZWlnaHQpKm0yKTtcXG4nICsgJ2FjdW1BdHJhY3Rpb24gKz0gMS4wO1xcbicgKyAnfScgKyAncmVwdWxzaW9uICs9IC1kaXJUb09wcG9zaXRlTiptYXgoMS4wLCAoMS4wLWRpc3ROKSphYnMoY3VycmVudFdlaWdodCkqKG0yLzguMCkpO1xcbicgKyAnYWN1bUF0cmFjdGlvbiArPSAxLjA7XFxuJyArIChcInJldHVybiBDYWxjdWxhdGlvblJlc3BvbnNlKGF0cmFjdGlvbiwgYWN1bUF0cmFjdGlvbiwgcmVwdWxzaW9uLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQSwgbmV0UGFyZW50RXJyb3JXZWlnaHRBLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQiwgbmV0UGFyZW50RXJyb3JXZWlnaHRCLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQywgbmV0UGFyZW50RXJyb3JXZWlnaHRDLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRCwgbmV0UGFyZW50RXJyb3JXZWlnaHRELFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRSwgbmV0UGFyZW50RXJyb3JXZWlnaHRFLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRiwgbmV0UGFyZW50RXJyb3JXZWlnaHRGLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRywgbmV0UGFyZW50RXJyb3JXZWlnaHRHKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHN0cnVjdCBpZEFkak1hdHJpeFJlc3BvbnNlIHtcXG4gICAgICAgICAgICB2ZWMzIGZvcmNlO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEZPdXRwdXRBO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEVycm9yV2VpZ2h0QTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRGT3V0cHV0QjtcXG4gICAgICAgICAgICBmbG9hdCBuZXRFcnJvcldlaWdodEI7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Rk91dHB1dEM7XFxuICAgICAgICAgICAgZmxvYXQgbmV0RXJyb3JXZWlnaHRDO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEZPdXRwdXREO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEVycm9yV2VpZ2h0RDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRGT3V0cHV0RTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRFcnJvcldlaWdodEU7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Rk91dHB1dEY7XFxuICAgICAgICAgICAgZmxvYXQgbmV0RXJyb3JXZWlnaHRGO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEZPdXRwdXRHO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEVycm9yV2VpZ2h0RztcXG4gICAgICAgIH07XFxuICAgICAgICBmbG9hdCB0YW5oKGZsb2F0IHZhbCkge1xcbiAgICAgICAgICAgIGZsb2F0IHRtcCA9IGV4cCh2YWwpO1xcbiAgICAgICAgICAgIGZsb2F0IHRhbkggPSAodG1wIC0gMS4wIC8gdG1wKSAvICh0bXAgKyAxLjAgLyB0bXApO1xcbiAgICAgICAgICAgIHJldHVybiB0YW5IO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgc2lnbShmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgICByZXR1cm4gKDEuMCAvICgxLjAgKyBleHAoLXZhbCkpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlkQWRqTWF0cml4UmVzcG9uc2UgaWRBZGpNYXRyaXhfRm9yY2VMYXlvdXQoZmxvYXQgbm9kZUlkLCB2ZWMzIGN1cnJlbnRQb3MsIHZlYzMgY3VycmVudERpciwgZmxvYXQgbnVtT2ZDb25uZWN0aW9ucykge1xcbiAgICAgICAgICAgIHZlYzMgYXRyYWN0aW9uID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgICAgICBmbG9hdCBhY3VtQXRyYWN0aW9uID0gMS4wO1xcbiAgICAgICAgICAgIHZlYzMgcmVwdWxzaW9uID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXG4gICAgICAgICAgICB2ZWMzIGZvcmNlID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXG5cXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQSA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0QSA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEEgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUIgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEIgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRCID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1DID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRDID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QyA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRCA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0RCA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEQgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUUgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEUgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRFID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1GID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRGID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RiA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRyA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0RyA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEcgPSAwLjA7XFxuICAgICAgICAgICAgXFxuXFxuICAgICAgICAgICAgaWYobm9kZUlkIDwgbm9kZXNDb3VudCkge1xcbiAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50QWN0aXZhdGlvbkZuID0gMC4wO1xcbiAgICAgICAgICAgICAgICB2ZWMyIHhHZW9tQ3VycmVudCA9IGdldF9nbG9iYWxfaWQobm9kZUlkLCB1QnVmZmVyV2lkdGgsIFwiICsgZ2VvbWV0cnlMZW5ndGgudG9GaXhlZCgxKSArIFwiKTtcXG4gICAgICAgICAgICAgICAgZm9yKGludCBuPTA7IG4gPCA0MDk2OyBuKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmKGZsb2F0KG4pID49IG5vZGVzQ291bnQpIHticmVhazt9XFxuICAgICAgICAgICAgICAgICAgICBpZihmbG9hdChuKSAhPSBub2RlSWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyIHhHZW9tT3Bwb3NpdGUgPSBnZXRfZ2xvYmFsX2lkKGZsb2F0KG4pLCB1QnVmZmVyV2lkdGgsIFwiICsgZ2VvbWV0cnlMZW5ndGgudG9GaXhlZCgxKSArIFwiKTtcXG5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyIHhBZGpNYXRDdXJyZW50ID0gZ2V0X2dsb2JhbF9pZCh2ZWMyKGZsb2F0KG4pLCBub2RlSWQpLCB3aWR0aEFkak1hdHJpeCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMiB4QWRqTWF0T3Bwb3NpdGUgPSBnZXRfZ2xvYmFsX2lkKHZlYzIobm9kZUlkLCBmbG9hdChuKSksIHdpZHRoQWRqTWF0cml4KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEFDdXJyZW50ID0gYWRqYWNlbmN5TWF0cml4W3hBZGpNYXRDdXJyZW50XTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEFPcHBvc2l0ZSA9IGFkamFjZW5jeU1hdHJpeFt4QWRqTWF0T3Bwb3NpdGVdO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0QkN1cnJlbnQgPSBhZGphY2VuY3lNYXRyaXhCW3hBZGpNYXRDdXJyZW50XTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEJPcHBvc2l0ZSA9IGFkamFjZW5jeU1hdHJpeEJbeEFkak1hdE9wcG9zaXRlXTtcXG5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBDYWxjdWxhdGlvblJlc3BvbnNlIGNhbGNSZXNwb25zZSA9IGNhbGN1bGF0ZShub2RlSWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhBZGpNYXRBQ3VycmVudCwgcGl4QWRqTWF0QU9wcG9zaXRlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4QWRqTWF0QkN1cnJlbnQsIHBpeEFkak1hdEJPcHBvc2l0ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhHZW9tQ3VycmVudCwgeEdlb21PcHBvc2l0ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MsIGN1cnJlbnREaXIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHJhY3Rpb24sIGFjdW1BdHJhY3Rpb24sIHJlcHVsc2lvbixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1BLCBuZXRQYXJlbnRFcnJvcldlaWdodEEsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQiwgbmV0UGFyZW50RXJyb3JXZWlnaHRCLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUMsIG5ldFBhcmVudEVycm9yV2VpZ2h0QyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1ELCBuZXRQYXJlbnRFcnJvcldlaWdodEQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRSwgbmV0UGFyZW50RXJyb3JXZWlnaHRFLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUYsIG5ldFBhcmVudEVycm9yV2VpZ2h0RixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1HLCBuZXRQYXJlbnRFcnJvcldlaWdodEcpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0cmFjdGlvbiA9IGNhbGNSZXNwb25zZS5hdHJhY3Rpb247XFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN1bUF0cmFjdGlvbiA9IGNhbGNSZXNwb25zZS5hY3VtQXRyYWN0aW9uO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcHVsc2lvbiA9IGNhbGNSZXNwb25zZS5yZXB1bHNpb247XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUEgPSBjYWxjUmVzcG9uc2UubmV0Q2hpbGRJbnB1dFN1bUE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRBID0gY2FsY1Jlc3BvbnNlLm5ldFBhcmVudEVycm9yV2VpZ2h0QTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQiA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtQjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEIgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JXZWlnaHRCO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1DID0gY2FsY1Jlc3BvbnNlLm5ldENoaWxkSW5wdXRTdW1DO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QyA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvcldlaWdodEM7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUQgPSBjYWxjUmVzcG9uc2UubmV0Q2hpbGRJbnB1dFN1bUQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHREID0gY2FsY1Jlc3BvbnNlLm5ldFBhcmVudEVycm9yV2VpZ2h0RDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRSA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtRTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEUgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JXZWlnaHRFO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1GID0gY2FsY1Jlc3BvbnNlLm5ldENoaWxkSW5wdXRTdW1GO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RiA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvcldlaWdodEY7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUcgPSBjYWxjUmVzcG9uc2UubmV0Q2hpbGRJbnB1dFN1bUc7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRHID0gY2FsY1Jlc3BvbnNlLm5ldFBhcmVudEVycm9yV2VpZ2h0RztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBmb3JjZSArPSAoYXRyYWN0aW9uL2FjdW1BdHJhY3Rpb24pO1xcbiAgICAgICAgICAgICAgICBmb3JjZSArPSAocmVwdWxzaW9uL2FjdW1BdHJhY3Rpb24pO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgXCIgKyBHcmFwaFV0aWxzLmVmZmVyZW50Tm9kZXNTdHIoZWZmZXJlbnRTdGFydCwgZWZmZXJlbnROb2Rlc0NvdW50KSArIFwiXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiBpZEFkak1hdHJpeFJlc3BvbnNlKHZlYzMoZm9yY2UpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QSwgbmV0UGFyZW50RXJyb3JXZWlnaHRBLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QiwgbmV0UGFyZW50RXJyb3JXZWlnaHRCLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QywgbmV0UGFyZW50RXJyb3JXZWlnaHRDLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RCwgbmV0UGFyZW50RXJyb3JXZWlnaHRELFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RSwgbmV0UGFyZW50RXJyb3JXZWlnaHRFLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RiwgbmV0UGFyZW50RXJyb3JXZWlnaHRGLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RywgbmV0UGFyZW50RXJyb3JXZWlnaHRHKTtcXG4gICAgICAgIH1cIik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlZmZlcmVudE5vZGVzU3RyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlZmZlcmVudE5vZGVzU3RyKGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkge1xuICAgICAgICAgICAgdmFyIHN0ciA9IFwiXFxuICAgICAgICAgICAgaWYobm9kZUlkIDwgYWZmZXJlbnROb2Rlc0NvdW50KSB7XFxuICAgICAgICAgICAgICAgIGZvcihmbG9hdCBuPTAuMDsgbiA8IDEwMjQuMDsgbis9MS4wKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZihuID49IGFmZmVyZW50Tm9kZXNDb3VudCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZUlkID09IG4pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QSA9IGFmZmVyZW50Tm9kZXNBW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEIgPSBhZmZlcmVudE5vZGVzQltpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRDID0gYWZmZXJlbnROb2Rlc0NbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RCA9IGFmZmVyZW50Tm9kZXNEW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEUgPSBhZmZlcmVudE5vZGVzRVtpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRGID0gYWZmZXJlbnROb2Rlc0ZbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RyA9IGFmZmVyZW50Tm9kZXNHW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0QSA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1BKTsgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICBmb3V0cHV0QiA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1CKTtcXG4gICAgICAgICAgICAgICAgZm91dHB1dEMgPSBtYXgoMC4wLCBuZXRDaGlsZElucHV0U3VtQyk7XFxuICAgICAgICAgICAgICAgIGZvdXRwdXREID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUQpO1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0RSA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1FKTtcXG4gICAgICAgICAgICAgICAgZm91dHB1dEYgPSBtYXgoMC4wLCBuZXRDaGlsZElucHV0U3VtRik7XFxuICAgICAgICAgICAgICAgIGZvdXRwdXRHID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUcpO1xcbiAgICAgICAgICAgIH1cIjtcblxuICAgICAgICAgICAgc3RyICs9IFwiXFxuICAgICAgICBpZihub2RlSWQgPT0gXCIgKyBlZmZlcmVudFN0YXJ0LnRvRml4ZWQoMSkgKyAoXCIpIHtcXG4gICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEEgPSAoZWZmZXJlbnROb2Rlc0FbMF0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1BLWVmZmVyZW50Tm9kZXNBWzBdIDogMC4wO1xcbiAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEIgPSAoZWZmZXJlbnROb2Rlc0JbMF0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1CLWVmZmVyZW50Tm9kZXNCWzBdIDogMC4wO1xcbiAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEMgPSAoZWZmZXJlbnROb2Rlc0NbMF0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1DLWVmZmVyZW50Tm9kZXNDWzBdIDogMC4wO1xcbiAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEQgPSAoZWZmZXJlbnROb2Rlc0RbMF0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1ELWVmZmVyZW50Tm9kZXNEWzBdIDogMC4wO1xcbiAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEUgPSAoZWZmZXJlbnROb2Rlc0VbMF0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1FLWVmZmVyZW50Tm9kZXNFWzBdIDogMC4wO1xcbiAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEYgPSAoZWZmZXJlbnROb2Rlc0ZbMF0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1GLWVmZmVyZW50Tm9kZXNGWzBdIDogMC4wO1xcbiAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEcgPSAoZWZmZXJlbnROb2Rlc0dbMF0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1HLWVmZmVyZW50Tm9kZXNHWzBdIDogMC4wO1xcbiAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgIH1cIik7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gZWZmZXJlbnRTdGFydCArIDE7IG4gPCBlZmZlcmVudFN0YXJ0ICsgZWZmZXJlbnROb2Rlc0NvdW50OyBuKyspIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCJcXG4gICAgICAgICAgICBlbHNlIGlmKG5vZGVJZCA9PSBcIiArIG4udG9GaXhlZCgxKSArIFwiKSB7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QSA9IChlZmZlcmVudE5vZGVzQVtcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtQS1lZmZlcmVudE5vZGVzQVtcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgKFwiXSA6IDAuMDtcXG4gICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEIgPSAoZWZmZXJlbnROb2Rlc0JbXCIpICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyBcIl0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1CLWVmZmVyZW50Tm9kZXNCW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAoXCJdIDogMC4wO1xcbiAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QyA9IChlZmZlcmVudE5vZGVzQ1tcIikgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUMtZWZmZXJlbnROb2Rlc0NbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIChcIl0gOiAwLjA7XFxuICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHREID0gKGVmZmVyZW50Tm9kZXNEW1wiKSArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtRC1lZmZlcmVudE5vZGVzRFtcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgKFwiXSA6IDAuMDtcXG4gICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEUgPSAoZWZmZXJlbnROb2Rlc0VbXCIpICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyBcIl0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1FLWVmZmVyZW50Tm9kZXNFW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAoXCJdIDogMC4wO1xcbiAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RiA9IChlZmZlcmVudE5vZGVzRltcIikgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUYtZWZmZXJlbnROb2Rlc0ZbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIChcIl0gOiAwLjA7XFxuICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRHID0gKGVmZmVyZW50Tm9kZXNHW1wiKSArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtRy1lZmZlcmVudE5vZGVzR1tcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgKFwiXSA6IDAuMDtcXG4gICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgIH1cIik7XG4gICAgICAgICAgICB9c3RyICs9IFwiXFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBpZihmb3V0cHV0QSA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRBID0gMC4wO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZihmb3V0cHV0QiA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRCID0gMC4wO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZihmb3V0cHV0QyA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRDID0gMC4wO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZihmb3V0cHV0RCA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHREID0gMC4wO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZihmb3V0cHV0RSA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRFID0gMC4wO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZihmb3V0cHV0RiA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRGID0gMC4wO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZihmb3V0cHV0RyA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRHID0gMC4wO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cIjtcblxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBHcmFwaFV0aWxzO1xufSgpO1xuXG5nbG9iYWwuR3JhcGhVdGlscyA9IEdyYXBoVXRpbHM7XG5tb2R1bGUuZXhwb3J0cy5HcmFwaFV0aWxzID0gR3JhcGhVdGlsczsiXX0=
