(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var KERNEL_DIR = exports.KERNEL_DIR = function () {
    function KERNEL_DIR() {
        _classCallCheck(this, KERNEL_DIR);
    }

    _createClass(KERNEL_DIR, null, [{
        key: "getSrc",
        value: function getSrc(customCode, geometryLength, afferentNodesCount, efferentStart, efferentNodesCount) {
            var outputArr = ["dir", "posXYZW", "dataB", "dataF", "dataG", "dataH"];
            var returnStr = 'return [vec4(currentDir, 1.0), vec4(currentPos.x, currentPos.y, currentPos.z, 1.0), currentDataB, currentDataF, currentDataG, currentDataH];';

            return ["x", outputArr,
            // head
            "float tanh(float val) {\n                float tmp = exp(val);\n                float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n                return tanH;\n            }\n            float sigm(float val) {\n                return (1.0 / (1.0 + exp(-val)));\n            }",

            // source
            "float nodeId = data[x].x;\n            vec2 xGeometry = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n            vec3 currentPos = posXYZW[xGeometry].xyz;\n            vec3 currentDir = dir[xGeometry].xyz;\n\n\n            vec4 currentDataB = dataB[xGeometry];\n            vec4 currentDataF = dataF[xGeometry];\n            vec4 currentDataG = dataG[xGeometry];\n            vec4 currentDataH = dataH[xGeometry];\n\n            currentDir = vec3(0.0, 0.0, 0.0);\n\n            \n            vec3 atraction = vec3(0.0, 0.0, 0.0);\n            float acumAtraction = 1.0;\n            vec3 repulsion = vec3(0.0, 0.0, 0.0);\n\n            vec3 force = vec3(0.0, 0.0, 0.0);\n\n\n            float netChildInputSumA = 0.0;\n            float foutputA = 0.0;\n            float netParentErrorWeightA = 0.0;\n            \n            float netChildInputSumB = 0.0;\n            float foutputB = 0.0;\n            float netParentErrorWeightB = 0.0;\n            \n            float netChildInputSumC = 0.0;\n            float foutputC = 0.0;\n            float netParentErrorWeightC = 0.0;\n            \n            float netChildInputSumD = 0.0;\n            float foutputD = 0.0;\n            float netParentErrorWeightD = 0.0;\n            \n            float netChildInputSumE = 0.0;\n            float foutputE = 0.0;\n            float netParentErrorWeightE = 0.0;\n            \n            float netChildInputSumF = 0.0;\n            float foutputF = 0.0;\n            float netParentErrorWeightF = 0.0;\n            \n            float netChildInputSumG = 0.0;\n            float foutputG = 0.0;\n            float netParentErrorWeightG = 0.0;\n            \n\n            if(nodeId < nodesCount && enableTrain == 0.0) {\n                float currentActivationFn = 0.0;\n                vec2 xGeomCurrent = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n                for(int n=0; n < 4096; n++) {\n                    if(float(n) >= nodesCount) {break;}\n                    if(float(n) != nodeId) {\n                        vec2 xGeomOpposite = get_global_id(float(n), uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n                        vec2 xAdjMatCurrent = get_global_id(vec2(float(n), nodeId), widthAdjMatrix);\n                        vec2 xAdjMatOpposite = get_global_id(vec2(nodeId, float(n)), widthAdjMatrix);\n\n                        vec4 pixAdjMatACurrent = adjacencyMatrix[xAdjMatCurrent];\n                        vec4 pixAdjMatAOpposite = adjacencyMatrix[xAdjMatOpposite];\n\n                        vec4 pixAdjMatBCurrent = adjacencyMatrixB[xAdjMatCurrent];\n                        vec4 pixAdjMatBOpposite = adjacencyMatrixB[xAdjMatOpposite];\n                        \n                        vec4 pixAdjMatCCurrent = adjacencyMatrixC[xAdjMatCurrent];\n                        vec4 pixAdjMatCOpposite = adjacencyMatrixC[xAdjMatOpposite];\n                        \n                        vec4 pixAdjMatDCurrent = adjacencyMatrixD[xAdjMatCurrent];\n                        vec4 pixAdjMatDOpposite = adjacencyMatrixD[xAdjMatOpposite];\n\n\n                                                                    \n                        " + "\n                        float currentLayerNum = pixAdjMatACurrent.x;\n                        float currentWeight = pixAdjMatACurrent.z;\n                        float currentIsParent = pixAdjMatACurrent.w;            \n                        " + "\n                        float oppositeLayerNum = pixAdjMatAOpposite.x;\n                        float oppositeWeight = pixAdjMatAOpposite.z;\n                        float oppositeIsParent = pixAdjMatAOpposite.w;\n            \n            \n                        " + "\n                        float currentCostA = pixAdjMatBCurrent.y;            \n                        " + "            \n            \n                        " + "\n                        float currentCostB = pixAdjMatCCurrent.x;\n                        float currentCostC = pixAdjMatCCurrent.y;\n                        float currentCostD = pixAdjMatCCurrent.z;\n                        float currentCostE = pixAdjMatCCurrent.w;            \n                        " + "                        \n                        \n                        " + "\n                        float currentCostF = pixAdjMatDCurrent.x;\n                        float currentCostG = pixAdjMatDCurrent.y;           \n                        " + "\n                        \n                        \n            \n                        " + "            \n                        " + "                        \n                        float oppositeNetOutputA = dataB[xGeomOpposite].z;                        \n                        float oppositeNetOutputB = dataF[xGeomOpposite].x;                    \n                        float oppositeNetOutputC = dataF[xGeomOpposite].z;                    \n                        float oppositeNetOutputD = dataG[xGeomOpposite].x;                    \n                        float oppositeNetOutputE = dataG[xGeomOpposite].z;                    \n                        float oppositeNetOutputF = dataH[xGeomOpposite].x;                    \n                        float oppositeNetOutputG = dataH[xGeomOpposite].z;\n            \n            \n                        " + "\n                        " + "\n                        " + "            \n                        " + "\n                        vec3 oppositePos = posXYZW[xGeomOpposite].xyz;\n                        vec3 oppositeDir = dir[xGeomOpposite].xyz;\n            \n                        " + "\n                        vec3 dirToOpposite = (oppositePos-currentPos);\n                        vec3 dirToOppositeN = normalize(dirToOpposite);\n            \n                        float dist = distance(oppositePos, currentPos); " + "\n                        float distN = max(0.0,dist)/100000.0;\n            \n                        float mm = 10000000.0;\n                        float m1 = 400000.0/mm;\n                        float m2 = 48.0/mm;\n                        if(currentIsParent == 1.0) {\n                            netChildInputSumA += oppositeNetOutputA*oppositeWeight;\n                            netChildInputSumB += oppositeNetOutputB*oppositeWeight;\n                            netChildInputSumC += oppositeNetOutputC*oppositeWeight;\n                            netChildInputSumD += oppositeNetOutputD*oppositeWeight;\n                            netChildInputSumE += oppositeNetOutputE*oppositeWeight;\n                            netChildInputSumF += oppositeNetOutputF*oppositeWeight;\n                            netChildInputSumG += oppositeNetOutputG*oppositeWeight;\n                            \n                            atraction += dirToOppositeN*max(1.0, distN*abs(oppositeWeight)*(m1/2.0));\n                            repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(oppositeWeight)*(m2/2.0));\n                            acumAtraction += 1.0;\n                        } else if(currentIsParent == 0.5) {\n                            netParentErrorWeightA += currentCostA;\n                            netParentErrorWeightB += currentCostB;\n                            netParentErrorWeightC += currentCostC;\n                            netParentErrorWeightD += currentCostD;\n                            netParentErrorWeightE += currentCostE;\n                            netParentErrorWeightF += currentCostF;\n                            netParentErrorWeightG += currentCostG;\n                            \n                            atraction += dirToOppositeN*max(1.0, distN*abs(currentWeight)*m1);\n                            repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*m2);\n                            acumAtraction += 1.0;\n                        }\n            \n                        repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*(m2/8.0));\n                        acumAtraction += 1.0;\n                    }\n                }\n                \n                float vndm = (viewNeuronDynamics == 1.0) ? netChildInputSumA : 1.0;\n                force += (atraction/acumAtraction)*abs(vndm);\n                force += (repulsion/acumAtraction)*abs(vndm);\n                currentDir += force;\n                \n                \n                float currentBiasNode = dataB[xGeomCurrent].x;\n                \n                " + KERNEL_DIR.efferentNodesStr(afferentNodesCount, efferentStart, efferentNodesCount) + "\n                \n                currentDataB = vec4(currentDataB.x, netParentErrorWeightA, foutputA, netParentErrorWeightB);\n                currentDataF = vec4(foutputB, netParentErrorWeightC, foutputC, netParentErrorWeightD);\n                currentDataG = vec4(foutputD, netParentErrorWeightE, foutputE, netParentErrorWeightF);\n                currentDataH = vec4(foutputF, netParentErrorWeightG, foutputG, 0.0);\n            }\n\n            " + (customCode !== undefined ? customCode : '') + "\n\n            if(enableDrag == 1.0) {\n                if(nodeId == idToDrag) {\n                    currentPos = vec3(MouseDragTranslationX, MouseDragTranslationY, MouseDragTranslationZ);\n                }\n            }\n\n            currentPos += currentDir;\n            if(only2d == 1.0) {\n                currentPos.y = 0.0;\n            }\n\n            " + returnStr];
        }
    }, {
        key: "efferentNodesStr",
        value: function efferentNodesStr(afferentNodesCount, efferentStart, efferentNodesCount) {
            var arrUniformsCount = Math.ceil(afferentNodesCount / 64);
            /////////////////////////////////////////////////
            // OUTPUT
            /////////////////////////////////////////////////
            var str = "\n            if(freezeOutput == 0.0) {\n                if(nodeId < afferentNodesCount) {                \n                    vec2 idA = get_global_id(nodeId, afferentNodesTWidth, 1.0);\n                    vec4 tA = afferentNodesT[idA];\n                    foutputA = tA.r;\n                    \n                    vec2 idB = get_global_id(nodeId+(afferentNodesCount), afferentNodesTWidth, 1.0);\n                    vec4 tB = afferentNodesT[idB];\n                    foutputB = tB.r;\n                    \n                    vec2 idC = get_global_id(nodeId+(afferentNodesCount*2.0), afferentNodesTWidth, 1.0);\n                    vec4 tC = afferentNodesT[idC];\n                    foutputC = tC.r;\n                    \n                    vec2 idD = get_global_id(nodeId+(afferentNodesCount*3.0), afferentNodesTWidth, 1.0);\n                    vec4 tD = afferentNodesT[idD];\n                    foutputD = tD.r;\n                    \n                    vec2 idE = get_global_id(nodeId+(afferentNodesCount*4.0), afferentNodesTWidth, 1.0);\n                    vec4 tE = afferentNodesT[idE];\n                    foutputE = tE.r;\n                    \n                    vec2 idF = get_global_id(nodeId+(afferentNodesCount*5.0), afferentNodesTWidth, 1.0);\n                    vec4 tF = afferentNodesT[idF];\n                    foutputF = tF.r;\n                    \n                    vec2 idG = get_global_id(nodeId+(afferentNodesCount*6.0), afferentNodesTWidth, 1.0);\n                    vec4 tG = afferentNodesT[idG];\n                    foutputG = tG.r;\n                } else {\n                    if(currentBiasNode == 0.0) {\n                        if(nodeId >= " + efferentStart.toFixed(1) + (") {\n                            foutputA = netChildInputSumA;\n                            foutputB = netChildInputSumB;\n                            foutputC = netChildInputSumC;\n                            foutputD = netChildInputSumD;\n                            foutputE = netChildInputSumE;\n                            foutputF = netChildInputSumF;\n                            foutputG = netChildInputSumG;\n                        } else {                                  \n                            foutputA = (netChildInputSumA <= 0.0) ? 0.01*netChildInputSumA : netChildInputSumA; " + "\n                            foutputB = (netChildInputSumB <= 0.0) ? 0.01*netChildInputSumB : netChildInputSumB;\n                            foutputC = (netChildInputSumC <= 0.0) ? 0.01*netChildInputSumC : netChildInputSumC;\n                            foutputD = (netChildInputSumD <= 0.0) ? 0.01*netChildInputSumD : netChildInputSumD;\n                            foutputE = (netChildInputSumE <= 0.0) ? 0.01*netChildInputSumE : netChildInputSumE;\n                            foutputF = (netChildInputSumF <= 0.0) ? 0.01*netChildInputSumF : netChildInputSumF;\n                            foutputG = (netChildInputSumG <= 0.0) ? 0.01*netChildInputSumG : netChildInputSumG;\n                        }\n                    } else {\n                        foutputA = 1.0;\n                        foutputB = 1.0;\n                        foutputC = 1.0;\n                        foutputD = 1.0;\n                        foutputE = 1.0;\n                        foutputF = 1.0;\n                        foutputG = 1.0;\n                    }\n                }\n            } else {\n                foutputA = currentDataB.z;\n                foutputB = currentDataF.x;\n                foutputC = currentDataF.z;\n                foutputD = currentDataG.x;\n                foutputE = currentDataG.z;\n                foutputF = currentDataH.x;\n                foutputG = currentDataH.z;\n            }");

            /////////////////////////////////////////////////
            // ERROR
            /////////////////////////////////////////////////
            for (var n = efferentStart; n < efferentStart + efferentNodesCount; n++) {
                var cond = n === efferentStart ? "if" : "else if";
                str += "\n            " + cond + "(nodeId == " + n.toFixed(1) + (") {\n                if(freezeOutput == 0.0) {\n                    foutputA = netChildInputSumA; " + " \n                    foutputB = netChildInputSumB;\n                    foutputC = netChildInputSumC;\n                    foutputD = netChildInputSumD;\n                    foutputE = netChildInputSumE;\n                    foutputF = netChildInputSumF;\n                    foutputG = netChildInputSumG;\n                } else {\n                    foutputA = currentDataB.z;\n                    foutputB = currentDataF.x;\n                    foutputC = currentDataF.z;\n                    foutputD = currentDataG.x;\n                    foutputE = currentDataG.z;\n                    foutputF = currentDataH.x;\n                    foutputG = currentDataH.z;\n                }               \n                netParentErrorWeightA = efferentNodesA[") + Math.round(n - efferentStart) + "];\n                netParentErrorWeightB = efferentNodesB[" + Math.round(n - efferentStart) + "];\n                netParentErrorWeightC = efferentNodesC[" + Math.round(n - efferentStart) + "];\n                netParentErrorWeightD = efferentNodesD[" + Math.round(n - efferentStart) + "];\n                netParentErrorWeightE = efferentNodesE[" + Math.round(n - efferentStart) + "];\n                netParentErrorWeightF = efferentNodesF[" + Math.round(n - efferentStart) + "];\n                netParentErrorWeightG = efferentNodesG[" + Math.round(n - efferentStart) + "];\n            }";
            }
            return str;
        }
    }]);

    return KERNEL_DIR;
}();

global.KERNEL_DIR = KERNEL_DIR;
module.exports.KERNEL_DIR = KERNEL_DIR;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZ2JyYWluL0tFUk5FTF9ESVIuY2xhc3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEtFUk5FTF9ESVIgPSBleHBvcnRzLktFUk5FTF9ESVIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gS0VSTkVMX0RJUigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtFUk5FTF9ESVIpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhLRVJORUxfRElSLCBudWxsLCBbe1xuICAgICAgICBrZXk6IFwiZ2V0U3JjXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTcmMoY3VzdG9tQ29kZSwgZ2VvbWV0cnlMZW5ndGgsIGFmZmVyZW50Tm9kZXNDb3VudCwgZWZmZXJlbnRTdGFydCwgZWZmZXJlbnROb2Rlc0NvdW50KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0QXJyID0gW1wiZGlyXCIsIFwicG9zWFlaV1wiLCBcImRhdGFCXCIsIFwiZGF0YUZcIiwgXCJkYXRhR1wiLCBcImRhdGFIXCJdO1xuICAgICAgICAgICAgdmFyIHJldHVyblN0ciA9ICdyZXR1cm4gW3ZlYzQoY3VycmVudERpciwgMS4wKSwgdmVjNChjdXJyZW50UG9zLngsIGN1cnJlbnRQb3MueSwgY3VycmVudFBvcy56LCAxLjApLCBjdXJyZW50RGF0YUIsIGN1cnJlbnREYXRhRiwgY3VycmVudERhdGFHLCBjdXJyZW50RGF0YUhdOyc7XG5cbiAgICAgICAgICAgIHJldHVybiBbXCJ4XCIsIG91dHB1dEFycixcbiAgICAgICAgICAgIC8vIGhlYWRcbiAgICAgICAgICAgIFwiZmxvYXQgdGFuaChmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgdG1wID0gZXhwKHZhbCk7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHRhbkggPSAodG1wIC0gMS4wIC8gdG1wKSAvICh0bXAgKyAxLjAgLyB0bXApO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFuSDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZmxvYXQgc2lnbShmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICgxLjAgLyAoMS4wICsgZXhwKC12YWwpKSk7XFxuICAgICAgICAgICAgfVwiLFxuXG4gICAgICAgICAgICAvLyBzb3VyY2VcbiAgICAgICAgICAgIFwiZmxvYXQgbm9kZUlkID0gZGF0YVt4XS54O1xcbiAgICAgICAgICAgIHZlYzIgeEdlb21ldHJ5ID0gZ2V0X2dsb2JhbF9pZChub2RlSWQsIHVCdWZmZXJXaWR0aCwgXCIgKyBnZW9tZXRyeUxlbmd0aC50b0ZpeGVkKDEpICsgXCIpO1xcblxcblxcbiAgICAgICAgICAgIHZlYzMgY3VycmVudFBvcyA9IHBvc1hZWldbeEdlb21ldHJ5XS54eXo7XFxuICAgICAgICAgICAgdmVjMyBjdXJyZW50RGlyID0gZGlyW3hHZW9tZXRyeV0ueHl6O1xcblxcblxcbiAgICAgICAgICAgIHZlYzQgY3VycmVudERhdGFCID0gZGF0YUJbeEdlb21ldHJ5XTtcXG4gICAgICAgICAgICB2ZWM0IGN1cnJlbnREYXRhRiA9IGRhdGFGW3hHZW9tZXRyeV07XFxuICAgICAgICAgICAgdmVjNCBjdXJyZW50RGF0YUcgPSBkYXRhR1t4R2VvbWV0cnldO1xcbiAgICAgICAgICAgIHZlYzQgY3VycmVudERhdGFIID0gZGF0YUhbeEdlb21ldHJ5XTtcXG5cXG4gICAgICAgICAgICBjdXJyZW50RGlyID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICB2ZWMzIGF0cmFjdGlvbiA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgICAgICAgZmxvYXQgYWN1bUF0cmFjdGlvbiA9IDEuMDtcXG4gICAgICAgICAgICB2ZWMzIHJlcHVsc2lvbiA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFxuICAgICAgICAgICAgdmVjMyBmb3JjZSA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFxuXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUEgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEEgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRBID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRCID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQyA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0QyA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEMgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUQgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEQgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHREID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1FID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRFID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRiA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0RiA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEYgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUcgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEcgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRHID0gMC4wO1xcbiAgICAgICAgICAgIFxcblxcbiAgICAgICAgICAgIGlmKG5vZGVJZCA8IG5vZGVzQ291bnQgJiYgZW5hYmxlVHJhaW4gPT0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGN1cnJlbnRBY3RpdmF0aW9uRm4gPSAwLjA7XFxuICAgICAgICAgICAgICAgIHZlYzIgeEdlb21DdXJyZW50ID0gZ2V0X2dsb2JhbF9pZChub2RlSWQsIHVCdWZmZXJXaWR0aCwgXCIgKyBnZW9tZXRyeUxlbmd0aC50b0ZpeGVkKDEpICsgXCIpO1xcbiAgICAgICAgICAgICAgICBmb3IoaW50IG49MDsgbiA8IDQwOTY7IG4rKykge1xcbiAgICAgICAgICAgICAgICAgICAgaWYoZmxvYXQobikgPj0gbm9kZXNDb3VudCkge2JyZWFrO31cXG4gICAgICAgICAgICAgICAgICAgIGlmKGZsb2F0KG4pICE9IG5vZGVJZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIgeEdlb21PcHBvc2l0ZSA9IGdldF9nbG9iYWxfaWQoZmxvYXQobiksIHVCdWZmZXJXaWR0aCwgXCIgKyBnZW9tZXRyeUxlbmd0aC50b0ZpeGVkKDEpICsgXCIpO1xcblxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIgeEFkak1hdEN1cnJlbnQgPSBnZXRfZ2xvYmFsX2lkKHZlYzIoZmxvYXQobiksIG5vZGVJZCksIHdpZHRoQWRqTWF0cml4KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyIHhBZGpNYXRPcHBvc2l0ZSA9IGdldF9nbG9iYWxfaWQodmVjMihub2RlSWQsIGZsb2F0KG4pKSwgd2lkdGhBZGpNYXRyaXgpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0QUN1cnJlbnQgPSBhZGphY2VuY3lNYXRyaXhbeEFkak1hdEN1cnJlbnRdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0QU9wcG9zaXRlID0gYWRqYWNlbmN5TWF0cml4W3hBZGpNYXRPcHBvc2l0ZV07XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRCQ3VycmVudCA9IGFkamFjZW5jeU1hdHJpeEJbeEFkak1hdEN1cnJlbnRdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0Qk9wcG9zaXRlID0gYWRqYWNlbmN5TWF0cml4Qlt4QWRqTWF0T3Bwb3NpdGVdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0Q0N1cnJlbnQgPSBhZGphY2VuY3lNYXRyaXhDW3hBZGpNYXRDdXJyZW50XTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdENPcHBvc2l0ZSA9IGFkamFjZW5jeU1hdHJpeENbeEFkak1hdE9wcG9zaXRlXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdERDdXJyZW50ID0gYWRqYWNlbmN5TWF0cml4RFt4QWRqTWF0Q3VycmVudF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRET3Bwb3NpdGUgPSBhZGphY2VuY3lNYXRyaXhEW3hBZGpNYXRPcHBvc2l0ZV07XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudExheWVyTnVtID0gcGl4QWRqTWF0QUN1cnJlbnQueDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50V2VpZ2h0ID0gcGl4QWRqTWF0QUN1cnJlbnQuejtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50SXNQYXJlbnQgPSBwaXhBZGpNYXRBQ3VycmVudC53OyAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUxheWVyTnVtID0gcGl4QWRqTWF0QU9wcG9zaXRlLng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVXZWlnaHQgPSBwaXhBZGpNYXRBT3Bwb3NpdGUuejtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUlzUGFyZW50ID0gcGl4QWRqTWF0QU9wcG9zaXRlLnc7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGN1cnJlbnRDb3N0QSA9IHBpeEFkak1hdEJDdXJyZW50Lnk7ICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50Q29zdEIgPSBwaXhBZGpNYXRDQ3VycmVudC54O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGN1cnJlbnRDb3N0QyA9IHBpeEFkak1hdENDdXJyZW50Lnk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudENvc3REID0gcGl4QWRqTWF0Q0N1cnJlbnQuejtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50Q29zdEUgPSBwaXhBZGpNYXRDQ3VycmVudC53OyAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCIgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudENvc3RGID0gcGl4QWRqTWF0REN1cnJlbnQueDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50Q29zdEcgPSBwaXhBZGpNYXREQ3VycmVudC55OyAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCIgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRBID0gZGF0YUJbeEdlb21PcHBvc2l0ZV0uejsgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEIgPSBkYXRhRlt4R2VvbU9wcG9zaXRlXS54OyAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRDID0gZGF0YUZbeEdlb21PcHBvc2l0ZV0uejsgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0RCA9IGRhdGFHW3hHZW9tT3Bwb3NpdGVdLng7ICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEUgPSBkYXRhR1t4R2VvbU9wcG9zaXRlXS56OyAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRGID0gZGF0YUhbeEdlb21PcHBvc2l0ZV0ueDsgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0RyA9IGRhdGFIW3hHZW9tT3Bwb3NpdGVdLno7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgb3Bwb3NpdGVQb3MgPSBwb3NYWVpXW3hHZW9tT3Bwb3NpdGVdLnh5ejtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMzIG9wcG9zaXRlRGlyID0gZGlyW3hHZW9tT3Bwb3NpdGVdLnh5ejtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyBkaXJUb09wcG9zaXRlID0gKG9wcG9zaXRlUG9zLWN1cnJlbnRQb3MpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgZGlyVG9PcHBvc2l0ZU4gPSBub3JtYWxpemUoZGlyVG9PcHBvc2l0ZSk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZGlzdCA9IGRpc3RhbmNlKG9wcG9zaXRlUG9zLCBjdXJyZW50UG9zKTsgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGRpc3ROID0gbWF4KDAuMCxkaXN0KS8xMDAwMDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBtbSA9IDEwMDAwMDAwLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbTEgPSA0MDAwMDAuMC9tbTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBtMiA9IDQ4LjAvbW07XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudElzUGFyZW50ID09IDEuMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQSArPSBvcHBvc2l0ZU5ldE91dHB1dEEqb3Bwb3NpdGVXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1CICs9IG9wcG9zaXRlTmV0T3V0cHV0QipvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUMgKz0gb3Bwb3NpdGVOZXRPdXRwdXRDKm9wcG9zaXRlV2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRCArPSBvcHBvc2l0ZU5ldE91dHB1dEQqb3Bwb3NpdGVXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1FICs9IG9wcG9zaXRlTmV0T3V0cHV0RSpvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUYgKz0gb3Bwb3NpdGVOZXRPdXRwdXRGKm9wcG9zaXRlV2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRyArPSBvcHBvc2l0ZU5ldE91dHB1dEcqb3Bwb3NpdGVXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHJhY3Rpb24gKz0gZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgZGlzdE4qYWJzKG9wcG9zaXRlV2VpZ2h0KSoobTEvMi4wKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcHVsc2lvbiArPSAtZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgKDEuMC1kaXN0TikqYWJzKG9wcG9zaXRlV2VpZ2h0KSoobTIvMi4wKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdW1BdHJhY3Rpb24gKz0gMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihjdXJyZW50SXNQYXJlbnQgPT0gMC41KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QSArPSBjdXJyZW50Q29zdEE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiArPSBjdXJyZW50Q29zdEI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QyArPSBjdXJyZW50Q29zdEM7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RCArPSBjdXJyZW50Q29zdEQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSArPSBjdXJyZW50Q29zdEU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RiArPSBjdXJyZW50Q29zdEY7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RyArPSBjdXJyZW50Q29zdEc7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHJhY3Rpb24gKz0gZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgZGlzdE4qYWJzKGN1cnJlbnRXZWlnaHQpKm0xKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwdWxzaW9uICs9IC1kaXJUb09wcG9zaXRlTiptYXgoMS4wLCAoMS4wLWRpc3ROKSphYnMoY3VycmVudFdlaWdodCkqbTIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3VtQXRyYWN0aW9uICs9IDEuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwdWxzaW9uICs9IC1kaXJUb09wcG9zaXRlTiptYXgoMS4wLCAoMS4wLWRpc3ROKSphYnMoY3VycmVudFdlaWdodCkqKG0yLzguMCkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdW1BdHJhY3Rpb24gKz0gMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBmbG9hdCB2bmRtID0gKHZpZXdOZXVyb25EeW5hbWljcyA9PSAxLjApID8gbmV0Q2hpbGRJbnB1dFN1bUEgOiAxLjA7XFxuICAgICAgICAgICAgICAgIGZvcmNlICs9IChhdHJhY3Rpb24vYWN1bUF0cmFjdGlvbikqYWJzKHZuZG0pO1xcbiAgICAgICAgICAgICAgICBmb3JjZSArPSAocmVwdWxzaW9uL2FjdW1BdHJhY3Rpb24pKmFicyh2bmRtKTtcXG4gICAgICAgICAgICAgICAgY3VycmVudERpciArPSBmb3JjZTtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50Qmlhc05vZGUgPSBkYXRhQlt4R2VvbUN1cnJlbnRdLng7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBcIiArIEtFUk5FTF9ESVIuZWZmZXJlbnROb2Rlc1N0cihhZmZlcmVudE5vZGVzQ291bnQsIGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkgKyBcIlxcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGFCID0gdmVjNChjdXJyZW50RGF0YUIueCwgbmV0UGFyZW50RXJyb3JXZWlnaHRBLCBmb3V0cHV0QSwgbmV0UGFyZW50RXJyb3JXZWlnaHRCKTtcXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGFGID0gdmVjNChmb3V0cHV0QiwgbmV0UGFyZW50RXJyb3JXZWlnaHRDLCBmb3V0cHV0QywgbmV0UGFyZW50RXJyb3JXZWlnaHREKTtcXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGFHID0gdmVjNChmb3V0cHV0RCwgbmV0UGFyZW50RXJyb3JXZWlnaHRFLCBmb3V0cHV0RSwgbmV0UGFyZW50RXJyb3JXZWlnaHRGKTtcXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGFIID0gdmVjNChmb3V0cHV0RiwgbmV0UGFyZW50RXJyb3JXZWlnaHRHLCBmb3V0cHV0RywgMC4wKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgXCIgKyAoY3VzdG9tQ29kZSAhPT0gdW5kZWZpbmVkID8gY3VzdG9tQ29kZSA6ICcnKSArIFwiXFxuXFxuICAgICAgICAgICAgaWYoZW5hYmxlRHJhZyA9PSAxLjApIHtcXG4gICAgICAgICAgICAgICAgaWYobm9kZUlkID09IGlkVG9EcmFnKSB7XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gdmVjMyhNb3VzZURyYWdUcmFuc2xhdGlvblgsIE1vdXNlRHJhZ1RyYW5zbGF0aW9uWSwgTW91c2VEcmFnVHJhbnNsYXRpb25aKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IGN1cnJlbnREaXI7XFxuICAgICAgICAgICAgaWYob25seTJkID09IDEuMCkge1xcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zLnkgPSAwLjA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIFwiICsgcmV0dXJuU3RyXTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVmZmVyZW50Tm9kZXNTdHJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVmZmVyZW50Tm9kZXNTdHIoYWZmZXJlbnROb2Rlc0NvdW50LCBlZmZlcmVudFN0YXJ0LCBlZmZlcmVudE5vZGVzQ291bnQpIHtcbiAgICAgICAgICAgIHZhciBhcnJVbmlmb3Jtc0NvdW50ID0gTWF0aC5jZWlsKGFmZmVyZW50Tm9kZXNDb3VudCAvIDY0KTtcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIE9VVFBVVFxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgdmFyIHN0ciA9IFwiXFxuICAgICAgICAgICAgaWYoZnJlZXplT3V0cHV0ID09IDAuMCkge1xcbiAgICAgICAgICAgICAgICBpZihub2RlSWQgPCBhZmZlcmVudE5vZGVzQ291bnQpIHsgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICB2ZWMyIGlkQSA9IGdldF9nbG9iYWxfaWQobm9kZUlkLCBhZmZlcmVudE5vZGVzVFdpZHRoLCAxLjApO1xcbiAgICAgICAgICAgICAgICAgICAgdmVjNCB0QSA9IGFmZmVyZW50Tm9kZXNUW2lkQV07XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QSA9IHRBLnI7XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgIHZlYzIgaWRCID0gZ2V0X2dsb2JhbF9pZChub2RlSWQrKGFmZmVyZW50Tm9kZXNDb3VudCksIGFmZmVyZW50Tm9kZXNUV2lkdGgsIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IHRCID0gYWZmZXJlbnROb2Rlc1RbaWRCXTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRCID0gdEIucjtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgdmVjMiBpZEMgPSBnZXRfZ2xvYmFsX2lkKG5vZGVJZCsoYWZmZXJlbnROb2Rlc0NvdW50KjIuMCksIGFmZmVyZW50Tm9kZXNUV2lkdGgsIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IHRDID0gYWZmZXJlbnROb2Rlc1RbaWRDXTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRDID0gdEMucjtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgdmVjMiBpZEQgPSBnZXRfZ2xvYmFsX2lkKG5vZGVJZCsoYWZmZXJlbnROb2Rlc0NvdW50KjMuMCksIGFmZmVyZW50Tm9kZXNUV2lkdGgsIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IHREID0gYWZmZXJlbnROb2Rlc1RbaWREXTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXREID0gdEQucjtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgdmVjMiBpZEUgPSBnZXRfZ2xvYmFsX2lkKG5vZGVJZCsoYWZmZXJlbnROb2Rlc0NvdW50KjQuMCksIGFmZmVyZW50Tm9kZXNUV2lkdGgsIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IHRFID0gYWZmZXJlbnROb2Rlc1RbaWRFXTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRFID0gdEUucjtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgdmVjMiBpZEYgPSBnZXRfZ2xvYmFsX2lkKG5vZGVJZCsoYWZmZXJlbnROb2Rlc0NvdW50KjUuMCksIGFmZmVyZW50Tm9kZXNUV2lkdGgsIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IHRGID0gYWZmZXJlbnROb2Rlc1RbaWRGXTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRGID0gdEYucjtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgdmVjMiBpZEcgPSBnZXRfZ2xvYmFsX2lkKG5vZGVJZCsoYWZmZXJlbnROb2Rlc0NvdW50KjYuMCksIGFmZmVyZW50Tm9kZXNUV2lkdGgsIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IHRHID0gYWZmZXJlbnROb2Rlc1RbaWRHXTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRHID0gdEcucjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRCaWFzTm9kZSA9PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihub2RlSWQgPj0gXCIgKyBlZmZlcmVudFN0YXJ0LnRvRml4ZWQoMSkgKyAoXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEEgPSBuZXRDaGlsZElucHV0U3VtQTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEIgPSBuZXRDaGlsZElucHV0U3VtQjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEMgPSBuZXRDaGlsZElucHV0U3VtQztcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEQgPSBuZXRDaGlsZElucHV0U3VtRDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEUgPSBuZXRDaGlsZElucHV0U3VtRTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEYgPSBuZXRDaGlsZElucHV0U3VtRjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEcgPSBuZXRDaGlsZElucHV0U3VtRztcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEEgPSAobmV0Q2hpbGRJbnB1dFN1bUEgPD0gMC4wKSA/IDAuMDEqbmV0Q2hpbGRJbnB1dFN1bUEgOiBuZXRDaGlsZElucHV0U3VtQTsgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QiA9IChuZXRDaGlsZElucHV0U3VtQiA8PSAwLjApID8gMC4wMSpuZXRDaGlsZElucHV0U3VtQiA6IG5ldENoaWxkSW5wdXRTdW1CO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QyA9IChuZXRDaGlsZElucHV0U3VtQyA8PSAwLjApID8gMC4wMSpuZXRDaGlsZElucHV0U3VtQyA6IG5ldENoaWxkSW5wdXRTdW1DO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RCA9IChuZXRDaGlsZElucHV0U3VtRCA8PSAwLjApID8gMC4wMSpuZXRDaGlsZElucHV0U3VtRCA6IG5ldENoaWxkSW5wdXRTdW1EO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RSA9IChuZXRDaGlsZElucHV0U3VtRSA8PSAwLjApID8gMC4wMSpuZXRDaGlsZElucHV0U3VtRSA6IG5ldENoaWxkSW5wdXRTdW1FO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RiA9IChuZXRDaGlsZElucHV0U3VtRiA8PSAwLjApID8gMC4wMSpuZXRDaGlsZElucHV0U3VtRiA6IG5ldENoaWxkSW5wdXRTdW1GO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RyA9IChuZXRDaGlsZElucHV0U3VtRyA8PSAwLjApID8gMC4wMSpuZXRDaGlsZElucHV0U3VtRyA6IG5ldENoaWxkSW5wdXRTdW1HO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEEgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEIgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEMgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEQgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEUgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEYgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEcgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0QSA9IGN1cnJlbnREYXRhQi56O1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0QiA9IGN1cnJlbnREYXRhRi54O1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0QyA9IGN1cnJlbnREYXRhRi56O1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0RCA9IGN1cnJlbnREYXRhRy54O1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0RSA9IGN1cnJlbnREYXRhRy56O1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0RiA9IGN1cnJlbnREYXRhSC54O1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0RyA9IGN1cnJlbnREYXRhSC56O1xcbiAgICAgICAgICAgIH1cIik7XG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIEVSUk9SXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICBmb3IgKHZhciBuID0gZWZmZXJlbnRTdGFydDsgbiA8IGVmZmVyZW50U3RhcnQgKyBlZmZlcmVudE5vZGVzQ291bnQ7IG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBjb25kID0gbiA9PT0gZWZmZXJlbnRTdGFydCA/IFwiaWZcIiA6IFwiZWxzZSBpZlwiO1xuICAgICAgICAgICAgICAgIHN0ciArPSBcIlxcbiAgICAgICAgICAgIFwiICsgY29uZCArIFwiKG5vZGVJZCA9PSBcIiArIG4udG9GaXhlZCgxKSArIChcIikge1xcbiAgICAgICAgICAgICAgICBpZihmcmVlemVPdXRwdXQgPT0gMC4wKSB7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QSA9IG5ldENoaWxkSW5wdXRTdW1BOyBcIiArIFwiIFxcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEIgPSBuZXRDaGlsZElucHV0U3VtQjtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRDID0gbmV0Q2hpbGRJbnB1dFN1bUM7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RCA9IG5ldENoaWxkSW5wdXRTdW1EO1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEUgPSBuZXRDaGlsZElucHV0U3VtRTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRGID0gbmV0Q2hpbGRJbnB1dFN1bUY7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RyA9IG5ldENoaWxkSW5wdXRTdW1HO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEEgPSBjdXJyZW50RGF0YUIuejtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRCID0gY3VycmVudERhdGFGLng7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QyA9IGN1cnJlbnREYXRhRi56O1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEQgPSBjdXJyZW50RGF0YUcueDtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRFID0gY3VycmVudERhdGFHLno7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RiA9IGN1cnJlbnREYXRhSC54O1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEcgPSBjdXJyZW50RGF0YUguejtcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEEgPSBlZmZlcmVudE5vZGVzQVtcIikgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXTtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRCID0gZWZmZXJlbnROb2Rlc0JbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXTtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRDID0gZWZmZXJlbnROb2Rlc0NbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXTtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHREID0gZWZmZXJlbnROb2Rlc0RbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXTtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRFID0gZWZmZXJlbnROb2Rlc0VbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXTtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRGID0gZWZmZXJlbnROb2Rlc0ZbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXTtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRHID0gZWZmZXJlbnROb2Rlc0dbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXTtcXG4gICAgICAgICAgICB9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEtFUk5FTF9ESVI7XG59KCk7XG5cbmdsb2JhbC5LRVJORUxfRElSID0gS0VSTkVMX0RJUjtcbm1vZHVsZS5leHBvcnRzLktFUk5FTF9ESVIgPSBLRVJORUxfRElSOyJdfQ==
