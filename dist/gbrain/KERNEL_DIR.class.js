(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var KERNEL_DIR = exports.KERNEL_DIR = function () {
    function KERNEL_DIR() {
        _classCallCheck(this, KERNEL_DIR);
    }

    _createClass(KERNEL_DIR, null, [{
        key: "getSrc",
        value: function getSrc(customCode, geometryLength, afferentNodesCount, efferentStart, efferentNodesCount) {
            var outputArr = ["dir", "posXYZW", "dataB", "dataF", "dataG", "dataH"];
            var returnStr = 'return [vec4(currentDir, 1.0), vec4(currentPos.x, currentPos.y, currentPos.z, 1.0), currentDataB, currentDataF, currentDataG, currentDataH];';

            return ["x", outputArr,
            // head
            "float tanh(float val) {\n                float tmp = exp(val);\n                float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n                return tanH;\n            }\n            float sigm(float val) {\n                return (1.0 / (1.0 + exp(-val)));\n            }",

            // source
            "float nodeId = data[x].x;\n            vec2 xGeometry = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n            vec3 currentPos = posXYZW[xGeometry].xyz;\n            vec3 currentDir = dir[xGeometry].xyz;\n\n\n            vec4 currentDataB = dataB[xGeometry];\n            vec4 currentDataF = dataF[xGeometry];\n            vec4 currentDataG = dataG[xGeometry];\n            vec4 currentDataH = dataH[xGeometry];\n\n            currentDir = vec3(0.0, 0.0, 0.0);\n\n            \n            vec3 atraction = vec3(0.0, 0.0, 0.0);\n            float acumAtraction = 1.0;\n            vec3 repulsion = vec3(0.0, 0.0, 0.0);\n\n            vec3 force = vec3(0.0, 0.0, 0.0);\n\n\n            float netChildInputSumA = 0.0;\n            float foutputA = 0.0;\n            float netParentErrorWeightA = 0.0;\n            \n            float netChildInputSumB = 0.0;\n            float foutputB = 0.0;\n            float netParentErrorWeightB = 0.0;\n            \n            float netChildInputSumC = 0.0;\n            float foutputC = 0.0;\n            float netParentErrorWeightC = 0.0;\n            \n            float netChildInputSumD = 0.0;\n            float foutputD = 0.0;\n            float netParentErrorWeightD = 0.0;\n            \n            float netChildInputSumE = 0.0;\n            float foutputE = 0.0;\n            float netParentErrorWeightE = 0.0;\n            \n\n            if(nodeId < nodesCount && enableTrain == 0.0) {\n                float currentActivationFn = 0.0;\n                vec2 xGeomCurrent = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n                for(int n=0; n < 4096; n++) {\n                    if(float(n) >= nodesCount) {break;}\n                    if(float(n) != nodeId) {\n                        vec2 xGeomOpposite = get_global_id(float(n), uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n                        vec2 xAdjMatCurrent = get_global_id(vec2(float(n), nodeId), widthAdjMatrix);\n                        vec2 xAdjMatOpposite = get_global_id(vec2(nodeId, float(n)), widthAdjMatrix);\n\n                        vec4 pixAdjMatACurrent = adjacencyMatrix[xAdjMatCurrent];\n                        vec4 pixAdjMatAOpposite = adjacencyMatrix[xAdjMatOpposite];\n\n                        vec4 pixAdjMatBCurrent = adjacencyMatrixB[xAdjMatCurrent];\n                        vec4 pixAdjMatBOpposite = adjacencyMatrixB[xAdjMatOpposite];\n\n\n                                                                    \n                        " + "\n                        float currentLayerNum = pixAdjMatACurrent.x;\n                        float currentWeight = pixAdjMatACurrent.z;\n                        float currentIsParent = pixAdjMatACurrent.w;\n            \n                        " + "\n                        float oppositeLayerNum = pixAdjMatAOpposite.x;\n                        float oppositeWeight = pixAdjMatAOpposite.z;\n                        float oppositeIsParent = pixAdjMatAOpposite.w;\n            \n            \n                        " + "\n                        float currentLinkMultiplier = pixAdjMatBCurrent.x;\n                        float currentActivationFn = pixAdjMatBCurrent.y;\n            \n                        " + "\n                        float oppositeLinkMultiplier = pixAdjMatBOpposite.x;\n                        float oppositeActivationFn = pixAdjMatBOpposite.y;\n            \n            \n            \n                        " + "\n                        float currentBiasNode = dataB[xGeomCurrent].x;\n                        " + "\n            \n                        " + "\n                        float oppositeBiasNode = dataB[xGeomOpposite].x;\n                        \n                        float oppositeNetErrorA = dataB[xGeomOpposite].y;\n                        float oppositeNetOutputA = dataB[xGeomOpposite].z;\n                        float oppositeInputsumA = dataB[xGeomOpposite].w;\n                        \n                        float oppositeNetErrorB = dataF[xGeomOpposite].x;\n                        float oppositeNetOutputB = dataF[xGeomOpposite].y;\n                        float oppositeInputsumB = dataF[xGeomOpposite].z;\n                    \n                        float oppositeNetErrorC = dataF[xGeomOpposite].w;\n                        float oppositeNetOutputC = dataG[xGeomOpposite].x;\n                        float oppositeInputsumC = dataG[xGeomOpposite].y;\n                    \n                        float oppositeNetErrorD = dataG[xGeomOpposite].z;\n                        float oppositeNetOutputD = dataG[xGeomOpposite].w;\n                        float oppositeInputsumD = dataH[xGeomOpposite].x;\n                    \n                        float oppositeNetErrorE = dataH[xGeomOpposite].y;\n                        float oppositeNetOutputE = dataH[xGeomOpposite].z;\n                        float oppositeInputsumE = dataH[xGeomOpposite].w;\n            \n            \n                        " + "\n                        " + "\n                        " + "\n            \n                        " + "\n                        vec3 oppositePos = posXYZW[xGeomOpposite].xyz;\n                        vec3 oppositeDir = dir[xGeomOpposite].xyz;\n            \n                        " + "\n                        vec3 dirToOpposite = (oppositePos-currentPos);\n                        vec3 dirToOppositeN = normalize(dirToOpposite);\n            \n                        float dist = distance(oppositePos, currentPos); " + "\n                        float distN = max(0.0,dist)/100000.0;\n            \n                        float mm = 200.0;\n                        float m1 = 400000.0/mm;\n                        float m2 = 48.0/mm;\n                        if(currentIsParent == 1.0) {\n                            netChildInputSumA += oppositeNetOutputA*oppositeWeight;\n                            netChildInputSumB += oppositeNetOutputB*oppositeWeight;\n                            netChildInputSumC += oppositeNetOutputC*oppositeWeight;\n                            netChildInputSumD += oppositeNetOutputD*oppositeWeight;\n                            netChildInputSumE += oppositeNetOutputE*oppositeWeight;\n                            \n                            atraction += dirToOppositeN*max(1.0, distN*abs(oppositeWeight)*(m1/2.0));\n                            repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(oppositeWeight)*(m2/2.0));\n                            acumAtraction += 1.0;\n                        } else if(currentIsParent == 0.5) {\n                            float parentGOutputDerivA = 1.0;                    \n                            float parentGOutputDerivB = 1.0;\n                            float parentGOutputDerivC = 1.0;\n                            float parentGOutputDerivD = 1.0;\n                            float parentGOutputDerivE = 1.0;\n                            if(currentLayerNum < layerCount-1.0) { \n                                parentGOutputDerivA = (oppositeInputsumA <= 0.0) ? 0.01 : 1.0;                    \n                                parentGOutputDerivB = (oppositeInputsumB <= 0.0) ? 0.01 : 1.0;\n                                parentGOutputDerivC = (oppositeInputsumC <= 0.0) ? 0.01 : 1.0;\n                                parentGOutputDerivD = (oppositeInputsumD <= 0.0) ? 0.01 : 1.0;\n                                parentGOutputDerivE = (oppositeInputsumE <= 0.0) ? 0.01 : 1.0;\n                            }\n                            \n                            if(currentBiasNode == 0.0) {\n                                netParentErrorWeightA += oppositeNetErrorA*parentGOutputDerivA*currentWeight;\n                                netParentErrorWeightB += oppositeNetErrorB*parentGOutputDerivB*currentWeight;\n                                netParentErrorWeightC += oppositeNetErrorC*parentGOutputDerivC*currentWeight;\n                                netParentErrorWeightD += oppositeNetErrorD*parentGOutputDerivD*currentWeight;\n                                netParentErrorWeightE += oppositeNetErrorE*parentGOutputDerivE*currentWeight;\n                            } else {\n                                netParentErrorWeightA += oppositeNetErrorA*parentGOutputDerivA;\n                                netParentErrorWeightB += oppositeNetErrorB*parentGOutputDerivB;\n                                netParentErrorWeightC += oppositeNetErrorC*parentGOutputDerivC;\n                                netParentErrorWeightD += oppositeNetErrorD*parentGOutputDerivD;\n                                netParentErrorWeightE += oppositeNetErrorE*parentGOutputDerivE;\n                            }\n                            atraction += dirToOppositeN*max(1.0, distN*abs(currentWeight)*m1);\n                            repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*m2);\n                            acumAtraction += 1.0;\n                        }\n            \n                        repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*(m2/8.0));\n                        acumAtraction += 1.0;\n                    }\n                }\n                \n                float vndm = (viewNeuronDynamics == 1.0) ? netChildInputSumA : 1.0;\n                force += (atraction/acumAtraction)*abs(vndm);\n                force += (repulsion/acumAtraction)*abs(vndm);\n                currentDir += force;\n                \n                \n                float currentBiasNode = dataB[xGeomCurrent].x;\n                \n                " + KERNEL_DIR.efferentNodesStr(afferentNodesCount, efferentStart, efferentNodesCount) + "\n                \n                currentDataB = vec4(currentDataB.x, netParentErrorWeightA, foutputA, netChildInputSumA);\n                currentDataF = vec4(netParentErrorWeightB, foutputB, netChildInputSumB, netParentErrorWeightC);\n                currentDataG = vec4(foutputC, netChildInputSumC, netParentErrorWeightD, foutputD);\n                currentDataH = vec4(netChildInputSumD, netParentErrorWeightE, foutputE, netChildInputSumE);\n            }\n\n            " + (customCode !== undefined ? customCode : '') + "\n\n            if(enableDrag == 1.0) {\n                if(nodeId == idToDrag) {\n                    currentPos = vec3(MouseDragTranslationX, MouseDragTranslationY, MouseDragTranslationZ);\n                }\n            }\n\n            currentPos += currentDir;\n            if(only2d == 1.0) {\n                currentPos.y = 0.0;\n            }\n\n            " + returnStr];
        }
    }, {
        key: "efferentNodesStr",
        value: function efferentNodesStr(afferentNodesCount, efferentStart, efferentNodesCount) {
            /////////////////////////////////////////////////
            // OUTPUT
            /////////////////////////////////////////////////
            var str = "\n            if(nodeId < afferentNodesCount) {\n                for(float n=0.0; n < 1024.0; n+=1.0) {\n                    if(n >= afferentNodesCount) {\n                        break;\n                    }\n                    if(nodeId == n) {\n                        foutputA = afferentNodesA[int(n)];\n                        foutputB = afferentNodesB[int(n)];\n                        foutputC = afferentNodesC[int(n)];\n                        foutputD = afferentNodesD[int(n)];\n                        foutputE = afferentNodesE[int(n)];\n                        break;\n                    }\n                }\n            } else {\n                if(currentBiasNode == 0.0) {                                     \n                    foutputA = (netChildInputSumA <= 0.0) ? 0.01*netChildInputSumA : netChildInputSumA; " + "\n                    foutputB = (netChildInputSumB <= 0.0) ? 0.01*netChildInputSumB : netChildInputSumB;\n                    foutputC = (netChildInputSumC <= 0.0) ? 0.01*netChildInputSumC : netChildInputSumC;\n                    foutputD = (netChildInputSumD <= 0.0) ? 0.01*netChildInputSumD : netChildInputSumD;\n                    foutputE = (netChildInputSumE <= 0.0) ? 0.01*netChildInputSumE : netChildInputSumE;\n                } else {\n                    foutputA = 1.0;\n                    foutputB = 1.0;\n                    foutputC = 1.0;\n                    foutputD = 1.0;\n                    foutputE = 1.0;\n                }\n            }";

            /////////////////////////////////////////////////
            // ERROR
            /////////////////////////////////////////////////
            for (var n = efferentStart; n < efferentStart + efferentNodesCount; n++) {
                var cond = n === efferentStart ? "if" : "else if";
                str += "\n            " + cond + "(nodeId == " + n.toFixed(1) + (") {\n                foutputA = netChildInputSumA; " + " \n                foutputB = netChildInputSumB;\n                foutputC = netChildInputSumC;\n                foutputD = netChildInputSumD;\n                foutputE = netChildInputSumE;\n                    \n                netParentErrorWeightA = efferentNodesA[") + Math.round(n - efferentStart) + "];\n                netParentErrorWeightB = efferentNodesB[" + Math.round(n - efferentStart) + "];\n                netParentErrorWeightC = efferentNodesC[" + Math.round(n - efferentStart) + "];\n                netParentErrorWeightD = efferentNodesD[" + Math.round(n - efferentStart) + "];\n                netParentErrorWeightE = efferentNodesE[" + Math.round(n - efferentStart) + "];\n            }";
            }
            return str;
        }
    }]);

    return KERNEL_DIR;
}();

global.KERNEL_DIR = KERNEL_DIR;
module.exports.KERNEL_DIR = KERNEL_DIR;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZ2JyYWluL0tFUk5FTF9ESVIuY2xhc3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO2Rlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1yZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO2lmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO3JldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9O1xufSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5cbnZhciBLRVJORUxfRElSID0gZXhwb3J0cy5LRVJORUxfRElSID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtFUk5FTF9ESVIoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLRVJORUxfRElSKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoS0VSTkVMX0RJUiwgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcImdldFNyY1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3JjKGN1c3RvbUNvZGUsIGdlb21ldHJ5TGVuZ3RoLCBhZmZlcmVudE5vZGVzQ291bnQsIGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dEFyciA9IFtcImRpclwiLCBcInBvc1hZWldcIiwgXCJkYXRhQlwiLCBcImRhdGFGXCIsIFwiZGF0YUdcIiwgXCJkYXRhSFwiXTtcbiAgICAgICAgICAgIHZhciByZXR1cm5TdHIgPSAncmV0dXJuIFt2ZWM0KGN1cnJlbnREaXIsIDEuMCksIHZlYzQoY3VycmVudFBvcy54LCBjdXJyZW50UG9zLnksIGN1cnJlbnRQb3MueiwgMS4wKSwgY3VycmVudERhdGFCLCBjdXJyZW50RGF0YUYsIGN1cnJlbnREYXRhRywgY3VycmVudERhdGFIXTsnO1xuXG4gICAgICAgICAgICByZXR1cm4gW1wieFwiLCBvdXRwdXRBcnIsXG4gICAgICAgICAgICAvLyBoZWFkXG4gICAgICAgICAgICBcImZsb2F0IHRhbmgoZmxvYXQgdmFsKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHRtcCA9IGV4cCh2YWwpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB0YW5IID0gKHRtcCAtIDEuMCAvIHRtcCkgLyAodG1wICsgMS4wIC8gdG1wKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhbkg7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGZsb2F0IHNpZ20oZmxvYXQgdmFsKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAoMS4wIC8gKDEuMCArIGV4cCgtdmFsKSkpO1xcbiAgICAgICAgICAgIH1cIixcblxuICAgICAgICAgICAgLy8gc291cmNlXG4gICAgICAgICAgICBcImZsb2F0IG5vZGVJZCA9IGRhdGFbeF0ueDtcXG4gICAgICAgICAgICB2ZWMyIHhHZW9tZXRyeSA9IGdldF9nbG9iYWxfaWQobm9kZUlkLCB1QnVmZmVyV2lkdGgsIFwiICsgZ2VvbWV0cnlMZW5ndGgudG9GaXhlZCgxKSArIFwiKTtcXG5cXG5cXG4gICAgICAgICAgICB2ZWMzIGN1cnJlbnRQb3MgPSBwb3NYWVpXW3hHZW9tZXRyeV0ueHl6O1xcbiAgICAgICAgICAgIHZlYzMgY3VycmVudERpciA9IGRpclt4R2VvbWV0cnldLnh5ejtcXG5cXG5cXG4gICAgICAgICAgICB2ZWM0IGN1cnJlbnREYXRhQiA9IGRhdGFCW3hHZW9tZXRyeV07XFxuICAgICAgICAgICAgdmVjNCBjdXJyZW50RGF0YUYgPSBkYXRhRlt4R2VvbWV0cnldO1xcbiAgICAgICAgICAgIHZlYzQgY3VycmVudERhdGFHID0gZGF0YUdbeEdlb21ldHJ5XTtcXG4gICAgICAgICAgICB2ZWM0IGN1cnJlbnREYXRhSCA9IGRhdGFIW3hHZW9tZXRyeV07XFxuXFxuICAgICAgICAgICAgY3VycmVudERpciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgdmVjMyBhdHJhY3Rpb24gPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcbiAgICAgICAgICAgIGZsb2F0IGFjdW1BdHJhY3Rpb24gPSAxLjA7XFxuICAgICAgICAgICAgdmVjMyByZXB1bHNpb24gPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcblxcbiAgICAgICAgICAgIHZlYzMgZm9yY2UgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcblxcblxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1BID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRBID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QSA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQiA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0QiA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEIgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUMgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEMgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRDID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1EID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXREID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RCA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRSA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0RSA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEUgPSAwLjA7XFxuICAgICAgICAgICAgXFxuXFxuICAgICAgICAgICAgaWYobm9kZUlkIDwgbm9kZXNDb3VudCAmJiBlbmFibGVUcmFpbiA9PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudEFjdGl2YXRpb25GbiA9IDAuMDtcXG4gICAgICAgICAgICAgICAgdmVjMiB4R2VvbUN1cnJlbnQgPSBnZXRfZ2xvYmFsX2lkKG5vZGVJZCwgdUJ1ZmZlcldpZHRoLCBcIiArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyBcIik7XFxuICAgICAgICAgICAgICAgIGZvcihpbnQgbj0wOyBuIDwgNDA5NjsgbisrKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZihmbG9hdChuKSA+PSBub2Rlc0NvdW50KSB7YnJlYWs7fVxcbiAgICAgICAgICAgICAgICAgICAgaWYoZmxvYXQobikgIT0gbm9kZUlkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMiB4R2VvbU9wcG9zaXRlID0gZ2V0X2dsb2JhbF9pZChmbG9hdChuKSwgdUJ1ZmZlcldpZHRoLCBcIiArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyBcIik7XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMiB4QWRqTWF0Q3VycmVudCA9IGdldF9nbG9iYWxfaWQodmVjMihmbG9hdChuKSwgbm9kZUlkKSwgd2lkdGhBZGpNYXRyaXgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIgeEFkak1hdE9wcG9zaXRlID0gZ2V0X2dsb2JhbF9pZCh2ZWMyKG5vZGVJZCwgZmxvYXQobikpLCB3aWR0aEFkak1hdHJpeCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRBQ3VycmVudCA9IGFkamFjZW5jeU1hdHJpeFt4QWRqTWF0Q3VycmVudF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRBT3Bwb3NpdGUgPSBhZGphY2VuY3lNYXRyaXhbeEFkak1hdE9wcG9zaXRlXTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEJDdXJyZW50ID0gYWRqYWNlbmN5TWF0cml4Qlt4QWRqTWF0Q3VycmVudF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRCT3Bwb3NpdGUgPSBhZGphY2VuY3lNYXRyaXhCW3hBZGpNYXRPcHBvc2l0ZV07XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudExheWVyTnVtID0gcGl4QWRqTWF0QUN1cnJlbnQueDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50V2VpZ2h0ID0gcGl4QWRqTWF0QUN1cnJlbnQuejtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50SXNQYXJlbnQgPSBwaXhBZGpNYXRBQ3VycmVudC53O1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUxheWVyTnVtID0gcGl4QWRqTWF0QU9wcG9zaXRlLng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVXZWlnaHQgPSBwaXhBZGpNYXRBT3Bwb3NpdGUuejtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUlzUGFyZW50ID0gcGl4QWRqTWF0QU9wcG9zaXRlLnc7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGN1cnJlbnRMaW5rTXVsdGlwbGllciA9IHBpeEFkak1hdEJDdXJyZW50Lng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudEFjdGl2YXRpb25GbiA9IHBpeEFkak1hdEJDdXJyZW50Lnk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTGlua011bHRpcGxpZXIgPSBwaXhBZGpNYXRCT3Bwb3NpdGUueDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUFjdGl2YXRpb25GbiA9IHBpeEFkak1hdEJPcHBvc2l0ZS55O1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50Qmlhc05vZGUgPSBkYXRhQlt4R2VvbUN1cnJlbnRdLng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUJpYXNOb2RlID0gZGF0YUJbeEdlb21PcHBvc2l0ZV0ueDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yQSA9IGRhdGFCW3hHZW9tT3Bwb3NpdGVdLnk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRBID0gZGF0YUJbeEdlb21PcHBvc2l0ZV0uejtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUlucHV0c3VtQSA9IGRhdGFCW3hHZW9tT3Bwb3NpdGVdLnc7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckIgPSBkYXRhRlt4R2VvbU9wcG9zaXRlXS54O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0QiA9IGRhdGFGW3hHZW9tT3Bwb3NpdGVdLnk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVJbnB1dHN1bUIgPSBkYXRhRlt4R2VvbU9wcG9zaXRlXS56O1xcbiAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckMgPSBkYXRhRlt4R2VvbU9wcG9zaXRlXS53O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0QyA9IGRhdGFHW3hHZW9tT3Bwb3NpdGVdLng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVJbnB1dHN1bUMgPSBkYXRhR1t4R2VvbU9wcG9zaXRlXS55O1xcbiAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckQgPSBkYXRhR1t4R2VvbU9wcG9zaXRlXS56O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0RCA9IGRhdGFHW3hHZW9tT3Bwb3NpdGVdLnc7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVJbnB1dHN1bUQgPSBkYXRhSFt4R2VvbU9wcG9zaXRlXS54O1xcbiAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckUgPSBkYXRhSFt4R2VvbU9wcG9zaXRlXS55O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0RSA9IGRhdGFIW3hHZW9tT3Bwb3NpdGVdLno7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVJbnB1dHN1bUUgPSBkYXRhSFt4R2VvbU9wcG9zaXRlXS53O1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMzIG9wcG9zaXRlUG9zID0gcG9zWFlaV1t4R2VvbU9wcG9zaXRlXS54eXo7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyBvcHBvc2l0ZURpciA9IGRpclt4R2VvbU9wcG9zaXRlXS54eXo7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgZGlyVG9PcHBvc2l0ZSA9IChvcHBvc2l0ZVBvcy1jdXJyZW50UG9zKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMzIGRpclRvT3Bwb3NpdGVOID0gbm9ybWFsaXplKGRpclRvT3Bwb3NpdGUpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGRpc3QgPSBkaXN0YW5jZShvcHBvc2l0ZVBvcywgY3VycmVudFBvcyk7IFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkaXN0TiA9IG1heCgwLjAsZGlzdCkvMTAwMDAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbW0gPSAyMDAuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBtMSA9IDQwMDAwMC4wL21tO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG0yID0gNDguMC9tbTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50SXNQYXJlbnQgPT0gMS4wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1BICs9IG9wcG9zaXRlTmV0T3V0cHV0QSpvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUIgKz0gb3Bwb3NpdGVOZXRPdXRwdXRCKm9wcG9zaXRlV2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQyArPSBvcHBvc2l0ZU5ldE91dHB1dEMqb3Bwb3NpdGVXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1EICs9IG9wcG9zaXRlTmV0T3V0cHV0RCpvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUUgKz0gb3Bwb3NpdGVOZXRPdXRwdXRFKm9wcG9zaXRlV2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRyYWN0aW9uICs9IGRpclRvT3Bwb3NpdGVOKm1heCgxLjAsIGRpc3ROKmFicyhvcHBvc2l0ZVdlaWdodCkqKG0xLzIuMCkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXB1bHNpb24gKz0gLWRpclRvT3Bwb3NpdGVOKm1heCgxLjAsICgxLjAtZGlzdE4pKmFicyhvcHBvc2l0ZVdlaWdodCkqKG0yLzIuMCkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3VtQXRyYWN0aW9uICs9IDEuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoY3VycmVudElzUGFyZW50ID09IDAuNSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRHT3V0cHV0RGVyaXZBID0gMS4wOyAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBhcmVudEdPdXRwdXREZXJpdkIgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBhcmVudEdPdXRwdXREZXJpdkMgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBhcmVudEdPdXRwdXREZXJpdkQgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBhcmVudEdPdXRwdXREZXJpdkUgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRMYXllck51bSA8IGxheWVyQ291bnQtMS4wKSB7IFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50R091dHB1dERlcml2QSA9IChvcHBvc2l0ZUlucHV0c3VtQSA8PSAwLjApID8gMC4wMSA6IDEuMDsgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50R091dHB1dERlcml2QiA9IChvcHBvc2l0ZUlucHV0c3VtQiA8PSAwLjApID8gMC4wMSA6IDEuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEdPdXRwdXREZXJpdkMgPSAob3Bwb3NpdGVJbnB1dHN1bUMgPD0gMC4wKSA/IDAuMDEgOiAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRHT3V0cHV0RGVyaXZEID0gKG9wcG9zaXRlSW5wdXRzdW1EIDw9IDAuMCkgPyAwLjAxIDogMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50R091dHB1dERlcml2RSA9IChvcHBvc2l0ZUlucHV0c3VtRSA8PSAwLjApID8gMC4wMSA6IDEuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudEJpYXNOb2RlID09IDAuMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRBICs9IG9wcG9zaXRlTmV0RXJyb3JBKnBhcmVudEdPdXRwdXREZXJpdkEqY3VycmVudFdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiArPSBvcHBvc2l0ZU5ldEVycm9yQipwYXJlbnRHT3V0cHV0RGVyaXZCKmN1cnJlbnRXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEMgKz0gb3Bwb3NpdGVOZXRFcnJvckMqcGFyZW50R091dHB1dERlcml2QypjdXJyZW50V2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHREICs9IG9wcG9zaXRlTmV0RXJyb3JEKnBhcmVudEdPdXRwdXREZXJpdkQqY3VycmVudFdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSArPSBvcHBvc2l0ZU5ldEVycm9yRSpwYXJlbnRHT3V0cHV0RGVyaXZFKmN1cnJlbnRXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEEgKz0gb3Bwb3NpdGVOZXRFcnJvckEqcGFyZW50R091dHB1dERlcml2QTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiArPSBvcHBvc2l0ZU5ldEVycm9yQipwYXJlbnRHT3V0cHV0RGVyaXZCO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRDICs9IG9wcG9zaXRlTmV0RXJyb3JDKnBhcmVudEdPdXRwdXREZXJpdkM7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEQgKz0gb3Bwb3NpdGVOZXRFcnJvckQqcGFyZW50R091dHB1dERlcml2RDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSArPSBvcHBvc2l0ZU5ldEVycm9yRSpwYXJlbnRHT3V0cHV0RGVyaXZFO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0cmFjdGlvbiArPSBkaXJUb09wcG9zaXRlTiptYXgoMS4wLCBkaXN0TiphYnMoY3VycmVudFdlaWdodCkqbTEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXB1bHNpb24gKz0gLWRpclRvT3Bwb3NpdGVOKm1heCgxLjAsICgxLjAtZGlzdE4pKmFicyhjdXJyZW50V2VpZ2h0KSptMik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdW1BdHJhY3Rpb24gKz0gMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXB1bHNpb24gKz0gLWRpclRvT3Bwb3NpdGVOKm1heCgxLjAsICgxLjAtZGlzdE4pKmFicyhjdXJyZW50V2VpZ2h0KSoobTIvOC4wKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN1bUF0cmFjdGlvbiArPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGZsb2F0IHZuZG0gPSAodmlld05ldXJvbkR5bmFtaWNzID09IDEuMCkgPyBuZXRDaGlsZElucHV0U3VtQSA6IDEuMDtcXG4gICAgICAgICAgICAgICAgZm9yY2UgKz0gKGF0cmFjdGlvbi9hY3VtQXRyYWN0aW9uKSphYnModm5kbSk7XFxuICAgICAgICAgICAgICAgIGZvcmNlICs9IChyZXB1bHNpb24vYWN1bUF0cmFjdGlvbikqYWJzKHZuZG0pO1xcbiAgICAgICAgICAgICAgICBjdXJyZW50RGlyICs9IGZvcmNlO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGZsb2F0IGN1cnJlbnRCaWFzTm9kZSA9IGRhdGFCW3hHZW9tQ3VycmVudF0ueDtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIFwiICsgS0VSTkVMX0RJUi5lZmZlcmVudE5vZGVzU3RyKGFmZmVyZW50Tm9kZXNDb3VudCwgZWZmZXJlbnRTdGFydCwgZWZmZXJlbnROb2Rlc0NvdW50KSArIFwiXFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0YUIgPSB2ZWM0KGN1cnJlbnREYXRhQi54LCBuZXRQYXJlbnRFcnJvcldlaWdodEEsIGZvdXRwdXRBLCBuZXRDaGlsZElucHV0U3VtQSk7XFxuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRhRiA9IHZlYzQobmV0UGFyZW50RXJyb3JXZWlnaHRCLCBmb3V0cHV0QiwgbmV0Q2hpbGRJbnB1dFN1bUIsIG5ldFBhcmVudEVycm9yV2VpZ2h0Qyk7XFxuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRhRyA9IHZlYzQoZm91dHB1dEMsIG5ldENoaWxkSW5wdXRTdW1DLCBuZXRQYXJlbnRFcnJvcldlaWdodEQsIGZvdXRwdXREKTtcXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGFIID0gdmVjNChuZXRDaGlsZElucHV0U3VtRCwgbmV0UGFyZW50RXJyb3JXZWlnaHRFLCBmb3V0cHV0RSwgbmV0Q2hpbGRJbnB1dFN1bUUpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBcIiArIChjdXN0b21Db2RlICE9PSB1bmRlZmluZWQgPyBjdXN0b21Db2RlIDogJycpICsgXCJcXG5cXG4gICAgICAgICAgICBpZihlbmFibGVEcmFnID09IDEuMCkge1xcbiAgICAgICAgICAgICAgICBpZihub2RlSWQgPT0gaWRUb0RyYWcpIHtcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSB2ZWMzKE1vdXNlRHJhZ1RyYW5zbGF0aW9uWCwgTW91c2VEcmFnVHJhbnNsYXRpb25ZLCBNb3VzZURyYWdUcmFuc2xhdGlvblopO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gY3VycmVudERpcjtcXG4gICAgICAgICAgICBpZihvbmx5MmQgPT0gMS4wKSB7XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MueSA9IDAuMDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgXCIgKyByZXR1cm5TdHJdO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZWZmZXJlbnROb2Rlc1N0clwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZWZmZXJlbnROb2Rlc1N0cihhZmZlcmVudE5vZGVzQ291bnQsIGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkge1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gT1VUUFVUXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICB2YXIgc3RyID0gXCJcXG4gICAgICAgICAgICBpZihub2RlSWQgPCBhZmZlcmVudE5vZGVzQ291bnQpIHtcXG4gICAgICAgICAgICAgICAgZm9yKGZsb2F0IG49MC4wOyBuIDwgMTAyNC4wOyBuKz0xLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmKG4gPj0gYWZmZXJlbnROb2Rlc0NvdW50KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBpZihub2RlSWQgPT0gbikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRBID0gYWZmZXJlbnROb2Rlc0FbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QiA9IGFmZmVyZW50Tm9kZXNCW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEMgPSBhZmZlcmVudE5vZGVzQ1tpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXREID0gYWZmZXJlbnROb2Rlc0RbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RSA9IGFmZmVyZW50Tm9kZXNFW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50Qmlhc05vZGUgPT0gMC4wKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEEgPSAobmV0Q2hpbGRJbnB1dFN1bUEgPD0gMC4wKSA/IDAuMDEqbmV0Q2hpbGRJbnB1dFN1bUEgOiBuZXRDaGlsZElucHV0U3VtQTsgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEIgPSAobmV0Q2hpbGRJbnB1dFN1bUIgPD0gMC4wKSA/IDAuMDEqbmV0Q2hpbGRJbnB1dFN1bUIgOiBuZXRDaGlsZElucHV0U3VtQjtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRDID0gKG5ldENoaWxkSW5wdXRTdW1DIDw9IDAuMCkgPyAwLjAxKm5ldENoaWxkSW5wdXRTdW1DIDogbmV0Q2hpbGRJbnB1dFN1bUM7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RCA9IChuZXRDaGlsZElucHV0U3VtRCA8PSAwLjApID8gMC4wMSpuZXRDaGlsZElucHV0U3VtRCA6IG5ldENoaWxkSW5wdXRTdW1EO1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEUgPSAobmV0Q2hpbGRJbnB1dFN1bUUgPD0gMC4wKSA/IDAuMDEqbmV0Q2hpbGRJbnB1dFN1bUUgOiBuZXRDaGlsZElucHV0U3VtRTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRBID0gMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEIgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QyA9IDEuMDtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXREID0gMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEUgPSAxLjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XCI7XG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIEVSUk9SXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICBmb3IgKHZhciBuID0gZWZmZXJlbnRTdGFydDsgbiA8IGVmZmVyZW50U3RhcnQgKyBlZmZlcmVudE5vZGVzQ291bnQ7IG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBjb25kID0gbiA9PT0gZWZmZXJlbnRTdGFydCA/IFwiaWZcIiA6IFwiZWxzZSBpZlwiO1xuICAgICAgICAgICAgICAgIHN0ciArPSBcIlxcbiAgICAgICAgICAgIFwiICsgY29uZCArIFwiKG5vZGVJZCA9PSBcIiArIG4udG9GaXhlZCgxKSArIChcIikge1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0QSA9IG5ldENoaWxkSW5wdXRTdW1BOyBcIiArIFwiIFxcbiAgICAgICAgICAgICAgICBmb3V0cHV0QiA9IG5ldENoaWxkSW5wdXRTdW1CO1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0QyA9IG5ldENoaWxkSW5wdXRTdW1DO1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0RCA9IG5ldENoaWxkSW5wdXRTdW1EO1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0RSA9IG5ldENoaWxkSW5wdXRTdW1FO1xcbiAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QSA9IGVmZmVyZW50Tm9kZXNBW1wiKSArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdO1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEIgPSBlZmZlcmVudE5vZGVzQltcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdO1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEMgPSBlZmZlcmVudE5vZGVzQ1tcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdO1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEQgPSBlZmZlcmVudE5vZGVzRFtcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdO1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEUgPSBlZmZlcmVudE5vZGVzRVtcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdO1xcbiAgICAgICAgICAgIH1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gS0VSTkVMX0RJUjtcbn0oKTtcblxuZ2xvYmFsLktFUk5FTF9ESVIgPSBLRVJORUxfRElSO1xubW9kdWxlLmV4cG9ydHMuS0VSTkVMX0RJUiA9IEtFUk5FTF9ESVI7Il19
