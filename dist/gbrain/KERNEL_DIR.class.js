(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
                    value: true
});
exports.KERNEL_DIR = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _graphUtil = require("./graphUtil");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var KERNEL_DIR = exports.KERNEL_DIR = function () {
                    function KERNEL_DIR() {
                                        _classCallCheck(this, KERNEL_DIR);
                    }

                    _createClass(KERNEL_DIR, null, [{
                                        key: "getSrc",
                                        value: function getSrc(customCode, geometryLength, efferentStart, efferentNodesCount) {
                                                            var outputArr = ["dir", "posXYZW", "dataB", "dataF", "dataG", "dataH"];
                                                            var returnStr = 'return [vec4(currentDir, 1.0), vec4(currentPos.x, currentPos.y, currentPos.z, 1.0), currentDataB, currentDataF, currentDataG, currentDataH];';

                                                            return ["x", outputArr,
                                                            // head
                                                            _graphUtil.GraphUtils.adjMatrix_ForceLayout_GLSLFunctionString(geometryLength, efferentStart, efferentNodesCount),

                                                            // source
                                                            "float nodeId = data[x].x;\n                    float numOfConnections = data[x].y;\n                    vec2 xGeometry = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n                    vec3 currentPos = posXYZW[xGeometry].xyz;\n                    vec3 currentDir = dir[xGeometry].xyz;\n\n\n                    vec4 currentDataB = dataB[xGeometry];\n                    vec4 currentDataF = dataF[xGeometry];\n                    vec4 currentDataG = dataG[xGeometry];\n                    vec4 currentDataH = dataH[xGeometry];\n\n                    currentDir = vec3(0.0, 0.0, 0.0);\n\n                    idAdjMatrixResponse adjM = idAdjMatrix_ForceLayout(nodeId, currentPos, currentDir, numOfConnections);\n                    currentDir += adjM.force;\n\n                    if(currentTrainLayer == -3.0) {\n                        currentDataB = vec4(currentDataB.x, currentDataB.y, adjM.netFOutputA, adjM.netErrorWeightA);\n                        currentDataF = vec4(adjM.netFOutputB, adjM.netErrorWeightB, adjM.netFOutputC, adjM.netErrorWeightC);\n                        currentDataG = vec4(adjM.netFOutputD, adjM.netErrorWeightD, adjM.netFOutputE, adjM.netErrorWeightE);\n                        currentDataH = vec4(adjM.netFOutputF, adjM.netErrorWeightF, adjM.netFOutputG, adjM.netErrorWeightG);\n                    }\n\n                    " + (customCode !== undefined ? customCode : '') + "\n\n                    if(enableDrag == 1.0) {\n                        if(nodeId == idToDrag) {\n                            currentPos = vec3(MouseDragTranslationX, MouseDragTranslationY, MouseDragTranslationZ);\n                        }\n                    }\n\n                    currentPos += currentDir;\n                    if(only2d == 1.0) {\n                        currentPos.y = 0.0;\n                    }\n\n                    " + returnStr];
                                        }
                    }]);

                    return KERNEL_DIR;
}();

global.KERNEL_DIR = KERNEL_DIR;
module.exports.KERNEL_DIR = KERNEL_DIR;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./graphUtil":2}],2:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GraphUtils = exports.GraphUtils = function () {
    function GraphUtils() {
        _classCallCheck(this, GraphUtils);
    }

    _createClass(GraphUtils, null, [{
        key: 'adjMatrix_ForceLayout_GLSLFunctionString',
        value: function adjMatrix_ForceLayout_GLSLFunctionString(geometryLength, efferentStart, efferentNodesCount) {
            return '' + 'struct CalculationResponse {\n            vec3 atraction;\n            float acumAtraction;\n            vec3 repulsion;\n            \n            float netChildInputSumA;\n            float netParentErrorWeightA;\n            float netChildInputSumBiasA;\n            float netParentErrorBiasA;\n            \n            float netChildInputSumB;\n            float netParentErrorWeightB;\n            float netChildInputSumBiasB;\n            float netParentErrorBiasB;\n            \n            float netChildInputSumC;\n            float netParentErrorWeightC;\n            float netChildInputSumBiasC;\n            float netParentErrorBiasC;\n            \n            float netChildInputSumD;\n            float netParentErrorWeightD;\n            float netChildInputSumBiasD;\n            float netParentErrorBiasD;\n            \n            float netChildInputSumE;\n            float netParentErrorWeightE;\n            float netChildInputSumBiasE;\n            float netParentErrorBiasE;\n            \n            float netChildInputSumF;\n            float netParentErrorWeightF;\n            float netChildInputSumBiasF;\n            float netParentErrorBiasF;\n            \n            float netChildInputSumG;\n            float netParentErrorWeightG;\n            float netChildInputSumBiasG;\n            float netParentErrorBiasG;\n        };' + 'CalculationResponse calculate(float nodeId,\n                                        vec4 pixAdjMatACurrent, vec4 pixAdjMatAOpposite,\n                                        vec4 pixAdjMatBCurrent, vec4 pixAdjMatBOpposite,\n                                        vec2 xGeomCurrent, vec2 xGeomOpposite,\n                                        vec3 currentPos, vec3 currentDir,\n                                        vec3 atraction, float acumAtraction, vec3 repulsion,\n                                        float netChildInputSumA, float netParentErrorWeightA,float netChildInputSumBiasA, float netParentErrorBiasA,\n                                        float netChildInputSumB, float netParentErrorWeightB,float netChildInputSumBiasB, float netParentErrorBiasB,\n                                        float netChildInputSumC, float netParentErrorWeightC,float netChildInputSumBiasC, float netParentErrorBiasC,\n                                        float netChildInputSumD, float netParentErrorWeightD,float netChildInputSumBiasD, float netParentErrorBiasD,\n                                        float netChildInputSumE, float netParentErrorWeightE,float netChildInputSumBiasE, float netParentErrorBiasE,\n                                        float netChildInputSumF, float netParentErrorWeightF,float netChildInputSumBiasF, float netParentErrorBiasF,\n                                        float netChildInputSumG, float netParentErrorWeightG,float netChildInputSumBiasG, float netParentErrorBiasG) {' +
            // pixAdjMatACurrent
            'float currentWeight = pixAdjMatACurrent.z;\n            float currentIsParent = pixAdjMatACurrent.w;' +

            // pixAdjMatAOpposite
            'float oppositeWeight = pixAdjMatAOpposite.z;\n            float oppositeIsParent = pixAdjMatAOpposite.w;' +

            // pixAdjMatBCurrent
            'float currentLinkMultiplier = pixAdjMatBCurrent.x;\n            float currentActivationFn = pixAdjMatBCurrent.y;' +

            // pixAdjMatBOpposite
            'float oppositeLinkMultiplier = pixAdjMatBOpposite.x;\n            float oppositeActivationFn = pixAdjMatBOpposite.y;' +

            // dataB Current
            //'float currentBiasNode = dataB[xGeomCurrent].x;'+
            //'float currentNetOutput = dataB[xGeomCurrent].z;'+
            //'float currentNetError = dataB[xGeomCurrent].w;'+

            // dataB Opposite
            'float oppositeBiasNode = dataB[xGeomOpposite].x;\n            float oppositeNetOutputA = dataB[xGeomOpposite].z;\n            float oppositeNetErrorA = dataB[xGeomOpposite].w;\n\n            float oppositeNetOutputB = dataF[xGeomOpposite].x;\n            float oppositeNetErrorB = dataF[xGeomOpposite].y;\n        \n            float oppositeNetOutputC = dataF[xGeomOpposite].z;\n            float oppositeNetErrorC = dataF[xGeomOpposite].w;\n        \n            float oppositeNetOutputD = dataG[xGeomOpposite].x;\n            float oppositeNetErrorD = dataG[xGeomOpposite].y;\n        \n            float oppositeNetOutputE = dataG[xGeomOpposite].z;\n            float oppositeNetErrorE = dataG[xGeomOpposite].w;\n        \n            float oppositeNetOutputF = dataH[xGeomOpposite].x;\n            float oppositeNetErrorF = dataH[xGeomOpposite].y;\n        \n            float oppositeNetOutputG = dataH[xGeomOpposite].z;\n            float oppositeNetErrorG = dataH[xGeomOpposite].w;' +

            // pos & dir Current
            //'vec3 currentPos = posXYZW[xGeomCurrent].xyz;\n'+
            //'vec3 currentDir = dir[xGeomCurrent].xyz;\n'+

            // pos & dir Opposite
            'vec3 oppositePos = posXYZW[xGeomOpposite].xyz;\n            vec3 oppositeDir = dir[xGeomOpposite].xyz;' +

            // dir / dist to opposite
            'vec3 dirToOpposite = (oppositePos-currentPos);\n' + 'vec3 dirToOppositeN = normalize(dirToOpposite);\n' + 'float dist = distance(oppositePos, currentPos);\n' + // near=0.0 ; far=1.0
            'float distN = max(0.0,dist)/100000.0;' + 'float mm = 30.0;' + 'float m1 = 400000.0/mm;' + 'float m2 = 48.0/mm;' + 'if(currentIsParent == 1.0) {' + 'netChildInputSumA += oppositeNetOutputA*oppositeWeight;' + 'netChildInputSumB += oppositeNetOutputB*oppositeWeight;' + 'netChildInputSumC += oppositeNetOutputC*oppositeWeight;' + 'netChildInputSumD += oppositeNetOutputD*oppositeWeight;' + 'netChildInputSumE += oppositeNetOutputE*oppositeWeight;' + 'netChildInputSumF += oppositeNetOutputF*oppositeWeight;' + 'netChildInputSumG += oppositeNetOutputG*oppositeWeight;' + 'netChildInputSumBiasA += oppositeWeight;' + 'netChildInputSumBiasB += oppositeWeight;' + 'netChildInputSumBiasC += oppositeWeight;' + 'netChildInputSumBiasD += oppositeWeight;' + 'netChildInputSumBiasE += oppositeWeight;' + 'netChildInputSumBiasF += oppositeWeight;' + 'netChildInputSumBiasG += oppositeWeight;' + 'atraction += dirToOppositeN*max(1.0, distN*abs(oppositeWeight)*(m1/2.0));\n' + 'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(oppositeWeight)*(m2/2.0));\n' + 'acumAtraction += 1.0;\n' + '} else if(currentIsParent == 0.5) {' + 'netParentErrorWeightA += oppositeNetErrorA*currentWeight;' + 'netParentErrorWeightB += oppositeNetErrorB*currentWeight;' + 'netParentErrorWeightC += oppositeNetErrorC*currentWeight;' + 'netParentErrorWeightD += oppositeNetErrorD*currentWeight;' + 'netParentErrorWeightE += oppositeNetErrorE*currentWeight;' + 'netParentErrorWeightF += oppositeNetErrorF*currentWeight;' + 'netParentErrorWeightG += oppositeNetErrorG*currentWeight;' + 'netParentErrorBiasA += oppositeNetErrorA;' + 'netParentErrorBiasB += oppositeNetErrorB;' + 'netParentErrorBiasC += oppositeNetErrorC;' + 'netParentErrorBiasD += oppositeNetErrorD;' + 'netParentErrorBiasE += oppositeNetErrorE;' + 'netParentErrorBiasF += oppositeNetErrorF;' + 'netParentErrorBiasG += oppositeNetErrorG;' + 'atraction += dirToOppositeN*max(1.0, distN*abs(currentWeight)*m1);\n' + 'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*m2);\n' + 'acumAtraction += 1.0;\n' + '}' + 'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*(m2/8.0));\n' + 'acumAtraction += 1.0;\n' + ('return CalculationResponse(atraction, acumAtraction, repulsion,\n                                        netChildInputSumA, netParentErrorWeightA, netChildInputSumBiasA, netParentErrorBiasA,\n                                        netChildInputSumB, netParentErrorWeightB, netChildInputSumBiasB, netParentErrorBiasB,\n                                        netChildInputSumC, netParentErrorWeightC, netChildInputSumBiasC, netParentErrorBiasC,\n                                        netChildInputSumD, netParentErrorWeightD, netChildInputSumBiasD, netParentErrorBiasD,\n                                        netChildInputSumE, netParentErrorWeightE, netChildInputSumBiasE, netParentErrorBiasE,\n                                        netChildInputSumF, netParentErrorWeightF, netChildInputSumBiasF, netParentErrorBiasF,\n                                        netChildInputSumG, netParentErrorWeightG, netChildInputSumBiasG, netParentErrorBiasG);\n        }\n        struct idAdjMatrixResponse {\n            vec3 force;\n            float netFOutputA;\n            float netErrorWeightA;\n            float netFOutputB;\n            float netErrorWeightB;\n            float netFOutputC;\n            float netErrorWeightC;\n            float netFOutputD;\n            float netErrorWeightD;\n            float netFOutputE;\n            float netErrorWeightE;\n            float netFOutputF;\n            float netErrorWeightF;\n            float netFOutputG;\n            float netErrorWeightG;\n        };\n        float tanh(float val) {\n            float tmp = exp(val);\n            float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n            return tanH;\n        }\n        float sigm(float val) {\n            return (1.0 / (1.0 + exp(-val)));\n        }\n        idAdjMatrixResponse idAdjMatrix_ForceLayout(float nodeId, vec3 currentPos, vec3 currentDir, float numOfConnections) {\n            vec3 atraction = vec3(0.0, 0.0, 0.0);\n            float acumAtraction = 1.0;\n            vec3 repulsion = vec3(0.0, 0.0, 0.0);\n\n            vec3 force = vec3(0.0, 0.0, 0.0);\n\n\n            float netChildInputSumA = 0.0;\n            float foutputA = 0.0;\n            float netParentErrorWeightA = 0.0;\n            float netChildInputSumBiasA = 0.0;\n            float netParentErrorBiasA = 0.0;\n            \n            float netChildInputSumB = 0.0;\n            float foutputB = 0.0;\n            float netParentErrorWeightB = 0.0;\n            float netChildInputSumBiasB = 0.0;\n            float netParentErrorBiasB = 0.0;\n            \n            float netChildInputSumC = 0.0;\n            float foutputC = 0.0;\n            float netParentErrorWeightC = 0.0;\n            float netChildInputSumBiasC = 0.0;\n            float netParentErrorBiasC = 0.0;\n            \n            float netChildInputSumD = 0.0;\n            float foutputD = 0.0;\n            float netParentErrorWeightD = 0.0;\n            float netChildInputSumBiasD = 0.0;\n            float netParentErrorBiasD = 0.0;\n            \n            float netChildInputSumE = 0.0;\n            float foutputE = 0.0;\n            float netParentErrorWeightE = 0.0;\n            float netChildInputSumBiasE = 0.0;\n            float netParentErrorBiasE = 0.0;\n            \n            float netChildInputSumF = 0.0;\n            float foutputF = 0.0;\n            float netParentErrorWeightF = 0.0;\n            float netChildInputSumBiasF = 0.0;\n            float netParentErrorBiasF = 0.0;\n            \n            float netChildInputSumG = 0.0;\n            float foutputG = 0.0;\n            float netParentErrorWeightG = 0.0;\n            float netChildInputSumBiasG = 0.0;\n            float netParentErrorBiasG = 0.0;\n            \n\n            if(nodeId < nodesCount) {\n                float currentActivationFn = 0.0;\n                vec2 xGeomCurrent = get_global_id(nodeId, uBufferWidth, ' + geometryLength.toFixed(1) + ');\n                for(int n=0; n < 4096; n++) {\n                    if(float(n) >= nodesCount) {break;}\n                    if(float(n) != nodeId) {\n                        vec2 xGeomOpposite = get_global_id(float(n), uBufferWidth, ' + geometryLength.toFixed(1) + ');\n\n\n                        vec2 xAdjMatCurrent = get_global_id(vec2(float(n), nodeId), widthAdjMatrix);\n                        vec2 xAdjMatOpposite = get_global_id(vec2(nodeId, float(n)), widthAdjMatrix);\n\n                        vec4 pixAdjMatACurrent = adjacencyMatrix[xAdjMatCurrent];\n                        vec4 pixAdjMatAOpposite = adjacencyMatrix[xAdjMatOpposite];\n\n                        vec4 pixAdjMatBCurrent = adjacencyMatrixB[xAdjMatCurrent];\n                        vec4 pixAdjMatBOpposite = adjacencyMatrixB[xAdjMatOpposite];\n\n\n                        CalculationResponse calcResponse = calculate(nodeId,\n                                                                    pixAdjMatACurrent, pixAdjMatAOpposite,\n                                                                    pixAdjMatBCurrent, pixAdjMatBOpposite,\n                                                                    xGeomCurrent, xGeomOpposite,\n                                                                    currentPos, currentDir,\n                                                                    atraction, acumAtraction, repulsion,\n                                                                    netChildInputSumA, netParentErrorWeightA, netChildInputSumBiasA, netParentErrorBiasA,\n                                                                    netChildInputSumB, netParentErrorWeightB, netChildInputSumBiasB, netParentErrorBiasB,\n                                                                    netChildInputSumC, netParentErrorWeightC, netChildInputSumBiasC, netParentErrorBiasC,\n                                                                    netChildInputSumD, netParentErrorWeightD, netChildInputSumBiasD, netParentErrorBiasD,\n                                                                    netChildInputSumE, netParentErrorWeightE, netChildInputSumBiasE, netParentErrorBiasE,\n                                                                    netChildInputSumF, netParentErrorWeightF, netChildInputSumBiasF, netParentErrorBiasF,\n                                                                    netChildInputSumG, netParentErrorWeightG, netChildInputSumBiasG, netParentErrorBiasG);\n                        atraction = calcResponse.atraction;\n                        acumAtraction = calcResponse.acumAtraction;\n                        repulsion = calcResponse.repulsion;\n                        \n                        netChildInputSumA = calcResponse.netChildInputSumA;\n                        netParentErrorWeightA = calcResponse.netParentErrorWeightA;\n                        netChildInputSumBiasA = calcResponse.netChildInputSumBiasA;\n                        netParentErrorBiasA = calcResponse.netParentErrorBiasA;\n                        \n                        netChildInputSumB = calcResponse.netChildInputSumB;\n                        netParentErrorWeightB = calcResponse.netParentErrorWeightB;\n                        netChildInputSumBiasB = calcResponse.netChildInputSumBiasB;\n                        netParentErrorBiasB = calcResponse.netParentErrorBiasB;\n                        \n                        netChildInputSumC = calcResponse.netChildInputSumC;\n                        netParentErrorWeightC = calcResponse.netParentErrorWeightC;\n                        netChildInputSumBiasC = calcResponse.netChildInputSumBiasC;\n                        netParentErrorBiasC = calcResponse.netParentErrorBiasC;\n                        \n                        netChildInputSumD = calcResponse.netChildInputSumD;\n                        netParentErrorWeightD = calcResponse.netParentErrorWeightD;\n                        netChildInputSumBiasD = calcResponse.netChildInputSumBiasD;\n                        netParentErrorBiasD = calcResponse.netParentErrorBiasD;\n                        \n                        netChildInputSumE = calcResponse.netChildInputSumE;\n                        netParentErrorWeightE = calcResponse.netParentErrorWeightE;\n                        netChildInputSumBiasE = calcResponse.netChildInputSumBiasE;\n                        netParentErrorBiasE = calcResponse.netParentErrorBiasE;\n                        \n                        netChildInputSumF = calcResponse.netChildInputSumF;\n                        netParentErrorWeightF = calcResponse.netParentErrorWeightF;\n                        netChildInputSumBiasF = calcResponse.netChildInputSumBiasF;\n                        netParentErrorBiasF = calcResponse.netParentErrorBiasF;\n                        \n                        netChildInputSumG = calcResponse.netChildInputSumG;\n                        netParentErrorWeightG = calcResponse.netParentErrorWeightG;\n                        netChildInputSumBiasG = calcResponse.netChildInputSumBiasG;\n                        netParentErrorBiasG = calcResponse.netParentErrorBiasG;\n                    }\n                }\n                force += (atraction/acumAtraction);\n                force += (repulsion/acumAtraction);\n                \n                float currentBiasNode = dataB[xGeomCurrent].x;\n                \n                ' + GraphUtils.efferentNodesStr(efferentStart, efferentNodesCount) + '\n            }\n\n            return idAdjMatrixResponse(vec3(force),\n                                        foutputA, netParentErrorWeightA,\n                                        foutputB, netParentErrorWeightB,\n                                        foutputC, netParentErrorWeightC,\n                                        foutputD, netParentErrorWeightD,\n                                        foutputE, netParentErrorWeightE,\n                                        foutputF, netParentErrorWeightF,\n                                        foutputG, netParentErrorWeightG);\n        }');
        }
    }, {
        key: 'efferentNodesStr',
        value: function efferentNodesStr(efferentStart, efferentNodesCount) {
            /////////////////////////////////////////////////
            // OUTPUT
            /////////////////////////////////////////////////
            var str = '\n            if(nodeId < afferentNodesCount) {\n                for(float n=0.0; n < 1024.0; n+=1.0) {\n                    if(n >= afferentNodesCount) {\n                        break;\n                    }\n                    if(nodeId == n) {\n                        foutputA = afferentNodesA[int(n)];\n                        foutputB = afferentNodesB[int(n)];\n                        foutputC = afferentNodesC[int(n)];\n                        foutputD = afferentNodesD[int(n)];\n                        foutputE = afferentNodesE[int(n)];\n                        foutputF = afferentNodesF[int(n)];\n                        foutputG = afferentNodesG[int(n)];\n                        break;\n                    }\n                }\n            } else {\n                if(currentBiasNode == 0.0) {                \n                    foutputA = max(0.0, netChildInputSumA); ' + '\n                    foutputB = max(0.0, netChildInputSumB);\n                    foutputC = max(0.0, netChildInputSumC);\n                    foutputD = max(0.0, netChildInputSumD);\n                    foutputE = max(0.0, netChildInputSumE);\n                    foutputF = max(0.0, netChildInputSumF);\n                    foutputG = max(0.0, netChildInputSumG);\n                } else {\n                    foutputA = netChildInputSumA;\n                    foutputB = netChildInputSumB;\n                    foutputC = netChildInputSumC;\n                    foutputD = netChildInputSumD;\n                    foutputE = netChildInputSumE;\n                    foutputF = netChildInputSumF;\n                    foutputG = netChildInputSumG;\n                }\n            }';

            /////////////////////////////////////////////////
            // ERROR
            /////////////////////////////////////////////////
            str += '\n        if(nodeId == ' + efferentStart.toFixed(1) + (') {\n            netParentErrorWeightA = (efferentNodesA[0] != 0.0) ? netChildInputSumA-efferentNodesA[0] : 0.0;\n            netParentErrorWeightB = (efferentNodesB[0] != 0.0) ? netChildInputSumB-efferentNodesB[0] : 0.0;\n            netParentErrorWeightC = (efferentNodesC[0] != 0.0) ? netChildInputSumC-efferentNodesC[0] : 0.0;\n            netParentErrorWeightD = (efferentNodesD[0] != 0.0) ? netChildInputSumD-efferentNodesD[0] : 0.0;\n            netParentErrorWeightE = (efferentNodesE[0] != 0.0) ? netChildInputSumE-efferentNodesE[0] : 0.0;\n            netParentErrorWeightF = (efferentNodesF[0] != 0.0) ? netChildInputSumF-efferentNodesF[0] : 0.0;\n            netParentErrorWeightG = (efferentNodesG[0] != 0.0) ? netChildInputSumG-efferentNodesG[0] : 0.0;\n            ' + '\n            ' + '\n            ' + '\n            ' + '\n            ' + '\n            ' + '\n            ' + '\n        }');
            for (var n = efferentStart + 1; n < efferentStart + efferentNodesCount; n++) {
                str += '\n            else if(nodeId == ' + n.toFixed(1) + ') {\n                netParentErrorWeightA = (efferentNodesA[' + Math.round(n - efferentStart) + '] != 0.0) ? netChildInputSumA-efferentNodesA[' + Math.round(n - efferentStart) + '] : 0.0;\n                netParentErrorWeightB = (efferentNodesB[' + Math.round(n - efferentStart) + '] != 0.0) ? netChildInputSumB-efferentNodesB[' + Math.round(n - efferentStart) + '] : 0.0;\n                netParentErrorWeightC = (efferentNodesC[' + Math.round(n - efferentStart) + '] != 0.0) ? netChildInputSumC-efferentNodesC[' + Math.round(n - efferentStart) + '] : 0.0;\n                netParentErrorWeightD = (efferentNodesD[' + Math.round(n - efferentStart) + '] != 0.0) ? netChildInputSumD-efferentNodesD[' + Math.round(n - efferentStart) + '] : 0.0;\n                netParentErrorWeightE = (efferentNodesE[' + Math.round(n - efferentStart) + '] != 0.0) ? netChildInputSumE-efferentNodesE[' + Math.round(n - efferentStart) + '] : 0.0;\n                netParentErrorWeightF = (efferentNodesF[' + Math.round(n - efferentStart) + '] != 0.0) ? netChildInputSumF-efferentNodesF[' + Math.round(n - efferentStart) + '] : 0.0;\n                netParentErrorWeightG = (efferentNodesG[' + Math.round(n - efferentStart) + '] != 0.0) ? netChildInputSumG-efferentNodesG[' + Math.round(n - efferentStart) + ('] : 0.0;\n                ' + '\n                ' + '\n                ' + '\n                ' + '\n                ' + '\n                ' + '\n                ' + '\n            }');
            }str += '\n        else {\n            if(currentBiasNode == 0.0) {\n                if(foutputA <= 0.0) {\n                    netParentErrorWeightA = 0.0;\n                }\n                if(foutputB <= 0.0) {\n                    netParentErrorWeightB = 0.0;\n                }\n                if(foutputC <= 0.0) {\n                    netParentErrorWeightC = 0.0;\n                }\n                if(foutputD <= 0.0) {\n                    netParentErrorWeightD = 0.0;\n                }\n                if(foutputE <= 0.0) {\n                    netParentErrorWeightE = 0.0;\n                }\n                if(foutputF <= 0.0) {\n                    netParentErrorWeightF = 0.0;\n                }\n                if(foutputG <= 0.0) {\n                    netParentErrorWeightG = 0.0;\n                }\n            } else {\n                netParentErrorWeightA = netParentErrorBiasA;\n                netParentErrorWeightB = netParentErrorBiasB;\n                netParentErrorWeightC = netParentErrorBiasC;\n                netParentErrorWeightD = netParentErrorBiasD;\n                netParentErrorWeightE = netParentErrorBiasE;\n                netParentErrorWeightF = netParentErrorBiasF;\n                netParentErrorWeightG = netParentErrorBiasG;\n            }\n        }';

            return str;
        }
    }]);

    return GraphUtils;
}();

global.GraphUtils = GraphUtils;
module.exports.GraphUtils = GraphUtils;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZ2JyYWluL0tFUk5FTF9ESVIuY2xhc3MuanMiLCJzcmMvZ2JyYWluL2dyYXBoVXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5LRVJORUxfRElSID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dyYXBoVXRpbCA9IHJlcXVpcmUoXCIuL2dyYXBoVXRpbFwiKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEtFUk5FTF9ESVIgPSBleHBvcnRzLktFUk5FTF9ESVIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEtFUk5FTF9ESVIoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtFUk5FTF9ESVIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEtFUk5FTF9ESVIsIG51bGwsIFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcImdldFNyY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTcmMoY3VzdG9tQ29kZSwgZ2VvbWV0cnlMZW5ndGgsIGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dEFyciA9IFtcImRpclwiLCBcInBvc1hZWldcIiwgXCJkYXRhQlwiLCBcImRhdGFGXCIsIFwiZGF0YUdcIiwgXCJkYXRhSFwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5TdHIgPSAncmV0dXJuIFt2ZWM0KGN1cnJlbnREaXIsIDEuMCksIHZlYzQoY3VycmVudFBvcy54LCBjdXJyZW50UG9zLnksIGN1cnJlbnRQb3MueiwgMS4wKSwgY3VycmVudERhdGFCLCBjdXJyZW50RGF0YUYsIGN1cnJlbnREYXRhRywgY3VycmVudERhdGFIXTsnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wieFwiLCBvdXRwdXRBcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ3JhcGhVdGlsLkdyYXBoVXRpbHMuYWRqTWF0cml4X0ZvcmNlTGF5b3V0X0dMU0xGdW5jdGlvblN0cmluZyhnZW9tZXRyeUxlbmd0aCwgZWZmZXJlbnRTdGFydCwgZWZmZXJlbnROb2Rlc0NvdW50KSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsb2F0IG5vZGVJZCA9IGRhdGFbeF0ueDtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG51bU9mQ29ubmVjdGlvbnMgPSBkYXRhW3hdLnk7XFxuICAgICAgICAgICAgICAgICAgICB2ZWMyIHhHZW9tZXRyeSA9IGdldF9nbG9iYWxfaWQobm9kZUlkLCB1QnVmZmVyV2lkdGgsIFwiICsgZ2VvbWV0cnlMZW5ndGgudG9GaXhlZCgxKSArIFwiKTtcXG5cXG5cXG4gICAgICAgICAgICAgICAgICAgIHZlYzMgY3VycmVudFBvcyA9IHBvc1hZWldbeEdlb21ldHJ5XS54eXo7XFxuICAgICAgICAgICAgICAgICAgICB2ZWMzIGN1cnJlbnREaXIgPSBkaXJbeEdlb21ldHJ5XS54eXo7XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGN1cnJlbnREYXRhQiA9IGRhdGFCW3hHZW9tZXRyeV07XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGN1cnJlbnREYXRhRiA9IGRhdGFGW3hHZW9tZXRyeV07XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGN1cnJlbnREYXRhRyA9IGRhdGFHW3hHZW9tZXRyeV07XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGN1cnJlbnREYXRhSCA9IGRhdGFIW3hHZW9tZXRyeV07XFxuXFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGlyID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGlkQWRqTWF0cml4UmVzcG9uc2UgYWRqTSA9IGlkQWRqTWF0cml4X0ZvcmNlTGF5b3V0KG5vZGVJZCwgY3VycmVudFBvcywgY3VycmVudERpciwgbnVtT2ZDb25uZWN0aW9ucyk7XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGlyICs9IGFkak0uZm9yY2U7XFxuXFxuICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VHJhaW5MYXllciA9PSAtMy4wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERhdGFCID0gdmVjNChjdXJyZW50RGF0YUIueCwgY3VycmVudERhdGFCLnksIGFkak0ubmV0Rk91dHB1dEEsIGFkak0ubmV0RXJyb3JXZWlnaHRBKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0YUYgPSB2ZWM0KGFkak0ubmV0Rk91dHB1dEIsIGFkak0ubmV0RXJyb3JXZWlnaHRCLCBhZGpNLm5ldEZPdXRwdXRDLCBhZGpNLm5ldEVycm9yV2VpZ2h0Qyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERhdGFHID0gdmVjNChhZGpNLm5ldEZPdXRwdXRELCBhZGpNLm5ldEVycm9yV2VpZ2h0RCwgYWRqTS5uZXRGT3V0cHV0RSwgYWRqTS5uZXRFcnJvcldlaWdodEUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREYXRhSCA9IHZlYzQoYWRqTS5uZXRGT3V0cHV0RiwgYWRqTS5uZXRFcnJvcldlaWdodEYsIGFkak0ubmV0Rk91dHB1dEcsIGFkak0ubmV0RXJyb3JXZWlnaHRHKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIFwiICsgKGN1c3RvbUNvZGUgIT09IHVuZGVmaW5lZCA/IGN1c3RvbUNvZGUgOiAnJykgKyBcIlxcblxcbiAgICAgICAgICAgICAgICAgICAgaWYoZW5hYmxlRHJhZyA9PSAxLjApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihub2RlSWQgPT0gaWRUb0RyYWcpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IHZlYzMoTW91c2VEcmFnVHJhbnNsYXRpb25YLCBNb3VzZURyYWdUcmFuc2xhdGlvblksIE1vdXNlRHJhZ1RyYW5zbGF0aW9uWik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcyArPSBjdXJyZW50RGlyO1xcbiAgICAgICAgICAgICAgICAgICAgaWYob25seTJkID09IDEuMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MueSA9IDAuMDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIFwiICsgcmV0dXJuU3RyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gS0VSTkVMX0RJUjtcbn0oKTtcblxuZ2xvYmFsLktFUk5FTF9ESVIgPSBLRVJORUxfRElSO1xubW9kdWxlLmV4cG9ydHMuS0VSTkVMX0RJUiA9IEtFUk5FTF9ESVI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBHcmFwaFV0aWxzID0gZXhwb3J0cy5HcmFwaFV0aWxzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyYXBoVXRpbHMoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmFwaFV0aWxzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoR3JhcGhVdGlscywgbnVsbCwgW3tcbiAgICAgICAga2V5OiAnYWRqTWF0cml4X0ZvcmNlTGF5b3V0X0dMU0xGdW5jdGlvblN0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGpNYXRyaXhfRm9yY2VMYXlvdXRfR0xTTEZ1bmN0aW9uU3RyaW5nKGdlb21ldHJ5TGVuZ3RoLCBlZmZlcmVudFN0YXJ0LCBlZmZlcmVudE5vZGVzQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArICdzdHJ1Y3QgQ2FsY3VsYXRpb25SZXNwb25zZSB7XFxuICAgICAgICAgICAgdmVjMyBhdHJhY3Rpb247XFxuICAgICAgICAgICAgZmxvYXQgYWN1bUF0cmFjdGlvbjtcXG4gICAgICAgICAgICB2ZWMzIHJlcHVsc2lvbjtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEE7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUJpYXNBO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yQmlhc0E7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUI7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRCO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CaWFzQjtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvckJpYXNCO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1DO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QztcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQmlhc0M7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JCaWFzQztcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEQ7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUJpYXNEO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yQmlhc0Q7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUU7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRFO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CaWFzRTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvckJpYXNFO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1GO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RjtcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQmlhc0Y7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JCaWFzRjtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRztcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEc7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUJpYXNHO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yQmlhc0c7XFxuICAgICAgICB9OycgKyAnQ2FsY3VsYXRpb25SZXNwb25zZSBjYWxjdWxhdGUoZmxvYXQgbm9kZUlkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEFDdXJyZW50LCB2ZWM0IHBpeEFkak1hdEFPcHBvc2l0ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRCQ3VycmVudCwgdmVjNCBwaXhBZGpNYXRCT3Bwb3NpdGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIgeEdlb21DdXJyZW50LCB2ZWMyIHhHZW9tT3Bwb3NpdGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgY3VycmVudFBvcywgdmVjMyBjdXJyZW50RGlyLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzIGF0cmFjdGlvbiwgZmxvYXQgYWN1bUF0cmFjdGlvbiwgdmVjMyByZXB1bHNpb24sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1BLCBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEEsZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUJpYXNBLCBmbG9hdCBuZXRQYXJlbnRFcnJvckJpYXNBLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQiwgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRCLGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CaWFzQiwgZmxvYXQgbmV0UGFyZW50RXJyb3JCaWFzQixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUMsIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QyxmbG9hdCBuZXRDaGlsZElucHV0U3VtQmlhc0MsIGZsb2F0IG5ldFBhcmVudEVycm9yQmlhc0MsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1ELCBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEQsZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUJpYXNELCBmbG9hdCBuZXRQYXJlbnRFcnJvckJpYXNELFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRSwgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRFLGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CaWFzRSwgZmxvYXQgbmV0UGFyZW50RXJyb3JCaWFzRSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUYsIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RixmbG9hdCBuZXRDaGlsZElucHV0U3VtQmlhc0YsIGZsb2F0IG5ldFBhcmVudEVycm9yQmlhc0YsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1HLCBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEcsZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUJpYXNHLCBmbG9hdCBuZXRQYXJlbnRFcnJvckJpYXNHKSB7JyArXG4gICAgICAgICAgICAvLyBwaXhBZGpNYXRBQ3VycmVudFxuICAgICAgICAgICAgJ2Zsb2F0IGN1cnJlbnRXZWlnaHQgPSBwaXhBZGpNYXRBQ3VycmVudC56O1xcbiAgICAgICAgICAgIGZsb2F0IGN1cnJlbnRJc1BhcmVudCA9IHBpeEFkak1hdEFDdXJyZW50Lnc7JyArXG5cbiAgICAgICAgICAgIC8vIHBpeEFkak1hdEFPcHBvc2l0ZVxuICAgICAgICAgICAgJ2Zsb2F0IG9wcG9zaXRlV2VpZ2h0ID0gcGl4QWRqTWF0QU9wcG9zaXRlLno7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVJc1BhcmVudCA9IHBpeEFkak1hdEFPcHBvc2l0ZS53OycgK1xuXG4gICAgICAgICAgICAvLyBwaXhBZGpNYXRCQ3VycmVudFxuICAgICAgICAgICAgJ2Zsb2F0IGN1cnJlbnRMaW5rTXVsdGlwbGllciA9IHBpeEFkak1hdEJDdXJyZW50Lng7XFxuICAgICAgICAgICAgZmxvYXQgY3VycmVudEFjdGl2YXRpb25GbiA9IHBpeEFkak1hdEJDdXJyZW50Lnk7JyArXG5cbiAgICAgICAgICAgIC8vIHBpeEFkak1hdEJPcHBvc2l0ZVxuICAgICAgICAgICAgJ2Zsb2F0IG9wcG9zaXRlTGlua011bHRpcGxpZXIgPSBwaXhBZGpNYXRCT3Bwb3NpdGUueDtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUFjdGl2YXRpb25GbiA9IHBpeEFkak1hdEJPcHBvc2l0ZS55OycgK1xuXG4gICAgICAgICAgICAvLyBkYXRhQiBDdXJyZW50XG4gICAgICAgICAgICAvLydmbG9hdCBjdXJyZW50Qmlhc05vZGUgPSBkYXRhQlt4R2VvbUN1cnJlbnRdLng7JytcbiAgICAgICAgICAgIC8vJ2Zsb2F0IGN1cnJlbnROZXRPdXRwdXQgPSBkYXRhQlt4R2VvbUN1cnJlbnRdLno7JytcbiAgICAgICAgICAgIC8vJ2Zsb2F0IGN1cnJlbnROZXRFcnJvciA9IGRhdGFCW3hHZW9tQ3VycmVudF0udzsnK1xuXG4gICAgICAgICAgICAvLyBkYXRhQiBPcHBvc2l0ZVxuICAgICAgICAgICAgJ2Zsb2F0IG9wcG9zaXRlQmlhc05vZGUgPSBkYXRhQlt4R2VvbU9wcG9zaXRlXS54O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0QSA9IGRhdGFCW3hHZW9tT3Bwb3NpdGVdLno7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckEgPSBkYXRhQlt4R2VvbU9wcG9zaXRlXS53O1xcblxcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0QiA9IGRhdGFGW3hHZW9tT3Bwb3NpdGVdLng7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckIgPSBkYXRhRlt4R2VvbU9wcG9zaXRlXS55O1xcbiAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRDID0gZGF0YUZbeEdlb21PcHBvc2l0ZV0uejtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yQyA9IGRhdGFGW3hHZW9tT3Bwb3NpdGVdLnc7XFxuICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEQgPSBkYXRhR1t4R2VvbU9wcG9zaXRlXS54O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0RXJyb3JEID0gZGF0YUdbeEdlb21PcHBvc2l0ZV0ueTtcXG4gICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0RSA9IGRhdGFHW3hHZW9tT3Bwb3NpdGVdLno7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckUgPSBkYXRhR1t4R2VvbU9wcG9zaXRlXS53O1xcbiAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRGID0gZGF0YUhbeEdlb21PcHBvc2l0ZV0ueDtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yRiA9IGRhdGFIW3hHZW9tT3Bwb3NpdGVdLnk7XFxuICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEcgPSBkYXRhSFt4R2VvbU9wcG9zaXRlXS56O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0RXJyb3JHID0gZGF0YUhbeEdlb21PcHBvc2l0ZV0udzsnICtcblxuICAgICAgICAgICAgLy8gcG9zICYgZGlyIEN1cnJlbnRcbiAgICAgICAgICAgIC8vJ3ZlYzMgY3VycmVudFBvcyA9IHBvc1hZWldbeEdlb21DdXJyZW50XS54eXo7XFxuJytcbiAgICAgICAgICAgIC8vJ3ZlYzMgY3VycmVudERpciA9IGRpclt4R2VvbUN1cnJlbnRdLnh5ejtcXG4nK1xuXG4gICAgICAgICAgICAvLyBwb3MgJiBkaXIgT3Bwb3NpdGVcbiAgICAgICAgICAgICd2ZWMzIG9wcG9zaXRlUG9zID0gcG9zWFlaV1t4R2VvbU9wcG9zaXRlXS54eXo7XFxuICAgICAgICAgICAgdmVjMyBvcHBvc2l0ZURpciA9IGRpclt4R2VvbU9wcG9zaXRlXS54eXo7JyArXG5cbiAgICAgICAgICAgIC8vIGRpciAvIGRpc3QgdG8gb3Bwb3NpdGVcbiAgICAgICAgICAgICd2ZWMzIGRpclRvT3Bwb3NpdGUgPSAob3Bwb3NpdGVQb3MtY3VycmVudFBvcyk7XFxuJyArICd2ZWMzIGRpclRvT3Bwb3NpdGVOID0gbm9ybWFsaXplKGRpclRvT3Bwb3NpdGUpO1xcbicgKyAnZmxvYXQgZGlzdCA9IGRpc3RhbmNlKG9wcG9zaXRlUG9zLCBjdXJyZW50UG9zKTtcXG4nICsgLy8gbmVhcj0wLjAgOyBmYXI9MS4wXG4gICAgICAgICAgICAnZmxvYXQgZGlzdE4gPSBtYXgoMC4wLGRpc3QpLzEwMDAwMC4wOycgKyAnZmxvYXQgbW0gPSAzMC4wOycgKyAnZmxvYXQgbTEgPSA0MDAwMDAuMC9tbTsnICsgJ2Zsb2F0IG0yID0gNDguMC9tbTsnICsgJ2lmKGN1cnJlbnRJc1BhcmVudCA9PSAxLjApIHsnICsgJ25ldENoaWxkSW5wdXRTdW1BICs9IG9wcG9zaXRlTmV0T3V0cHV0QSpvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1CICs9IG9wcG9zaXRlTmV0T3V0cHV0QipvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1DICs9IG9wcG9zaXRlTmV0T3V0cHV0QypvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1EICs9IG9wcG9zaXRlTmV0T3V0cHV0RCpvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1FICs9IG9wcG9zaXRlTmV0T3V0cHV0RSpvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1GICs9IG9wcG9zaXRlTmV0T3V0cHV0RipvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1HICs9IG9wcG9zaXRlTmV0T3V0cHV0RypvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1CaWFzQSArPSBvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1CaWFzQiArPSBvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1CaWFzQyArPSBvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1CaWFzRCArPSBvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1CaWFzRSArPSBvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1CaWFzRiArPSBvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1CaWFzRyArPSBvcHBvc2l0ZVdlaWdodDsnICsgJ2F0cmFjdGlvbiArPSBkaXJUb09wcG9zaXRlTiptYXgoMS4wLCBkaXN0TiphYnMob3Bwb3NpdGVXZWlnaHQpKihtMS8yLjApKTtcXG4nICsgJ3JlcHVsc2lvbiArPSAtZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgKDEuMC1kaXN0TikqYWJzKG9wcG9zaXRlV2VpZ2h0KSoobTIvMi4wKSk7XFxuJyArICdhY3VtQXRyYWN0aW9uICs9IDEuMDtcXG4nICsgJ30gZWxzZSBpZihjdXJyZW50SXNQYXJlbnQgPT0gMC41KSB7JyArICduZXRQYXJlbnRFcnJvcldlaWdodEEgKz0gb3Bwb3NpdGVOZXRFcnJvckEqY3VycmVudFdlaWdodDsnICsgJ25ldFBhcmVudEVycm9yV2VpZ2h0QiArPSBvcHBvc2l0ZU5ldEVycm9yQipjdXJyZW50V2VpZ2h0OycgKyAnbmV0UGFyZW50RXJyb3JXZWlnaHRDICs9IG9wcG9zaXRlTmV0RXJyb3JDKmN1cnJlbnRXZWlnaHQ7JyArICduZXRQYXJlbnRFcnJvcldlaWdodEQgKz0gb3Bwb3NpdGVOZXRFcnJvckQqY3VycmVudFdlaWdodDsnICsgJ25ldFBhcmVudEVycm9yV2VpZ2h0RSArPSBvcHBvc2l0ZU5ldEVycm9yRSpjdXJyZW50V2VpZ2h0OycgKyAnbmV0UGFyZW50RXJyb3JXZWlnaHRGICs9IG9wcG9zaXRlTmV0RXJyb3JGKmN1cnJlbnRXZWlnaHQ7JyArICduZXRQYXJlbnRFcnJvcldlaWdodEcgKz0gb3Bwb3NpdGVOZXRFcnJvckcqY3VycmVudFdlaWdodDsnICsgJ25ldFBhcmVudEVycm9yQmlhc0EgKz0gb3Bwb3NpdGVOZXRFcnJvckE7JyArICduZXRQYXJlbnRFcnJvckJpYXNCICs9IG9wcG9zaXRlTmV0RXJyb3JCOycgKyAnbmV0UGFyZW50RXJyb3JCaWFzQyArPSBvcHBvc2l0ZU5ldEVycm9yQzsnICsgJ25ldFBhcmVudEVycm9yQmlhc0QgKz0gb3Bwb3NpdGVOZXRFcnJvckQ7JyArICduZXRQYXJlbnRFcnJvckJpYXNFICs9IG9wcG9zaXRlTmV0RXJyb3JFOycgKyAnbmV0UGFyZW50RXJyb3JCaWFzRiArPSBvcHBvc2l0ZU5ldEVycm9yRjsnICsgJ25ldFBhcmVudEVycm9yQmlhc0cgKz0gb3Bwb3NpdGVOZXRFcnJvckc7JyArICdhdHJhY3Rpb24gKz0gZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgZGlzdE4qYWJzKGN1cnJlbnRXZWlnaHQpKm0xKTtcXG4nICsgJ3JlcHVsc2lvbiArPSAtZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgKDEuMC1kaXN0TikqYWJzKGN1cnJlbnRXZWlnaHQpKm0yKTtcXG4nICsgJ2FjdW1BdHJhY3Rpb24gKz0gMS4wO1xcbicgKyAnfScgKyAncmVwdWxzaW9uICs9IC1kaXJUb09wcG9zaXRlTiptYXgoMS4wLCAoMS4wLWRpc3ROKSphYnMoY3VycmVudFdlaWdodCkqKG0yLzguMCkpO1xcbicgKyAnYWN1bUF0cmFjdGlvbiArPSAxLjA7XFxuJyArICgncmV0dXJuIENhbGN1bGF0aW9uUmVzcG9uc2UoYXRyYWN0aW9uLCBhY3VtQXRyYWN0aW9uLCByZXB1bHNpb24sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1BLCBuZXRQYXJlbnRFcnJvcldlaWdodEEsIG5ldENoaWxkSW5wdXRTdW1CaWFzQSwgbmV0UGFyZW50RXJyb3JCaWFzQSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUIsIG5ldFBhcmVudEVycm9yV2VpZ2h0QiwgbmV0Q2hpbGRJbnB1dFN1bUJpYXNCLCBuZXRQYXJlbnRFcnJvckJpYXNCLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQywgbmV0UGFyZW50RXJyb3JXZWlnaHRDLCBuZXRDaGlsZElucHV0U3VtQmlhc0MsIG5ldFBhcmVudEVycm9yQmlhc0MsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1ELCBuZXRQYXJlbnRFcnJvcldlaWdodEQsIG5ldENoaWxkSW5wdXRTdW1CaWFzRCwgbmV0UGFyZW50RXJyb3JCaWFzRCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUUsIG5ldFBhcmVudEVycm9yV2VpZ2h0RSwgbmV0Q2hpbGRJbnB1dFN1bUJpYXNFLCBuZXRQYXJlbnRFcnJvckJpYXNFLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRiwgbmV0UGFyZW50RXJyb3JXZWlnaHRGLCBuZXRDaGlsZElucHV0U3VtQmlhc0YsIG5ldFBhcmVudEVycm9yQmlhc0YsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1HLCBuZXRQYXJlbnRFcnJvcldlaWdodEcsIG5ldENoaWxkSW5wdXRTdW1CaWFzRywgbmV0UGFyZW50RXJyb3JCaWFzRyk7XFxuICAgICAgICB9XFxuICAgICAgICBzdHJ1Y3QgaWRBZGpNYXRyaXhSZXNwb25zZSB7XFxuICAgICAgICAgICAgdmVjMyBmb3JjZTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRGT3V0cHV0QTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRFcnJvcldlaWdodEE7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Rk91dHB1dEI7XFxuICAgICAgICAgICAgZmxvYXQgbmV0RXJyb3JXZWlnaHRCO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEZPdXRwdXRDO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEVycm9yV2VpZ2h0QztcXG4gICAgICAgICAgICBmbG9hdCBuZXRGT3V0cHV0RDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRFcnJvcldlaWdodEQ7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Rk91dHB1dEU7XFxuICAgICAgICAgICAgZmxvYXQgbmV0RXJyb3JXZWlnaHRFO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEZPdXRwdXRGO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEVycm9yV2VpZ2h0RjtcXG4gICAgICAgICAgICBmbG9hdCBuZXRGT3V0cHV0RztcXG4gICAgICAgICAgICBmbG9hdCBuZXRFcnJvcldlaWdodEc7XFxuICAgICAgICB9O1xcbiAgICAgICAgZmxvYXQgdGFuaChmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgICBmbG9hdCB0bXAgPSBleHAodmFsKTtcXG4gICAgICAgICAgICBmbG9hdCB0YW5IID0gKHRtcCAtIDEuMCAvIHRtcCkgLyAodG1wICsgMS4wIC8gdG1wKTtcXG4gICAgICAgICAgICByZXR1cm4gdGFuSDtcXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IHNpZ20oZmxvYXQgdmFsKSB7XFxuICAgICAgICAgICAgcmV0dXJuICgxLjAgLyAoMS4wICsgZXhwKC12YWwpKSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZEFkak1hdHJpeFJlc3BvbnNlIGlkQWRqTWF0cml4X0ZvcmNlTGF5b3V0KGZsb2F0IG5vZGVJZCwgdmVjMyBjdXJyZW50UG9zLCB2ZWMzIGN1cnJlbnREaXIsIGZsb2F0IG51bU9mQ29ubmVjdGlvbnMpIHtcXG4gICAgICAgICAgICB2ZWMzIGF0cmFjdGlvbiA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgICAgICAgZmxvYXQgYWN1bUF0cmFjdGlvbiA9IDEuMDtcXG4gICAgICAgICAgICB2ZWMzIHJlcHVsc2lvbiA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFxuICAgICAgICAgICAgdmVjMyBmb3JjZSA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFxuXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUEgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEEgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRBID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CaWFzQSA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvckJpYXNBID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRCID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQmlhc0IgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JCaWFzQiA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQyA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0QyA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEMgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUJpYXNDID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yQmlhc0MgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUQgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEQgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHREID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CaWFzRCA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvckJpYXNEID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1FID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRFID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQmlhc0UgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JCaWFzRSA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRiA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0RiA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEYgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUJpYXNGID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yQmlhc0YgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUcgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEcgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRHID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CaWFzRyA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvckJpYXNHID0gMC4wO1xcbiAgICAgICAgICAgIFxcblxcbiAgICAgICAgICAgIGlmKG5vZGVJZCA8IG5vZGVzQ291bnQpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudEFjdGl2YXRpb25GbiA9IDAuMDtcXG4gICAgICAgICAgICAgICAgdmVjMiB4R2VvbUN1cnJlbnQgPSBnZXRfZ2xvYmFsX2lkKG5vZGVJZCwgdUJ1ZmZlcldpZHRoLCAnICsgZ2VvbWV0cnlMZW5ndGgudG9GaXhlZCgxKSArICcpO1xcbiAgICAgICAgICAgICAgICBmb3IoaW50IG49MDsgbiA8IDQwOTY7IG4rKykge1xcbiAgICAgICAgICAgICAgICAgICAgaWYoZmxvYXQobikgPj0gbm9kZXNDb3VudCkge2JyZWFrO31cXG4gICAgICAgICAgICAgICAgICAgIGlmKGZsb2F0KG4pICE9IG5vZGVJZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIgeEdlb21PcHBvc2l0ZSA9IGdldF9nbG9iYWxfaWQoZmxvYXQobiksIHVCdWZmZXJXaWR0aCwgJyArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyAnKTtcXG5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyIHhBZGpNYXRDdXJyZW50ID0gZ2V0X2dsb2JhbF9pZCh2ZWMyKGZsb2F0KG4pLCBub2RlSWQpLCB3aWR0aEFkak1hdHJpeCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMiB4QWRqTWF0T3Bwb3NpdGUgPSBnZXRfZ2xvYmFsX2lkKHZlYzIobm9kZUlkLCBmbG9hdChuKSksIHdpZHRoQWRqTWF0cml4KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEFDdXJyZW50ID0gYWRqYWNlbmN5TWF0cml4W3hBZGpNYXRDdXJyZW50XTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEFPcHBvc2l0ZSA9IGFkamFjZW5jeU1hdHJpeFt4QWRqTWF0T3Bwb3NpdGVdO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0QkN1cnJlbnQgPSBhZGphY2VuY3lNYXRyaXhCW3hBZGpNYXRDdXJyZW50XTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEJPcHBvc2l0ZSA9IGFkamFjZW5jeU1hdHJpeEJbeEFkak1hdE9wcG9zaXRlXTtcXG5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBDYWxjdWxhdGlvblJlc3BvbnNlIGNhbGNSZXNwb25zZSA9IGNhbGN1bGF0ZShub2RlSWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhBZGpNYXRBQ3VycmVudCwgcGl4QWRqTWF0QU9wcG9zaXRlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4QWRqTWF0QkN1cnJlbnQsIHBpeEFkak1hdEJPcHBvc2l0ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhHZW9tQ3VycmVudCwgeEdlb21PcHBvc2l0ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MsIGN1cnJlbnREaXIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHJhY3Rpb24sIGFjdW1BdHJhY3Rpb24sIHJlcHVsc2lvbixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1BLCBuZXRQYXJlbnRFcnJvcldlaWdodEEsIG5ldENoaWxkSW5wdXRTdW1CaWFzQSwgbmV0UGFyZW50RXJyb3JCaWFzQSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1CLCBuZXRQYXJlbnRFcnJvcldlaWdodEIsIG5ldENoaWxkSW5wdXRTdW1CaWFzQiwgbmV0UGFyZW50RXJyb3JCaWFzQixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1DLCBuZXRQYXJlbnRFcnJvcldlaWdodEMsIG5ldENoaWxkSW5wdXRTdW1CaWFzQywgbmV0UGFyZW50RXJyb3JCaWFzQyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1ELCBuZXRQYXJlbnRFcnJvcldlaWdodEQsIG5ldENoaWxkSW5wdXRTdW1CaWFzRCwgbmV0UGFyZW50RXJyb3JCaWFzRCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1FLCBuZXRQYXJlbnRFcnJvcldlaWdodEUsIG5ldENoaWxkSW5wdXRTdW1CaWFzRSwgbmV0UGFyZW50RXJyb3JCaWFzRSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1GLCBuZXRQYXJlbnRFcnJvcldlaWdodEYsIG5ldENoaWxkSW5wdXRTdW1CaWFzRiwgbmV0UGFyZW50RXJyb3JCaWFzRixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1HLCBuZXRQYXJlbnRFcnJvcldlaWdodEcsIG5ldENoaWxkSW5wdXRTdW1CaWFzRywgbmV0UGFyZW50RXJyb3JCaWFzRyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYXRyYWN0aW9uID0gY2FsY1Jlc3BvbnNlLmF0cmFjdGlvbjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3VtQXRyYWN0aW9uID0gY2FsY1Jlc3BvbnNlLmFjdW1BdHJhY3Rpb247XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwdWxzaW9uID0gY2FsY1Jlc3BvbnNlLnJlcHVsc2lvbjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQSA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtQTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEEgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JXZWlnaHRBO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1CaWFzQSA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtQmlhc0E7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JCaWFzQSA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvckJpYXNBO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1CID0gY2FsY1Jlc3BvbnNlLm5ldENoaWxkSW5wdXRTdW1CO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvcldlaWdodEI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUJpYXNCID0gY2FsY1Jlc3BvbnNlLm5ldENoaWxkSW5wdXRTdW1CaWFzQjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvckJpYXNCID0gY2FsY1Jlc3BvbnNlLm5ldFBhcmVudEVycm9yQmlhc0I7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUMgPSBjYWxjUmVzcG9uc2UubmV0Q2hpbGRJbnB1dFN1bUM7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRDID0gY2FsY1Jlc3BvbnNlLm5ldFBhcmVudEVycm9yV2VpZ2h0QztcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQmlhc0MgPSBjYWxjUmVzcG9uc2UubmV0Q2hpbGRJbnB1dFN1bUJpYXNDO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yQmlhc0MgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JCaWFzQztcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRCA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtRDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEQgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JXZWlnaHREO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1CaWFzRCA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtQmlhc0Q7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JCaWFzRCA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvckJpYXNEO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1FID0gY2FsY1Jlc3BvbnNlLm5ldENoaWxkSW5wdXRTdW1FO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvcldlaWdodEU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUJpYXNFID0gY2FsY1Jlc3BvbnNlLm5ldENoaWxkSW5wdXRTdW1CaWFzRTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvckJpYXNFID0gY2FsY1Jlc3BvbnNlLm5ldFBhcmVudEVycm9yQmlhc0U7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUYgPSBjYWxjUmVzcG9uc2UubmV0Q2hpbGRJbnB1dFN1bUY7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRGID0gY2FsY1Jlc3BvbnNlLm5ldFBhcmVudEVycm9yV2VpZ2h0RjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQmlhc0YgPSBjYWxjUmVzcG9uc2UubmV0Q2hpbGRJbnB1dFN1bUJpYXNGO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yQmlhc0YgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JCaWFzRjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRyA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtRztcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEcgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JXZWlnaHRHO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1CaWFzRyA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtQmlhc0c7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JCaWFzRyA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvckJpYXNHO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGZvcmNlICs9IChhdHJhY3Rpb24vYWN1bUF0cmFjdGlvbik7XFxuICAgICAgICAgICAgICAgIGZvcmNlICs9IChyZXB1bHNpb24vYWN1bUF0cmFjdGlvbik7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50Qmlhc05vZGUgPSBkYXRhQlt4R2VvbUN1cnJlbnRdLng7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAnICsgR3JhcGhVdGlscy5lZmZlcmVudE5vZGVzU3RyKGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkgKyAnXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiBpZEFkak1hdHJpeFJlc3BvbnNlKHZlYzMoZm9yY2UpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QSwgbmV0UGFyZW50RXJyb3JXZWlnaHRBLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QiwgbmV0UGFyZW50RXJyb3JXZWlnaHRCLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QywgbmV0UGFyZW50RXJyb3JXZWlnaHRDLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RCwgbmV0UGFyZW50RXJyb3JXZWlnaHRELFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RSwgbmV0UGFyZW50RXJyb3JXZWlnaHRFLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RiwgbmV0UGFyZW50RXJyb3JXZWlnaHRGLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RywgbmV0UGFyZW50RXJyb3JXZWlnaHRHKTtcXG4gICAgICAgIH0nKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZWZmZXJlbnROb2Rlc1N0cicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlZmZlcmVudE5vZGVzU3RyKGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkge1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gT1VUUFVUXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICB2YXIgc3RyID0gJ1xcbiAgICAgICAgICAgIGlmKG5vZGVJZCA8IGFmZmVyZW50Tm9kZXNDb3VudCkge1xcbiAgICAgICAgICAgICAgICBmb3IoZmxvYXQgbj0wLjA7IG4gPCAxMDI0LjA7IG4rPTEuMCkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYobiA+PSBhZmZlcmVudE5vZGVzQ291bnQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGlmKG5vZGVJZCA9PSBuKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEEgPSBhZmZlcmVudE5vZGVzQVtpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRCID0gYWZmZXJlbnROb2Rlc0JbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QyA9IGFmZmVyZW50Tm9kZXNDW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEQgPSBhZmZlcmVudE5vZGVzRFtpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRFID0gYWZmZXJlbnROb2Rlc0VbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RiA9IGFmZmVyZW50Tm9kZXNGW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEcgPSBhZmZlcmVudE5vZGVzR1tpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaWYoY3VycmVudEJpYXNOb2RlID09IDAuMCkgeyAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRBID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUEpOyAnICsgJ1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEIgPSBtYXgoMC4wLCBuZXRDaGlsZElucHV0U3VtQik7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QyA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1DKTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXREID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUQpO1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEUgPSBtYXgoMC4wLCBuZXRDaGlsZElucHV0U3VtRSk7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RiA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1GKTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRHID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUcpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEEgPSBuZXRDaGlsZElucHV0U3VtQTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRCID0gbmV0Q2hpbGRJbnB1dFN1bUI7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QyA9IG5ldENoaWxkSW5wdXRTdW1DO1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEQgPSBuZXRDaGlsZElucHV0U3VtRDtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRFID0gbmV0Q2hpbGRJbnB1dFN1bUU7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RiA9IG5ldENoaWxkSW5wdXRTdW1GO1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEcgPSBuZXRDaGlsZElucHV0U3VtRztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0nO1xuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBFUlJPUlxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgc3RyICs9ICdcXG4gICAgICAgIGlmKG5vZGVJZCA9PSAnICsgZWZmZXJlbnRTdGFydC50b0ZpeGVkKDEpICsgKCcpIHtcXG4gICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEEgPSAoZWZmZXJlbnROb2Rlc0FbMF0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1BLWVmZmVyZW50Tm9kZXNBWzBdIDogMC4wO1xcbiAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IChlZmZlcmVudE5vZGVzQlswXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUItZWZmZXJlbnROb2Rlc0JbMF0gOiAwLjA7XFxuICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRDID0gKGVmZmVyZW50Tm9kZXNDWzBdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtQy1lZmZlcmVudE5vZGVzQ1swXSA6IDAuMDtcXG4gICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEQgPSAoZWZmZXJlbnROb2Rlc0RbMF0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1ELWVmZmVyZW50Tm9kZXNEWzBdIDogMC4wO1xcbiAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IChlZmZlcmVudE5vZGVzRVswXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUUtZWZmZXJlbnROb2Rlc0VbMF0gOiAwLjA7XFxuICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRGID0gKGVmZmVyZW50Tm9kZXNGWzBdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtRi1lZmZlcmVudE5vZGVzRlswXSA6IDAuMDtcXG4gICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEcgPSAoZWZmZXJlbnROb2Rlc0dbMF0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1HLWVmZmVyZW50Tm9kZXNHWzBdIDogMC4wO1xcbiAgICAgICAgICAgICcgKyAnXFxuICAgICAgICAgICAgJyArICdcXG4gICAgICAgICAgICAnICsgJ1xcbiAgICAgICAgICAgICcgKyAnXFxuICAgICAgICAgICAgJyArICdcXG4gICAgICAgICAgICAnICsgJ1xcbiAgICAgICAgICAgICcgKyAnXFxuICAgICAgICB9Jyk7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gZWZmZXJlbnRTdGFydCArIDE7IG4gPCBlZmZlcmVudFN0YXJ0ICsgZWZmZXJlbnROb2Rlc0NvdW50OyBuKyspIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbiAgICAgICAgICAgIGVsc2UgaWYobm9kZUlkID09ICcgKyBuLnRvRml4ZWQoMSkgKyAnKSB7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QSA9IChlZmZlcmVudE5vZGVzQVsnICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAnXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUEtZWZmZXJlbnROb2Rlc0FbJyArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgJ10gOiAwLjA7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IChlZmZlcmVudE5vZGVzQlsnICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAnXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUItZWZmZXJlbnROb2Rlc0JbJyArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgJ10gOiAwLjA7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QyA9IChlZmZlcmVudE5vZGVzQ1snICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAnXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUMtZWZmZXJlbnROb2Rlc0NbJyArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgJ10gOiAwLjA7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RCA9IChlZmZlcmVudE5vZGVzRFsnICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAnXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUQtZWZmZXJlbnROb2Rlc0RbJyArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgJ10gOiAwLjA7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IChlZmZlcmVudE5vZGVzRVsnICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAnXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUUtZWZmZXJlbnROb2Rlc0VbJyArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgJ10gOiAwLjA7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RiA9IChlZmZlcmVudE5vZGVzRlsnICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAnXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUYtZWZmZXJlbnROb2Rlc0ZbJyArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgJ10gOiAwLjA7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RyA9IChlZmZlcmVudE5vZGVzR1snICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAnXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUctZWZmZXJlbnROb2Rlc0dbJyArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgKCddIDogMC4wO1xcbiAgICAgICAgICAgICAgICAnICsgJ1xcbiAgICAgICAgICAgICAgICAnICsgJ1xcbiAgICAgICAgICAgICAgICAnICsgJ1xcbiAgICAgICAgICAgICAgICAnICsgJ1xcbiAgICAgICAgICAgICAgICAnICsgJ1xcbiAgICAgICAgICAgICAgICAnICsgJ1xcbiAgICAgICAgICAgICAgICAnICsgJ1xcbiAgICAgICAgICAgIH0nKTtcbiAgICAgICAgICAgIH1zdHIgKz0gJ1xcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgaWYoY3VycmVudEJpYXNOb2RlID09IDAuMCkge1xcbiAgICAgICAgICAgICAgICBpZihmb3V0cHV0QSA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QSA9IDAuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZihmb3V0cHV0QiA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IDAuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZihmb3V0cHV0QyA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QyA9IDAuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZihmb3V0cHV0RCA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RCA9IDAuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZihmb3V0cHV0RSA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IDAuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZihmb3V0cHV0RiA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RiA9IDAuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZihmb3V0cHV0RyA8PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RyA9IDAuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QSA9IG5ldFBhcmVudEVycm9yQmlhc0E7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IG5ldFBhcmVudEVycm9yQmlhc0I7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QyA9IG5ldFBhcmVudEVycm9yQmlhc0M7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RCA9IG5ldFBhcmVudEVycm9yQmlhc0Q7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IG5ldFBhcmVudEVycm9yQmlhc0U7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RiA9IG5ldFBhcmVudEVycm9yQmlhc0Y7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RyA9IG5ldFBhcmVudEVycm9yQmlhc0c7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSc7XG5cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gR3JhcGhVdGlscztcbn0oKTtcblxuZ2xvYmFsLkdyYXBoVXRpbHMgPSBHcmFwaFV0aWxzO1xubW9kdWxlLmV4cG9ydHMuR3JhcGhVdGlscyA9IEdyYXBoVXRpbHM7Il19
