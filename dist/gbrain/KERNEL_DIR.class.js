(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KERNEL_DIR = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _graphUtil = require("./graphUtil");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var KERNEL_DIR = exports.KERNEL_DIR = function () {
    function KERNEL_DIR() {
        _classCallCheck(this, KERNEL_DIR);
    }

    _createClass(KERNEL_DIR, null, [{
        key: "getSrc",
        value: function getSrc(customCode, geometryLength, efferentStart, efferentNodesCount, _enableNeuronalNetwork) {
            var outputArr = null;
            var returnStr = null;
            if (_enableNeuronalNetwork === true) {
                outputArr = ["dir", "posXYZW", "dataB", "dataF", "dataG", "dataH"];
                returnStr = 'return [vec4(currentDir, 1.0), vec4(currentPos.x, currentPos.y, currentPos.z, 1.0), currentDataB, currentDataF, currentDataG, currentDataH];';
            } else {
                outputArr = ["dir", "posXYZW"];
                returnStr = 'return [vec4(currentDir, 1.0), vec4(currentPos.x, currentPos.y, currentPos.z, 1.0)];';
            }

            return ["x", outputArr,
            // head
            _graphUtil.GraphUtils.adjMatrix_ForceLayout_GLSLFunctionString(geometryLength, efferentStart, efferentNodesCount),

            // source
            "float nodeId = data[x].x;\n                    float numOfConnections = data[x].y;\n                    vec2 xGeometry = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n                    vec3 currentPos = posXYZW[xGeometry].xyz;\n\n                    float bornDate = dataB[xGeometry].x;\n                    float dieDate = dataB[xGeometry].y;\n\n                    vec3 currentDir = dir[xGeometry].xyz;\n\n\n                    vec4 currentDataB = dataB[xGeometry];\n                    vec4 currentDataF = dataF[xGeometry];\n                    vec4 currentDataG = dataG[xGeometry];\n                    vec4 currentDataH = dataH[xGeometry];\n\n                    currentDir = vec3(0.0, 0.0, 0.0);\n\n                    if(enableForceLayout == 1.0) {\n                        idAdjMatrixResponse adjM = idAdjMatrix_ForceLayout(nodeId, currentPos, currentDir, numOfConnections, currentTimestamp, bornDate, dieDate, enableNeuronalNetwork);\n                        currentDir = (adjM.collisionExists == 1.0) ? adjM.force : currentDir+(adjM.force*1.0);\n\n                        if(enableNeuronalNetwork == 1.0 && currentTrainLayer == -3.0) {\n                            currentDataB = vec4(currentDataB.x, currentDataB.y, adjM.netFOutputA, adjM.netErrorWeightA);\n                            currentDataF = vec4(adjM.netFOutputB, adjM.netErrorWeightB, adjM.netFOutputC, adjM.netErrorWeightC);\n                            currentDataG = vec4(adjM.netFOutputD, adjM.netErrorWeightD, adjM.netFOutputE, adjM.netErrorWeightE);\n                            currentDataH = vec4(adjM.netFOutputF, adjM.netErrorWeightF, adjM.netFOutputG, adjM.netErrorWeightG);\n                        }\n                    }\n\n                    " + (customCode !== undefined ? customCode : '') + "\n\n                    if(enableDrag == 1.0) {\n                        if(nodeId == idToDrag) {\n                            currentPos = vec3(MouseDragTranslationX, MouseDragTranslationY, MouseDragTranslationZ);\n                        }\n                    }\n\n                    currentPos += currentDir;\n                    if(only2d == 1.0) {\n                        currentPos.y = 0.0;\n                    }\n\n                    " + returnStr];
        }
    }]);

    return KERNEL_DIR;
}();

global.KERNEL_DIR = KERNEL_DIR;
module.exports.KERNEL_DIR = KERNEL_DIR;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./graphUtil":2}],2:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GraphUtils = exports.GraphUtils = function () {
    function GraphUtils() {
        _classCallCheck(this, GraphUtils);
    }

    _createClass(GraphUtils, null, [{
        key: "nodesDrawMode",
        value: function nodesDrawMode(geometryLength) {
            if (geometryLength === 1) return "vec4(color.rgb, 1.0)";else return "vec4(tex.rgb*color.rgb, tex.a)";
        }
    }, {
        key: "adjMatrix_ForceLayout_GLSLFunctionString",
        value: function adjMatrix_ForceLayout_GLSLFunctionString(geometryLength, efferentStart, efferentNodesCount) {
            return '' + "vec3 sphericalColl(vec3 currentDir, vec3 currentDirB, vec3 dirToBN) {\n            vec3 currentDirN = normalize(currentDir);\n            float pPoint = abs(dot(currentDirN, dirToBN));\n            vec3 reflectV = reflect(currentDirN*-1.0, dirToBN);\n\n            vec3 currentDirBN = normalize(currentDirB);\n            float pPointB = abs(dot(currentDirBN, dirToBN));\n\n            vec3 repulsionForce = (reflectV*-1.0)* (((1.0-pPoint)*length(currentDir))+((pPointB)*length(currentDirB)));\n\n            return (repulsionForce.x > 0.0 && repulsionForce.y > 0.0 && repulsionForce.z > 0.0) ? repulsionForce : dirToBN*-0.1;\n        }\n\n        struct CalculationResponse {\n            vec3 atraction;\n            float acumAtraction;\n            vec3 repulsion;\n            float collisionExists;\n            float netChildInputSumA;\n            float netParentErrorWeightA;\n            float netChildInputSumB;\n            float netParentErrorWeightB;\n            float netChildInputSumC;\n            float netParentErrorWeightC;\n            float netChildInputSumD;\n            float netParentErrorWeightD;\n            float netChildInputSumE;\n            float netParentErrorWeightE;\n            float netChildInputSumF;\n            float netParentErrorWeightF;\n            float netChildInputSumG;\n            float netParentErrorWeightG;\n        };" +

            // pixAdjMatA (bornDate, dieDate, weight (parent:-2;child:w), isParent (1.0:parent;0.0:child))
            // pixAdjMatA (linkMultiplier, activationFunction)
            "CalculationResponse calculate(float nodeId,\n                                        vec4 pixAdjMatACurrent, vec4 pixAdjMatAOpposite,\n                                        vec4 pixAdjMatBCurrent, vec4 pixAdjMatBOpposite,\n                                        vec2 xGeomCurrent, vec2 xGeomOpposite,\n                                        vec3 currentPos, vec3 currentDir,\n                                        vec3 atraction, float acumAtraction, vec3 repulsion,\n                                        float enableNeuronalNetwork,\n                                        float netChildInputSumA, float netParentErrorWeightA,\n                                        float netChildInputSumB, float netParentErrorWeightB,\n                                        float netChildInputSumC, float netParentErrorWeightC,\n                                        float netChildInputSumD, float netParentErrorWeightD,\n                                        float netChildInputSumE, float netParentErrorWeightE,\n                                        float netChildInputSumF, float netParentErrorWeightF,\n                                        float netChildInputSumG, float netParentErrorWeightG) {" +
            // pixAdjMatACurrent
            "float currentBornDate = pixAdjMatACurrent.x;\n            float currentDieDate = pixAdjMatACurrent.y;\n            float currentWeight = pixAdjMatACurrent.z;\n            float currentIsParent = pixAdjMatACurrent.w;" +

            // pixAdjMatAOpposite
            "float oppositeBornDate = pixAdjMatAOpposite.x;\n            float oppositeDieDate = pixAdjMatAOpposite.y;\n            float oppositeWeight = pixAdjMatAOpposite.z;\n            float oppositeIsParent = pixAdjMatAOpposite.w;" +

            // pixAdjMatBCurrent
            "float currentLinkMultiplier = pixAdjMatBCurrent.x;\n            float currentActivationFn = pixAdjMatBCurrent.y;" +

            // pixAdjMatBOpposite
            "float oppositeLinkMultiplier = pixAdjMatBOpposite.x;\n            float oppositeActivationFn = pixAdjMatBOpposite.y;" +

            // dataB Current
            //'float currentBornDate = dataB[xGeomCurrent].x;'+
            //'float currentDieDate = dataB[xGeomCurrent].y;'+
            //'float currentNetOutput = dataB[xGeomCurrent].z;'+
            //'float currentNetError = dataB[xGeomCurrent].w;'+

            // dataB Opposite
            //'float oppositeBornDate = dataB[xGeomOpposite].x;'+
            //'float oppositeDieDate = dataB[xGeomOpposite].y;'+
            "float oppositeNetOutputA = dataB[xGeomOpposite].z;\n            float oppositeNetErrorA = dataB[xGeomOpposite].w;\n\n            float oppositeNetOutputB = dataF[xGeomOpposite].x;\n            float oppositeNetErrorB = dataF[xGeomOpposite].y;\n        \n            float oppositeNetOutputC = dataF[xGeomOpposite].z;\n            float oppositeNetErrorC = dataF[xGeomOpposite].w;\n        \n            float oppositeNetOutputD = dataG[xGeomOpposite].x;\n            float oppositeNetErrorD = dataG[xGeomOpposite].y;\n        \n            float oppositeNetOutputE = dataG[xGeomOpposite].z;\n            float oppositeNetErrorE = dataG[xGeomOpposite].w;\n        \n            float oppositeNetOutputF = dataH[xGeomOpposite].x;\n            float oppositeNetErrorF = dataH[xGeomOpposite].y;\n        \n            float oppositeNetOutputG = dataH[xGeomOpposite].z;\n            float oppositeNetErrorG = dataH[xGeomOpposite].w;" +

            // pos & dir Current
            //'vec3 currentPos = posXYZW[xGeomCurrent].xyz;\n'+
            //'vec3 currentDir = dir[xGeomCurrent].xyz;\n'+

            // pos & dir Opposite
            "vec3 oppositePos = posXYZW[xGeomOpposite].xyz;\n            vec3 oppositeDir = dir[xGeomOpposite].xyz;" +

            // dir / dist to opposite
            'vec3 dirToOpposite = (oppositePos-currentPos);\n' + 'vec3 dirToOppositeN = normalize(dirToOpposite);\n' + 'float dist = distance(oppositePos, currentPos);\n' + // near=0.0 ; far=1.0
            'float distN = max(0.0,dist)/100000.0;' + 'float p = 1.0;' + 'if(currentDieDate != 0.0 && (currentTimestamp < currentBornDate || currentTimestamp > currentDieDate)) ' + 'p = 0.0;' + 'if(oppositeDieDate != 0.0 && (currentTimestamp < oppositeBornDate || currentTimestamp > oppositeDieDate)) ' + 'p = 0.0;' + 'if(p == 1.0) {' + 'float m1 = (enableNeuronalNetwork == 1.0) ? 0.0 : 400000.0;' + 'float m2 = (enableNeuronalNetwork == 1.0) ? 0.0 : 48.0;' + 'if(currentIsParent == 1.0) {' +
            //'if(enableNeuronalNetwork == 1.0) '+
            'netChildInputSumA += oppositeNetOutputA*oppositeWeight;' + 'netChildInputSumB += oppositeNetOutputB*oppositeWeight;' + 'netChildInputSumC += oppositeNetOutputC*oppositeWeight;' + 'netChildInputSumD += oppositeNetOutputD*oppositeWeight;' + 'netChildInputSumE += oppositeNetOutputE*oppositeWeight;' + 'netChildInputSumF += oppositeNetOutputF*oppositeWeight;' + 'netChildInputSumG += oppositeNetOutputG*oppositeWeight;' +
            //'else {'+
            'atraction += dirToOppositeN*max(1.0, distN*abs(oppositeWeight)*(m1/2.0));\n' + 'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(oppositeWeight)*(m2/2.0));\n' + 'acumAtraction += 1.0;\n' +
            //'}'+
            '} else if(currentIsParent == 0.5) {' +
            //'if(enableNeuronalNetwork == 1.0) '+
            'netParentErrorWeightA += oppositeNetErrorA*currentWeight;' + 'netParentErrorWeightB += oppositeNetErrorB*currentWeight;' + 'netParentErrorWeightC += oppositeNetErrorC*currentWeight;' + 'netParentErrorWeightD += oppositeNetErrorD*currentWeight;' + 'netParentErrorWeightE += oppositeNetErrorE*currentWeight;' + 'netParentErrorWeightF += oppositeNetErrorF*currentWeight;' + 'netParentErrorWeightG += oppositeNetErrorG*currentWeight;' +
            //'else {'+
            'atraction += dirToOppositeN*max(1.0, distN*abs(currentWeight)*m1);\n' + 'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*m2);\n' + 'acumAtraction += 1.0;\n' +
            //'}'+
            '}' +

            //'if(enableNeuronalNetwork == 0.0) {'+
            'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*(m2/8.0));\n' + 'acumAtraction += 1.0;\n' +
            //'}'+
            '}' + ("float collisionExists = 0.0;\n            if(enableForceLayoutCollision == 1.0 && dist < 4.0) {\n                collisionExists = 1.0;\n                atraction = sphericalColl(currentDir, oppositeDir, dirToOppositeN);\n            }\n\n            return CalculationResponse(atraction, acumAtraction, repulsion, collisionExists,\n                                        netChildInputSumA, netParentErrorWeightA,\n                                        netChildInputSumB, netParentErrorWeightB,\n                                        netChildInputSumC, netParentErrorWeightC,\n                                        netChildInputSumD, netParentErrorWeightD,\n                                        netChildInputSumE, netParentErrorWeightE,\n                                        netChildInputSumF, netParentErrorWeightF,\n                                        netChildInputSumG, netParentErrorWeightG);\n        }\n        struct idAdjMatrixResponse {\n            vec3 force;\n            float collisionExists;\n            float netFOutputA;\n            float netErrorWeightA;\n            float netFOutputB;\n            float netErrorWeightB;\n            float netFOutputC;\n            float netErrorWeightC;\n            float netFOutputD;\n            float netErrorWeightD;\n            float netFOutputE;\n            float netErrorWeightE;\n            float netFOutputF;\n            float netErrorWeightF;\n            float netFOutputG;\n            float netErrorWeightG;\n        };\n        float tanh(float val) {\n            float tmp = exp(val);\n            float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n            return tanH;\n        }\n        float sigm(float val) {\n            return (1.0 / (1.0 + exp(-val)));\n        }\n        idAdjMatrixResponse idAdjMatrix_ForceLayout(float nodeId, vec3 currentPos, vec3 currentDir, float numOfConnections, float currentTimestamp, float bornDate, float dieDate, float enableNeuronalNetwork) {\n            vec3 atraction = vec3(0.0, 0.0, 0.0);\n            float acumAtraction = 1.0;\n            vec3 repulsion = vec3(0.0, 0.0, 0.0);\n\n            float collisionExists = 0.0;\n            vec3 force = vec3(0.0, 0.0, 0.0);\n\n\n            float netChildInputSumA = 0.0;\n            float foutputA = 0.0;\n            float netParentErrorWeightA = 0.0;\n            \n            float netChildInputSumB = 0.0;\n            float foutputB = 0.0;\n            float netParentErrorWeightB = 0.0;\n            \n            float netChildInputSumC = 0.0;\n            float foutputC = 0.0;\n            float netParentErrorWeightC = 0.0;\n            \n            float netChildInputSumD = 0.0;\n            float foutputD = 0.0;\n            float netParentErrorWeightD = 0.0;\n            \n            float netChildInputSumE = 0.0;\n            float foutputE = 0.0;\n            float netParentErrorWeightE = 0.0;\n            \n            float netChildInputSumF = 0.0;\n            float foutputF = 0.0;\n            float netParentErrorWeightF = 0.0;\n            \n            float netChildInputSumG = 0.0;\n            float foutputG = 0.0;\n            float netParentErrorWeightG = 0.0;\n            \n\n            if(nodeId < nodesCount) {\n                float currentActivationFn = 0.0;\n                vec2 xGeomCurrent = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n                for(int n=0; n < 4096; n++) {\n                    if(float(n) >= nodesCount) {break;}\n                    if(float(n) != nodeId) {\n                        vec2 xGeomOpposite = get_global_id(float(n), uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n                        vec2 xAdjMatCurrent = get_global_id(vec2(float(n), nodeId), widthAdjMatrix);\n                        vec2 xAdjMatOpposite = get_global_id(vec2(nodeId, float(n)), widthAdjMatrix);\n\n                        vec4 pixAdjMatACurrent = adjacencyMatrix[xAdjMatCurrent];\n                        vec4 pixAdjMatAOpposite = adjacencyMatrix[xAdjMatOpposite];\n\n                        vec4 pixAdjMatBCurrent = adjacencyMatrixB[xAdjMatCurrent];\n                        vec4 pixAdjMatBOpposite = adjacencyMatrixB[xAdjMatOpposite];\n\n\n                        CalculationResponse calcResponse = calculate(nodeId,\n                                                                    pixAdjMatACurrent, pixAdjMatAOpposite,\n                                                                    pixAdjMatBCurrent, pixAdjMatBOpposite,\n                                                                    xGeomCurrent, xGeomOpposite,\n                                                                    currentPos, currentDir,\n                                                                    atraction, acumAtraction, repulsion,\n                                                                    enableNeuronalNetwork,\n                                                                    netChildInputSumA, netParentErrorWeightA,\n                                                                    netChildInputSumB, netParentErrorWeightB,\n                                                                    netChildInputSumC, netParentErrorWeightC,\n                                                                    netChildInputSumD, netParentErrorWeightD,\n                                                                    netChildInputSumE, netParentErrorWeightE,\n                                                                    netChildInputSumF, netParentErrorWeightF,\n                                                                    netChildInputSumG, netParentErrorWeightG);\n                        atraction = calcResponse.atraction;\n                        acumAtraction = calcResponse.acumAtraction;\n                        repulsion = calcResponse.repulsion;\n                        \n                        \n                        netChildInputSumA = calcResponse.netChildInputSumA;\n                        netParentErrorWeightA = calcResponse.netParentErrorWeightA;\n                        \n                        netChildInputSumB = calcResponse.netChildInputSumB;\n                        netParentErrorWeightB = calcResponse.netParentErrorWeightB;\n                        \n                        netChildInputSumC = calcResponse.netChildInputSumC;\n                        netParentErrorWeightC = calcResponse.netParentErrorWeightC;\n                        \n                        netChildInputSumD = calcResponse.netChildInputSumD;\n                        netParentErrorWeightD = calcResponse.netParentErrorWeightD;\n                        \n                        netChildInputSumE = calcResponse.netChildInputSumE;\n                        netParentErrorWeightE = calcResponse.netParentErrorWeightE;\n                        \n                        netChildInputSumF = calcResponse.netChildInputSumF;\n                        netParentErrorWeightF = calcResponse.netParentErrorWeightF;\n                        \n                        netChildInputSumG = calcResponse.netChildInputSumG;\n                        netParentErrorWeightG = calcResponse.netParentErrorWeightG;\n\n\n                        if(calcResponse.collisionExists == 1.0) {\n                            collisionExists = 1.0;\n                            force = calcResponse.atraction;\n                            break;\n                        }\n\n                        if(dieDate != 0.0) {\n                            if(currentTimestamp < bornDate || currentTimestamp > dieDate) {\n                                force = vec3(0.0, 0.0, 0.0);\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if(collisionExists == 0.0) {\n                    force += (atraction/acumAtraction)*1.0;\n                    force += (repulsion/acumAtraction)*1.0;\n                }\n\n                if(enableNeuronalNetwork == 1.0) {\n                    " + GraphUtils.efferentNodesStr(efferentStart, efferentNodesCount) + "\n                }\n            }\n\n            return idAdjMatrixResponse(vec3(force), collisionExists,\n                                        foutputA, netParentErrorWeightA,\n                                        foutputB, netParentErrorWeightB,\n                                        foutputC, netParentErrorWeightC,\n                                        foutputD, netParentErrorWeightD,\n                                        foutputE, netParentErrorWeightE,\n                                        foutputF, netParentErrorWeightF,\n                                        foutputG, netParentErrorWeightG);\n        }");
        }
    }, {
        key: "efferentNodesStr",
        value: function efferentNodesStr(efferentStart, efferentNodesCount) {
            var str = "\n            if(nodeId < afferentNodesCount) {\n                for(float n=0.0; n < 1024.0; n+=1.0) {\n                    if(n >= afferentNodesCount) {\n                        break;\n                    }\n                    if(nodeId == n) {\n                        foutputA = afferentNodesA[int(n)];\n                        foutputB = afferentNodesB[int(n)];\n                        foutputC = afferentNodesC[int(n)];\n                        foutputD = afferentNodesD[int(n)];\n                        foutputE = afferentNodesE[int(n)];\n                        foutputF = afferentNodesF[int(n)];\n                        foutputG = afferentNodesG[int(n)];\n                        break;\n                    }\n                }\n            } else {\n                foutputA = max(0.0, netChildInputSumA); " + "\n                foutputB = max(0.0, netChildInputSumB);\n                foutputC = max(0.0, netChildInputSumC);\n                foutputD = max(0.0, netChildInputSumD);\n                foutputE = max(0.0, netChildInputSumE);\n                foutputF = max(0.0, netChildInputSumF);\n                foutputG = max(0.0, netChildInputSumG);\n            }";

            str += "\n        if(nodeId == " + efferentStart.toFixed(1) + (") {\n            netParentErrorWeightA = (efferentNodesA[0] != 0.0) ? netChildInputSumA-efferentNodesA[0] : 0.0;\n            " + "\n            netParentErrorWeightB = (efferentNodesB[0] != 0.0) ? netChildInputSumB-efferentNodesB[0] : 0.0;\n            " + "\n            netParentErrorWeightC = (efferentNodesC[0] != 0.0) ? netChildInputSumC-efferentNodesC[0] : 0.0;\n            " + "\n            netParentErrorWeightD = (efferentNodesD[0] != 0.0) ? netChildInputSumD-efferentNodesD[0] : 0.0;\n            " + "\n            netParentErrorWeightE = (efferentNodesE[0] != 0.0) ? netChildInputSumE-efferentNodesE[0] : 0.0;\n            " + "\n            netParentErrorWeightF = (efferentNodesF[0] != 0.0) ? netChildInputSumF-efferentNodesF[0] : 0.0;\n            " + "\n            netParentErrorWeightG = (efferentNodesG[0] != 0.0) ? netChildInputSumG-efferentNodesG[0] : 0.0;\n            " + "\n        }");
            for (var n = efferentStart + 1; n < efferentStart + efferentNodesCount; n++) {
                str += "\n            else if(nodeId == " + n.toFixed(1) + ") {\n                netParentErrorWeightA = (efferentNodesA[" + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumA-efferentNodesA[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightB = (efferentNodesB[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumB-efferentNodesB[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightC = (efferentNodesC[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumC-efferentNodesC[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightD = (efferentNodesD[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumD-efferentNodesD[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightE = (efferentNodesE[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumE-efferentNodesE[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightF = (efferentNodesF[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumF-efferentNodesF[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightG = (efferentNodesG[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumG-efferentNodesG[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n            }");
            }str += "\n        else {\n            if(foutputA <= 0.0) {\n                netParentErrorWeightA = 0.0;\n            }\n            if(foutputB <= 0.0) {\n                netParentErrorWeightB = 0.0;\n            }\n            if(foutputC <= 0.0) {\n                netParentErrorWeightC = 0.0;\n            }\n            if(foutputD <= 0.0) {\n                netParentErrorWeightD = 0.0;\n            }\n            if(foutputE <= 0.0) {\n                netParentErrorWeightE = 0.0;\n            }\n            if(foutputF <= 0.0) {\n                netParentErrorWeightF = 0.0;\n            }\n            if(foutputG <= 0.0) {\n                netParentErrorWeightG = 0.0;\n            }\n        }";

            return str;
        }
    }, {
        key: "adjMatrix_Autolink_GLSLFunctionString",
        value: function adjMatrix_Autolink_GLSLFunctionString(geometryLength) {
            return '' + 'float GetAngle(vec3 A, vec3 B) {' + // from -180.0 to 180.0
            'vec3 cr = cross(A, B);' + 'float d = dot(A, B);' + 'if(cr.y < 0.0) {' + 'if(d > 0.0) {' + 'd =        (1.0-d)*90.0;' + '} else {' + 'd = 90.0+  (abs(d)*90.0);' + '}' + '} else {' + 'if(d > 0.0) {' + 'd = 270.0+ (d*90.0);' + '} else {' + 'd = 180.0+ ((1.0-abs(d))*90.0);' + '}' + '}' + 'return d;' + '}' + 'vec4 idAdjMatrix_Autolink(float nodeId, vec3 currentPos) {\n' +
            // INIT VARS
            'vec2 totalIDrelation = vec2(0.0, 0.0);' + 'float totalAngleRelations = 0.0;' +
            // END INIT VARS

            'if(nodeId < nodesCount) {\n' + 'for(int n=0; n < 4096; n++) {\n' + 'if(float(n) >= nodesCount) break;\n' + 'if(float(n) != nodeId) {' + 'vec2 xAdjMatCurrent = get_global_id(vec2(float(n), nodeId), widthAdjMatrix);' + 'vec4 pixAdjMatACurrent = adjacencyMatrix[xAdjMatCurrent];\n' +

            // RELATION FOUND
            'if(pixAdjMatACurrent.x > 0.0) {' + 'vec2 xGeomOpposite = get_global_id(float(n), uBufferWidth, ' + geometryLength.toFixed(1) + ');\n' + 'vec3 currentPosB = posXYZW[xGeomOpposite].xyz;\n' + 'vec3 dirToBN = normalize(currentPosB-currentPos);\n' + 'vec2 IDrelation = vec2(0.0, 0.0);' + 'float angleRelations = 360.0;' + 'if(nodeId < nodesCount) {\n' + 'for(int nB=0; nB < 4096; nB++) {\n' + 'if(float(nB) >= nodesCount) break;\n' + 'if(float(nB) != float(n) && float(nB) != nodeId) {' + 'vec2 xAdjMatCurrentB = get_global_id(vec2(float(nB), nodeId), widthAdjMatrix);' + 'vec4 pixAdjMatACurrent_B = adjacencyMatrix[xAdjMatCurrentB];\n' + 'if(pixAdjMatACurrent_B.x > 0.0) {' + 'vec2 xGeom_oppoB = get_global_id(float(nB), uBufferWidth, ' + geometryLength.toFixed(1) + ');\n' + 'vec3 currentPosBB = posXYZW[xGeom_oppoB].xyz;\n' + 'vec3 dirToBBN = normalize(currentPosBB-currentPos);\n' + 'float angle = GetAngle(dirToBN,dirToBBN);' + 'if(angle > 0.0 && angle < angleRelations) {' + 'IDrelation = xGeom_oppoB;' + 'angleRelations = angle;' + '}' + '}' + '}' + '}' + '}' + 'if(angleRelations < 360.0 && angleRelations > totalAngleRelations) {' + 'totalIDrelation = IDrelation;' + 'totalAngleRelations = angleRelations;' + '}' + '}' +
            // END RELATION FOUND

            '}' + '}' +
            // SUMMATION
            // END SUMMATION

            '}' + 'return vec4(totalIDrelation, totalAngleRelations, 0.0);' + '}';
        }
    }]);

    return GraphUtils;
}();

global.GraphUtils = GraphUtils;
module.exports.GraphUtils = GraphUtils;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZ2JyYWluL0tFUk5FTF9ESVIuY2xhc3MuanMiLCJzcmMvZ2JyYWluL2dyYXBoVXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLktFUk5FTF9ESVIgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ3JhcGhVdGlsID0gcmVxdWlyZShcIi4vZ3JhcGhVdGlsXCIpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgS0VSTkVMX0RJUiA9IGV4cG9ydHMuS0VSTkVMX0RJUiA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBLRVJORUxfRElSKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS0VSTkVMX0RJUik7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEtFUk5FTF9ESVIsIG51bGwsIFt7XG4gICAgICAgIGtleTogXCJnZXRTcmNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNyYyhjdXN0b21Db2RlLCBnZW9tZXRyeUxlbmd0aCwgZWZmZXJlbnRTdGFydCwgZWZmZXJlbnROb2Rlc0NvdW50LCBfZW5hYmxlTmV1cm9uYWxOZXR3b3JrKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0QXJyID0gbnVsbDtcbiAgICAgICAgICAgIHZhciByZXR1cm5TdHIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKF9lbmFibGVOZXVyb25hbE5ldHdvcmsgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRBcnIgPSBbXCJkaXJcIiwgXCJwb3NYWVpXXCIsIFwiZGF0YUJcIiwgXCJkYXRhRlwiLCBcImRhdGFHXCIsIFwiZGF0YUhcIl07XG4gICAgICAgICAgICAgICAgcmV0dXJuU3RyID0gJ3JldHVybiBbdmVjNChjdXJyZW50RGlyLCAxLjApLCB2ZWM0KGN1cnJlbnRQb3MueCwgY3VycmVudFBvcy55LCBjdXJyZW50UG9zLnosIDEuMCksIGN1cnJlbnREYXRhQiwgY3VycmVudERhdGFGLCBjdXJyZW50RGF0YUcsIGN1cnJlbnREYXRhSF07JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0QXJyID0gW1wiZGlyXCIsIFwicG9zWFlaV1wiXTtcbiAgICAgICAgICAgICAgICByZXR1cm5TdHIgPSAncmV0dXJuIFt2ZWM0KGN1cnJlbnREaXIsIDEuMCksIHZlYzQoY3VycmVudFBvcy54LCBjdXJyZW50UG9zLnksIGN1cnJlbnRQb3MueiwgMS4wKV07JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtcInhcIiwgb3V0cHV0QXJyLFxuICAgICAgICAgICAgLy8gaGVhZFxuICAgICAgICAgICAgX2dyYXBoVXRpbC5HcmFwaFV0aWxzLmFkak1hdHJpeF9Gb3JjZUxheW91dF9HTFNMRnVuY3Rpb25TdHJpbmcoZ2VvbWV0cnlMZW5ndGgsIGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCksXG5cbiAgICAgICAgICAgIC8vIHNvdXJjZVxuICAgICAgICAgICAgXCJmbG9hdCBub2RlSWQgPSBkYXRhW3hdLng7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBudW1PZkNvbm5lY3Rpb25zID0gZGF0YVt4XS55O1xcbiAgICAgICAgICAgICAgICAgICAgdmVjMiB4R2VvbWV0cnkgPSBnZXRfZ2xvYmFsX2lkKG5vZGVJZCwgdUJ1ZmZlcldpZHRoLCBcIiArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyBcIik7XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICB2ZWMzIGN1cnJlbnRQb3MgPSBwb3NYWVpXW3hHZW9tZXRyeV0ueHl6O1xcblxcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgYm9ybkRhdGUgPSBkYXRhQlt4R2VvbWV0cnldLng7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBkaWVEYXRlID0gZGF0YUJbeEdlb21ldHJ5XS55O1xcblxcbiAgICAgICAgICAgICAgICAgICAgdmVjMyBjdXJyZW50RGlyID0gZGlyW3hHZW9tZXRyeV0ueHl6O1xcblxcblxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBjdXJyZW50RGF0YUIgPSBkYXRhQlt4R2VvbWV0cnldO1xcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBjdXJyZW50RGF0YUYgPSBkYXRhRlt4R2VvbWV0cnldO1xcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBjdXJyZW50RGF0YUcgPSBkYXRhR1t4R2VvbWV0cnldO1xcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBjdXJyZW50RGF0YUggPSBkYXRhSFt4R2VvbWV0cnldO1xcblxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERpciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICBpZihlbmFibGVGb3JjZUxheW91dCA9PSAxLjApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZEFkak1hdHJpeFJlc3BvbnNlIGFkak0gPSBpZEFkak1hdHJpeF9Gb3JjZUxheW91dChub2RlSWQsIGN1cnJlbnRQb3MsIGN1cnJlbnREaXIsIG51bU9mQ29ubmVjdGlvbnMsIGN1cnJlbnRUaW1lc3RhbXAsIGJvcm5EYXRlLCBkaWVEYXRlLCBlbmFibGVOZXVyb25hbE5ldHdvcmspO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREaXIgPSAoYWRqTS5jb2xsaXNpb25FeGlzdHMgPT0gMS4wKSA/IGFkak0uZm9yY2UgOiBjdXJyZW50RGlyKyhhZGpNLmZvcmNlKjEuMCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZW5hYmxlTmV1cm9uYWxOZXR3b3JrID09IDEuMCAmJiBjdXJyZW50VHJhaW5MYXllciA9PSAtMy4wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREYXRhQiA9IHZlYzQoY3VycmVudERhdGFCLngsIGN1cnJlbnREYXRhQi55LCBhZGpNLm5ldEZPdXRwdXRBLCBhZGpNLm5ldEVycm9yV2VpZ2h0QSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREYXRhRiA9IHZlYzQoYWRqTS5uZXRGT3V0cHV0QiwgYWRqTS5uZXRFcnJvcldlaWdodEIsIGFkak0ubmV0Rk91dHB1dEMsIGFkak0ubmV0RXJyb3JXZWlnaHRDKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERhdGFHID0gdmVjNChhZGpNLm5ldEZPdXRwdXRELCBhZGpNLm5ldEVycm9yV2VpZ2h0RCwgYWRqTS5uZXRGT3V0cHV0RSwgYWRqTS5uZXRFcnJvcldlaWdodEUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0YUggPSB2ZWM0KGFkak0ubmV0Rk91dHB1dEYsIGFkak0ubmV0RXJyb3JXZWlnaHRGLCBhZGpNLm5ldEZPdXRwdXRHLCBhZGpNLm5ldEVycm9yV2VpZ2h0Ryk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgXCIgKyAoY3VzdG9tQ29kZSAhPT0gdW5kZWZpbmVkID8gY3VzdG9tQ29kZSA6ICcnKSArIFwiXFxuXFxuICAgICAgICAgICAgICAgICAgICBpZihlbmFibGVEcmFnID09IDEuMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5vZGVJZCA9PSBpZFRvRHJhZykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gdmVjMyhNb3VzZURyYWdUcmFuc2xhdGlvblgsIE1vdXNlRHJhZ1RyYW5zbGF0aW9uWSwgTW91c2VEcmFnVHJhbnNsYXRpb25aKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zICs9IGN1cnJlbnREaXI7XFxuICAgICAgICAgICAgICAgICAgICBpZihvbmx5MmQgPT0gMS4wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcy55ID0gMC4wO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgXCIgKyByZXR1cm5TdHJdO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEtFUk5FTF9ESVI7XG59KCk7XG5cbmdsb2JhbC5LRVJORUxfRElSID0gS0VSTkVMX0RJUjtcbm1vZHVsZS5leHBvcnRzLktFUk5FTF9ESVIgPSBLRVJORUxfRElSOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBHcmFwaFV0aWxzID0gZXhwb3J0cy5HcmFwaFV0aWxzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyYXBoVXRpbHMoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmFwaFV0aWxzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoR3JhcGhVdGlscywgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcIm5vZGVzRHJhd01vZGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5vZGVzRHJhd01vZGUoZ2VvbWV0cnlMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeUxlbmd0aCA9PT0gMSkgcmV0dXJuIFwidmVjNChjb2xvci5yZ2IsIDEuMClcIjtlbHNlIHJldHVybiBcInZlYzQodGV4LnJnYipjb2xvci5yZ2IsIHRleC5hKVwiO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYWRqTWF0cml4X0ZvcmNlTGF5b3V0X0dMU0xGdW5jdGlvblN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRqTWF0cml4X0ZvcmNlTGF5b3V0X0dMU0xGdW5jdGlvblN0cmluZyhnZW9tZXRyeUxlbmd0aCwgZWZmZXJlbnRTdGFydCwgZWZmZXJlbnROb2Rlc0NvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyBcInZlYzMgc3BoZXJpY2FsQ29sbCh2ZWMzIGN1cnJlbnREaXIsIHZlYzMgY3VycmVudERpckIsIHZlYzMgZGlyVG9CTikge1xcbiAgICAgICAgICAgIHZlYzMgY3VycmVudERpck4gPSBub3JtYWxpemUoY3VycmVudERpcik7XFxuICAgICAgICAgICAgZmxvYXQgcFBvaW50ID0gYWJzKGRvdChjdXJyZW50RGlyTiwgZGlyVG9CTikpO1xcbiAgICAgICAgICAgIHZlYzMgcmVmbGVjdFYgPSByZWZsZWN0KGN1cnJlbnREaXJOKi0xLjAsIGRpclRvQk4pO1xcblxcbiAgICAgICAgICAgIHZlYzMgY3VycmVudERpckJOID0gbm9ybWFsaXplKGN1cnJlbnREaXJCKTtcXG4gICAgICAgICAgICBmbG9hdCBwUG9pbnRCID0gYWJzKGRvdChjdXJyZW50RGlyQk4sIGRpclRvQk4pKTtcXG5cXG4gICAgICAgICAgICB2ZWMzIHJlcHVsc2lvbkZvcmNlID0gKHJlZmxlY3RWKi0xLjApKiAoKCgxLjAtcFBvaW50KSpsZW5ndGgoY3VycmVudERpcikpKygocFBvaW50QikqbGVuZ3RoKGN1cnJlbnREaXJCKSkpO1xcblxcbiAgICAgICAgICAgIHJldHVybiAocmVwdWxzaW9uRm9yY2UueCA+IDAuMCAmJiByZXB1bHNpb25Gb3JjZS55ID4gMC4wICYmIHJlcHVsc2lvbkZvcmNlLnogPiAwLjApID8gcmVwdWxzaW9uRm9yY2UgOiBkaXJUb0JOKi0wLjE7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdHJ1Y3QgQ2FsY3VsYXRpb25SZXNwb25zZSB7XFxuICAgICAgICAgICAgdmVjMyBhdHJhY3Rpb247XFxuICAgICAgICAgICAgZmxvYXQgYWN1bUF0cmFjdGlvbjtcXG4gICAgICAgICAgICB2ZWMzIHJlcHVsc2lvbjtcXG4gICAgICAgICAgICBmbG9hdCBjb2xsaXNpb25FeGlzdHM7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUE7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRBO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QjtcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQztcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEM7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUQ7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHREO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1FO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRjtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEY7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUc7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRHO1xcbiAgICAgICAgfTtcIiArXG5cbiAgICAgICAgICAgIC8vIHBpeEFkak1hdEEgKGJvcm5EYXRlLCBkaWVEYXRlLCB3ZWlnaHQgKHBhcmVudDotMjtjaGlsZDp3KSwgaXNQYXJlbnQgKDEuMDpwYXJlbnQ7MC4wOmNoaWxkKSlcbiAgICAgICAgICAgIC8vIHBpeEFkak1hdEEgKGxpbmtNdWx0aXBsaWVyLCBhY3RpdmF0aW9uRnVuY3Rpb24pXG4gICAgICAgICAgICBcIkNhbGN1bGF0aW9uUmVzcG9uc2UgY2FsY3VsYXRlKGZsb2F0IG5vZGVJZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRBQ3VycmVudCwgdmVjNCBwaXhBZGpNYXRBT3Bwb3NpdGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0QkN1cnJlbnQsIHZlYzQgcGl4QWRqTWF0Qk9wcG9zaXRlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyIHhHZW9tQ3VycmVudCwgdmVjMiB4R2VvbU9wcG9zaXRlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzIGN1cnJlbnRQb3MsIHZlYzMgY3VycmVudERpcixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyBhdHJhY3Rpb24sIGZsb2F0IGFjdW1BdHJhY3Rpb24sIHZlYzMgcmVwdWxzaW9uLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBlbmFibGVOZXVyb25hbE5ldHdvcmssXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1BLCBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEEsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CLCBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1DLCBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1ELCBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1FLCBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1GLCBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEYsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1HLCBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEcpIHtcIiArXG4gICAgICAgICAgICAvLyBwaXhBZGpNYXRBQ3VycmVudFxuICAgICAgICAgICAgXCJmbG9hdCBjdXJyZW50Qm9ybkRhdGUgPSBwaXhBZGpNYXRBQ3VycmVudC54O1xcbiAgICAgICAgICAgIGZsb2F0IGN1cnJlbnREaWVEYXRlID0gcGl4QWRqTWF0QUN1cnJlbnQueTtcXG4gICAgICAgICAgICBmbG9hdCBjdXJyZW50V2VpZ2h0ID0gcGl4QWRqTWF0QUN1cnJlbnQuejtcXG4gICAgICAgICAgICBmbG9hdCBjdXJyZW50SXNQYXJlbnQgPSBwaXhBZGpNYXRBQ3VycmVudC53O1wiICtcblxuICAgICAgICAgICAgLy8gcGl4QWRqTWF0QU9wcG9zaXRlXG4gICAgICAgICAgICBcImZsb2F0IG9wcG9zaXRlQm9ybkRhdGUgPSBwaXhBZGpNYXRBT3Bwb3NpdGUueDtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZURpZURhdGUgPSBwaXhBZGpNYXRBT3Bwb3NpdGUueTtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZVdlaWdodCA9IHBpeEFkak1hdEFPcHBvc2l0ZS56O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlSXNQYXJlbnQgPSBwaXhBZGpNYXRBT3Bwb3NpdGUudztcIiArXG5cbiAgICAgICAgICAgIC8vIHBpeEFkak1hdEJDdXJyZW50XG4gICAgICAgICAgICBcImZsb2F0IGN1cnJlbnRMaW5rTXVsdGlwbGllciA9IHBpeEFkak1hdEJDdXJyZW50Lng7XFxuICAgICAgICAgICAgZmxvYXQgY3VycmVudEFjdGl2YXRpb25GbiA9IHBpeEFkak1hdEJDdXJyZW50Lnk7XCIgK1xuXG4gICAgICAgICAgICAvLyBwaXhBZGpNYXRCT3Bwb3NpdGVcbiAgICAgICAgICAgIFwiZmxvYXQgb3Bwb3NpdGVMaW5rTXVsdGlwbGllciA9IHBpeEFkak1hdEJPcHBvc2l0ZS54O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlQWN0aXZhdGlvbkZuID0gcGl4QWRqTWF0Qk9wcG9zaXRlLnk7XCIgK1xuXG4gICAgICAgICAgICAvLyBkYXRhQiBDdXJyZW50XG4gICAgICAgICAgICAvLydmbG9hdCBjdXJyZW50Qm9ybkRhdGUgPSBkYXRhQlt4R2VvbUN1cnJlbnRdLng7JytcbiAgICAgICAgICAgIC8vJ2Zsb2F0IGN1cnJlbnREaWVEYXRlID0gZGF0YUJbeEdlb21DdXJyZW50XS55OycrXG4gICAgICAgICAgICAvLydmbG9hdCBjdXJyZW50TmV0T3V0cHV0ID0gZGF0YUJbeEdlb21DdXJyZW50XS56OycrXG4gICAgICAgICAgICAvLydmbG9hdCBjdXJyZW50TmV0RXJyb3IgPSBkYXRhQlt4R2VvbUN1cnJlbnRdLnc7JytcblxuICAgICAgICAgICAgLy8gZGF0YUIgT3Bwb3NpdGVcbiAgICAgICAgICAgIC8vJ2Zsb2F0IG9wcG9zaXRlQm9ybkRhdGUgPSBkYXRhQlt4R2VvbU9wcG9zaXRlXS54OycrXG4gICAgICAgICAgICAvLydmbG9hdCBvcHBvc2l0ZURpZURhdGUgPSBkYXRhQlt4R2VvbU9wcG9zaXRlXS55OycrXG4gICAgICAgICAgICBcImZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0QSA9IGRhdGFCW3hHZW9tT3Bwb3NpdGVdLno7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckEgPSBkYXRhQlt4R2VvbU9wcG9zaXRlXS53O1xcblxcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0QiA9IGRhdGFGW3hHZW9tT3Bwb3NpdGVdLng7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckIgPSBkYXRhRlt4R2VvbU9wcG9zaXRlXS55O1xcbiAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRDID0gZGF0YUZbeEdlb21PcHBvc2l0ZV0uejtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yQyA9IGRhdGFGW3hHZW9tT3Bwb3NpdGVdLnc7XFxuICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEQgPSBkYXRhR1t4R2VvbU9wcG9zaXRlXS54O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0RXJyb3JEID0gZGF0YUdbeEdlb21PcHBvc2l0ZV0ueTtcXG4gICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0RSA9IGRhdGFHW3hHZW9tT3Bwb3NpdGVdLno7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckUgPSBkYXRhR1t4R2VvbU9wcG9zaXRlXS53O1xcbiAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRGID0gZGF0YUhbeEdlb21PcHBvc2l0ZV0ueDtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yRiA9IGRhdGFIW3hHZW9tT3Bwb3NpdGVdLnk7XFxuICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEcgPSBkYXRhSFt4R2VvbU9wcG9zaXRlXS56O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0RXJyb3JHID0gZGF0YUhbeEdlb21PcHBvc2l0ZV0udztcIiArXG5cbiAgICAgICAgICAgIC8vIHBvcyAmIGRpciBDdXJyZW50XG4gICAgICAgICAgICAvLyd2ZWMzIGN1cnJlbnRQb3MgPSBwb3NYWVpXW3hHZW9tQ3VycmVudF0ueHl6O1xcbicrXG4gICAgICAgICAgICAvLyd2ZWMzIGN1cnJlbnREaXIgPSBkaXJbeEdlb21DdXJyZW50XS54eXo7XFxuJytcblxuICAgICAgICAgICAgLy8gcG9zICYgZGlyIE9wcG9zaXRlXG4gICAgICAgICAgICBcInZlYzMgb3Bwb3NpdGVQb3MgPSBwb3NYWVpXW3hHZW9tT3Bwb3NpdGVdLnh5ejtcXG4gICAgICAgICAgICB2ZWMzIG9wcG9zaXRlRGlyID0gZGlyW3hHZW9tT3Bwb3NpdGVdLnh5ejtcIiArXG5cbiAgICAgICAgICAgIC8vIGRpciAvIGRpc3QgdG8gb3Bwb3NpdGVcbiAgICAgICAgICAgICd2ZWMzIGRpclRvT3Bwb3NpdGUgPSAob3Bwb3NpdGVQb3MtY3VycmVudFBvcyk7XFxuJyArICd2ZWMzIGRpclRvT3Bwb3NpdGVOID0gbm9ybWFsaXplKGRpclRvT3Bwb3NpdGUpO1xcbicgKyAnZmxvYXQgZGlzdCA9IGRpc3RhbmNlKG9wcG9zaXRlUG9zLCBjdXJyZW50UG9zKTtcXG4nICsgLy8gbmVhcj0wLjAgOyBmYXI9MS4wXG4gICAgICAgICAgICAnZmxvYXQgZGlzdE4gPSBtYXgoMC4wLGRpc3QpLzEwMDAwMC4wOycgKyAnZmxvYXQgcCA9IDEuMDsnICsgJ2lmKGN1cnJlbnREaWVEYXRlICE9IDAuMCAmJiAoY3VycmVudFRpbWVzdGFtcCA8IGN1cnJlbnRCb3JuRGF0ZSB8fCBjdXJyZW50VGltZXN0YW1wID4gY3VycmVudERpZURhdGUpKSAnICsgJ3AgPSAwLjA7JyArICdpZihvcHBvc2l0ZURpZURhdGUgIT0gMC4wICYmIChjdXJyZW50VGltZXN0YW1wIDwgb3Bwb3NpdGVCb3JuRGF0ZSB8fCBjdXJyZW50VGltZXN0YW1wID4gb3Bwb3NpdGVEaWVEYXRlKSkgJyArICdwID0gMC4wOycgKyAnaWYocCA9PSAxLjApIHsnICsgJ2Zsb2F0IG0xID0gKGVuYWJsZU5ldXJvbmFsTmV0d29yayA9PSAxLjApID8gMC4wIDogNDAwMDAwLjA7JyArICdmbG9hdCBtMiA9IChlbmFibGVOZXVyb25hbE5ldHdvcmsgPT0gMS4wKSA/IDAuMCA6IDQ4LjA7JyArICdpZihjdXJyZW50SXNQYXJlbnQgPT0gMS4wKSB7JyArXG4gICAgICAgICAgICAvLydpZihlbmFibGVOZXVyb25hbE5ldHdvcmsgPT0gMS4wKSAnK1xuICAgICAgICAgICAgJ25ldENoaWxkSW5wdXRTdW1BICs9IG9wcG9zaXRlTmV0T3V0cHV0QSpvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1CICs9IG9wcG9zaXRlTmV0T3V0cHV0QipvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1DICs9IG9wcG9zaXRlTmV0T3V0cHV0QypvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1EICs9IG9wcG9zaXRlTmV0T3V0cHV0RCpvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1FICs9IG9wcG9zaXRlTmV0T3V0cHV0RSpvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1GICs9IG9wcG9zaXRlTmV0T3V0cHV0RipvcHBvc2l0ZVdlaWdodDsnICsgJ25ldENoaWxkSW5wdXRTdW1HICs9IG9wcG9zaXRlTmV0T3V0cHV0RypvcHBvc2l0ZVdlaWdodDsnICtcbiAgICAgICAgICAgIC8vJ2Vsc2UgeycrXG4gICAgICAgICAgICAnYXRyYWN0aW9uICs9IGRpclRvT3Bwb3NpdGVOKm1heCgxLjAsIGRpc3ROKmFicyhvcHBvc2l0ZVdlaWdodCkqKG0xLzIuMCkpO1xcbicgKyAncmVwdWxzaW9uICs9IC1kaXJUb09wcG9zaXRlTiptYXgoMS4wLCAoMS4wLWRpc3ROKSphYnMob3Bwb3NpdGVXZWlnaHQpKihtMi8yLjApKTtcXG4nICsgJ2FjdW1BdHJhY3Rpb24gKz0gMS4wO1xcbicgK1xuICAgICAgICAgICAgLy8nfScrXG4gICAgICAgICAgICAnfSBlbHNlIGlmKGN1cnJlbnRJc1BhcmVudCA9PSAwLjUpIHsnICtcbiAgICAgICAgICAgIC8vJ2lmKGVuYWJsZU5ldXJvbmFsTmV0d29yayA9PSAxLjApICcrXG4gICAgICAgICAgICAnbmV0UGFyZW50RXJyb3JXZWlnaHRBICs9IG9wcG9zaXRlTmV0RXJyb3JBKmN1cnJlbnRXZWlnaHQ7JyArICduZXRQYXJlbnRFcnJvcldlaWdodEIgKz0gb3Bwb3NpdGVOZXRFcnJvckIqY3VycmVudFdlaWdodDsnICsgJ25ldFBhcmVudEVycm9yV2VpZ2h0QyArPSBvcHBvc2l0ZU5ldEVycm9yQypjdXJyZW50V2VpZ2h0OycgKyAnbmV0UGFyZW50RXJyb3JXZWlnaHREICs9IG9wcG9zaXRlTmV0RXJyb3JEKmN1cnJlbnRXZWlnaHQ7JyArICduZXRQYXJlbnRFcnJvcldlaWdodEUgKz0gb3Bwb3NpdGVOZXRFcnJvckUqY3VycmVudFdlaWdodDsnICsgJ25ldFBhcmVudEVycm9yV2VpZ2h0RiArPSBvcHBvc2l0ZU5ldEVycm9yRipjdXJyZW50V2VpZ2h0OycgKyAnbmV0UGFyZW50RXJyb3JXZWlnaHRHICs9IG9wcG9zaXRlTmV0RXJyb3JHKmN1cnJlbnRXZWlnaHQ7JyArXG4gICAgICAgICAgICAvLydlbHNlIHsnK1xuICAgICAgICAgICAgJ2F0cmFjdGlvbiArPSBkaXJUb09wcG9zaXRlTiptYXgoMS4wLCBkaXN0TiphYnMoY3VycmVudFdlaWdodCkqbTEpO1xcbicgKyAncmVwdWxzaW9uICs9IC1kaXJUb09wcG9zaXRlTiptYXgoMS4wLCAoMS4wLWRpc3ROKSphYnMoY3VycmVudFdlaWdodCkqbTIpO1xcbicgKyAnYWN1bUF0cmFjdGlvbiArPSAxLjA7XFxuJyArXG4gICAgICAgICAgICAvLyd9JytcbiAgICAgICAgICAgICd9JyArXG5cbiAgICAgICAgICAgIC8vJ2lmKGVuYWJsZU5ldXJvbmFsTmV0d29yayA9PSAwLjApIHsnK1xuICAgICAgICAgICAgJ3JlcHVsc2lvbiArPSAtZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgKDEuMC1kaXN0TikqYWJzKGN1cnJlbnRXZWlnaHQpKihtMi84LjApKTtcXG4nICsgJ2FjdW1BdHJhY3Rpb24gKz0gMS4wO1xcbicgK1xuICAgICAgICAgICAgLy8nfScrXG4gICAgICAgICAgICAnfScgKyAoXCJmbG9hdCBjb2xsaXNpb25FeGlzdHMgPSAwLjA7XFxuICAgICAgICAgICAgaWYoZW5hYmxlRm9yY2VMYXlvdXRDb2xsaXNpb24gPT0gMS4wICYmIGRpc3QgPCA0LjApIHtcXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uRXhpc3RzID0gMS4wO1xcbiAgICAgICAgICAgICAgICBhdHJhY3Rpb24gPSBzcGhlcmljYWxDb2xsKGN1cnJlbnREaXIsIG9wcG9zaXRlRGlyLCBkaXJUb09wcG9zaXRlTik7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiBDYWxjdWxhdGlvblJlc3BvbnNlKGF0cmFjdGlvbiwgYWN1bUF0cmFjdGlvbiwgcmVwdWxzaW9uLCBjb2xsaXNpb25FeGlzdHMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1BLCBuZXRQYXJlbnRFcnJvcldlaWdodEEsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1CLCBuZXRQYXJlbnRFcnJvcldlaWdodEIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1DLCBuZXRQYXJlbnRFcnJvcldlaWdodEMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1ELCBuZXRQYXJlbnRFcnJvcldlaWdodEQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1FLCBuZXRQYXJlbnRFcnJvcldlaWdodEUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1GLCBuZXRQYXJlbnRFcnJvcldlaWdodEYsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1HLCBuZXRQYXJlbnRFcnJvcldlaWdodEcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RydWN0IGlkQWRqTWF0cml4UmVzcG9uc2Uge1xcbiAgICAgICAgICAgIHZlYzMgZm9yY2U7XFxuICAgICAgICAgICAgZmxvYXQgY29sbGlzaW9uRXhpc3RzO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEZPdXRwdXRBO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEVycm9yV2VpZ2h0QTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRGT3V0cHV0QjtcXG4gICAgICAgICAgICBmbG9hdCBuZXRFcnJvcldlaWdodEI7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Rk91dHB1dEM7XFxuICAgICAgICAgICAgZmxvYXQgbmV0RXJyb3JXZWlnaHRDO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEZPdXRwdXREO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEVycm9yV2VpZ2h0RDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRGT3V0cHV0RTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRFcnJvcldlaWdodEU7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Rk91dHB1dEY7XFxuICAgICAgICAgICAgZmxvYXQgbmV0RXJyb3JXZWlnaHRGO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEZPdXRwdXRHO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEVycm9yV2VpZ2h0RztcXG4gICAgICAgIH07XFxuICAgICAgICBmbG9hdCB0YW5oKGZsb2F0IHZhbCkge1xcbiAgICAgICAgICAgIGZsb2F0IHRtcCA9IGV4cCh2YWwpO1xcbiAgICAgICAgICAgIGZsb2F0IHRhbkggPSAodG1wIC0gMS4wIC8gdG1wKSAvICh0bXAgKyAxLjAgLyB0bXApO1xcbiAgICAgICAgICAgIHJldHVybiB0YW5IO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgc2lnbShmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgICByZXR1cm4gKDEuMCAvICgxLjAgKyBleHAoLXZhbCkpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlkQWRqTWF0cml4UmVzcG9uc2UgaWRBZGpNYXRyaXhfRm9yY2VMYXlvdXQoZmxvYXQgbm9kZUlkLCB2ZWMzIGN1cnJlbnRQb3MsIHZlYzMgY3VycmVudERpciwgZmxvYXQgbnVtT2ZDb25uZWN0aW9ucywgZmxvYXQgY3VycmVudFRpbWVzdGFtcCwgZmxvYXQgYm9ybkRhdGUsIGZsb2F0IGRpZURhdGUsIGZsb2F0IGVuYWJsZU5ldXJvbmFsTmV0d29yaykge1xcbiAgICAgICAgICAgIHZlYzMgYXRyYWN0aW9uID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgICAgICBmbG9hdCBhY3VtQXRyYWN0aW9uID0gMS4wO1xcbiAgICAgICAgICAgIHZlYzMgcmVwdWxzaW9uID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBjb2xsaXNpb25FeGlzdHMgPSAwLjA7XFxuICAgICAgICAgICAgdmVjMyBmb3JjZSA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFxuXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUEgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEEgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRBID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1CID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRCID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQyA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0QyA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEMgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUQgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEQgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHREID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1FID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRFID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRiA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0RiA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEYgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUcgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEcgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRHID0gMC4wO1xcbiAgICAgICAgICAgIFxcblxcbiAgICAgICAgICAgIGlmKG5vZGVJZCA8IG5vZGVzQ291bnQpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudEFjdGl2YXRpb25GbiA9IDAuMDtcXG4gICAgICAgICAgICAgICAgdmVjMiB4R2VvbUN1cnJlbnQgPSBnZXRfZ2xvYmFsX2lkKG5vZGVJZCwgdUJ1ZmZlcldpZHRoLCBcIiArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyBcIik7XFxuICAgICAgICAgICAgICAgIGZvcihpbnQgbj0wOyBuIDwgNDA5NjsgbisrKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZihmbG9hdChuKSA+PSBub2Rlc0NvdW50KSB7YnJlYWs7fVxcbiAgICAgICAgICAgICAgICAgICAgaWYoZmxvYXQobikgIT0gbm9kZUlkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMiB4R2VvbU9wcG9zaXRlID0gZ2V0X2dsb2JhbF9pZChmbG9hdChuKSwgdUJ1ZmZlcldpZHRoLCBcIiArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyBcIik7XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMiB4QWRqTWF0Q3VycmVudCA9IGdldF9nbG9iYWxfaWQodmVjMihmbG9hdChuKSwgbm9kZUlkKSwgd2lkdGhBZGpNYXRyaXgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIgeEFkak1hdE9wcG9zaXRlID0gZ2V0X2dsb2JhbF9pZCh2ZWMyKG5vZGVJZCwgZmxvYXQobikpLCB3aWR0aEFkak1hdHJpeCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRBQ3VycmVudCA9IGFkamFjZW5jeU1hdHJpeFt4QWRqTWF0Q3VycmVudF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRBT3Bwb3NpdGUgPSBhZGphY2VuY3lNYXRyaXhbeEFkak1hdE9wcG9zaXRlXTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEJDdXJyZW50ID0gYWRqYWNlbmN5TWF0cml4Qlt4QWRqTWF0Q3VycmVudF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRCT3Bwb3NpdGUgPSBhZGphY2VuY3lNYXRyaXhCW3hBZGpNYXRPcHBvc2l0ZV07XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgQ2FsY3VsYXRpb25SZXNwb25zZSBjYWxjUmVzcG9uc2UgPSBjYWxjdWxhdGUobm9kZUlkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4QWRqTWF0QUN1cnJlbnQsIHBpeEFkak1hdEFPcHBvc2l0ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpeEFkak1hdEJDdXJyZW50LCBwaXhBZGpNYXRCT3Bwb3NpdGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4R2VvbUN1cnJlbnQsIHhHZW9tT3Bwb3NpdGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zLCBjdXJyZW50RGlyLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRyYWN0aW9uLCBhY3VtQXRyYWN0aW9uLCByZXB1bHNpb24sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVOZXVyb25hbE5ldHdvcmssXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQSwgbmV0UGFyZW50RXJyb3JXZWlnaHRBLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUIsIG5ldFBhcmVudEVycm9yV2VpZ2h0QixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1DLCBuZXRQYXJlbnRFcnJvcldlaWdodEMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRCwgbmV0UGFyZW50RXJyb3JXZWlnaHRELFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUUsIG5ldFBhcmVudEVycm9yV2VpZ2h0RSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1GLCBuZXRQYXJlbnRFcnJvcldlaWdodEYsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRywgbmV0UGFyZW50RXJyb3JXZWlnaHRHKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHJhY3Rpb24gPSBjYWxjUmVzcG9uc2UuYXRyYWN0aW9uO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdW1BdHJhY3Rpb24gPSBjYWxjUmVzcG9uc2UuYWN1bUF0cmFjdGlvbjtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXB1bHNpb24gPSBjYWxjUmVzcG9uc2UucmVwdWxzaW9uO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1BID0gY2FsY1Jlc3BvbnNlLm5ldENoaWxkSW5wdXRTdW1BO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QSA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvcldlaWdodEE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUIgPSBjYWxjUmVzcG9uc2UubmV0Q2hpbGRJbnB1dFN1bUI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRCID0gY2FsY1Jlc3BvbnNlLm5ldFBhcmVudEVycm9yV2VpZ2h0QjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQyA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtQztcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEMgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JXZWlnaHRDO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1EID0gY2FsY1Jlc3BvbnNlLm5ldENoaWxkSW5wdXRTdW1EO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RCA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvcldlaWdodEQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUUgPSBjYWxjUmVzcG9uc2UubmV0Q2hpbGRJbnB1dFN1bUU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRFID0gY2FsY1Jlc3BvbnNlLm5ldFBhcmVudEVycm9yV2VpZ2h0RTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRiA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtRjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEYgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JXZWlnaHRGO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1HID0gY2FsY1Jlc3BvbnNlLm5ldENoaWxkSW5wdXRTdW1HO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RyA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvcldlaWdodEc7XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FsY1Jlc3BvbnNlLmNvbGxpc2lvbkV4aXN0cyA9PSAxLjApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uRXhpc3RzID0gMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZSA9IGNhbGNSZXNwb25zZS5hdHJhY3Rpb247XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkaWVEYXRlICE9IDAuMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VGltZXN0YW1wIDwgYm9ybkRhdGUgfHwgY3VycmVudFRpbWVzdGFtcCA+IGRpZURhdGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmKGNvbGxpc2lvbkV4aXN0cyA9PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlICs9IChhdHJhY3Rpb24vYWN1bUF0cmFjdGlvbikqMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgZm9yY2UgKz0gKHJlcHVsc2lvbi9hY3VtQXRyYWN0aW9uKSoxLjA7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYoZW5hYmxlTmV1cm9uYWxOZXR3b3JrID09IDEuMCkge1xcbiAgICAgICAgICAgICAgICAgICAgXCIgKyBHcmFwaFV0aWxzLmVmZmVyZW50Tm9kZXNTdHIoZWZmZXJlbnRTdGFydCwgZWZmZXJlbnROb2Rlc0NvdW50KSArIFwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIGlkQWRqTWF0cml4UmVzcG9uc2UodmVjMyhmb3JjZSksIGNvbGxpc2lvbkV4aXN0cyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEEsIG5ldFBhcmVudEVycm9yV2VpZ2h0QSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEIsIG5ldFBhcmVudEVycm9yV2VpZ2h0QixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEMsIG5ldFBhcmVudEVycm9yV2VpZ2h0QyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEQsIG5ldFBhcmVudEVycm9yV2VpZ2h0RCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEUsIG5ldFBhcmVudEVycm9yV2VpZ2h0RSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEYsIG5ldFBhcmVudEVycm9yV2VpZ2h0RixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEcsIG5ldFBhcmVudEVycm9yV2VpZ2h0Ryk7XFxuICAgICAgICB9XCIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZWZmZXJlbnROb2Rlc1N0clwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZWZmZXJlbnROb2Rlc1N0cihlZmZlcmVudFN0YXJ0LCBlZmZlcmVudE5vZGVzQ291bnQpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIlxcbiAgICAgICAgICAgIGlmKG5vZGVJZCA8IGFmZmVyZW50Tm9kZXNDb3VudCkge1xcbiAgICAgICAgICAgICAgICBmb3IoZmxvYXQgbj0wLjA7IG4gPCAxMDI0LjA7IG4rPTEuMCkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYobiA+PSBhZmZlcmVudE5vZGVzQ291bnQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGlmKG5vZGVJZCA9PSBuKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEEgPSBhZmZlcmVudE5vZGVzQVtpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRCID0gYWZmZXJlbnROb2Rlc0JbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QyA9IGFmZmVyZW50Tm9kZXNDW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEQgPSBhZmZlcmVudE5vZGVzRFtpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRFID0gYWZmZXJlbnROb2Rlc0VbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RiA9IGFmZmVyZW50Tm9kZXNGW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEcgPSBhZmZlcmVudE5vZGVzR1tpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZm91dHB1dEEgPSBtYXgoMC4wLCBuZXRDaGlsZElucHV0U3VtQSk7IFwiICsgXCJcXG4gICAgICAgICAgICAgICAgZm91dHB1dEIgPSBtYXgoMC4wLCBuZXRDaGlsZElucHV0U3VtQik7XFxuICAgICAgICAgICAgICAgIGZvdXRwdXRDID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUMpO1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0RCA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1EKTtcXG4gICAgICAgICAgICAgICAgZm91dHB1dEUgPSBtYXgoMC4wLCBuZXRDaGlsZElucHV0U3VtRSk7XFxuICAgICAgICAgICAgICAgIGZvdXRwdXRGID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUYpO1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0RyA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1HKTtcXG4gICAgICAgICAgICB9XCI7XG5cbiAgICAgICAgICAgIHN0ciArPSBcIlxcbiAgICAgICAgaWYobm9kZUlkID09IFwiICsgZWZmZXJlbnRTdGFydC50b0ZpeGVkKDEpICsgKFwiKSB7XFxuICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRBID0gKGVmZmVyZW50Tm9kZXNBWzBdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtQS1lZmZlcmVudE5vZGVzQVswXSA6IDAuMDtcXG4gICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRCID0gKGVmZmVyZW50Tm9kZXNCWzBdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtQi1lZmZlcmVudE5vZGVzQlswXSA6IDAuMDtcXG4gICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRDID0gKGVmZmVyZW50Tm9kZXNDWzBdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtQy1lZmZlcmVudE5vZGVzQ1swXSA6IDAuMDtcXG4gICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHREID0gKGVmZmVyZW50Tm9kZXNEWzBdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtRC1lZmZlcmVudE5vZGVzRFswXSA6IDAuMDtcXG4gICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRFID0gKGVmZmVyZW50Tm9kZXNFWzBdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtRS1lZmZlcmVudE5vZGVzRVswXSA6IDAuMDtcXG4gICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRGID0gKGVmZmVyZW50Tm9kZXNGWzBdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtRi1lZmZlcmVudE5vZGVzRlswXSA6IDAuMDtcXG4gICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRHID0gKGVmZmVyZW50Tm9kZXNHWzBdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtRy1lZmZlcmVudE5vZGVzR1swXSA6IDAuMDtcXG4gICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICB9XCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IGVmZmVyZW50U3RhcnQgKyAxOyBuIDwgZWZmZXJlbnRTdGFydCArIGVmZmVyZW50Tm9kZXNDb3VudDsgbisrKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiXFxuICAgICAgICAgICAgZWxzZSBpZihub2RlSWQgPT0gXCIgKyBuLnRvRml4ZWQoMSkgKyBcIikge1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEEgPSAoZWZmZXJlbnROb2Rlc0FbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUEtZWZmZXJlbnROb2Rlc0FbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIChcIl0gOiAwLjA7XFxuICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRCID0gKGVmZmVyZW50Tm9kZXNCW1wiKSArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtQi1lZmZlcmVudE5vZGVzQltcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgKFwiXSA6IDAuMDtcXG4gICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEMgPSAoZWZmZXJlbnROb2Rlc0NbXCIpICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyBcIl0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1DLWVmZmVyZW50Tm9kZXNDW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAoXCJdIDogMC4wO1xcbiAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RCA9IChlZmZlcmVudE5vZGVzRFtcIikgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUQtZWZmZXJlbnROb2Rlc0RbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIChcIl0gOiAwLjA7XFxuICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRFID0gKGVmZmVyZW50Tm9kZXNFW1wiKSArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtRS1lZmZlcmVudE5vZGVzRVtcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgKFwiXSA6IDAuMDtcXG4gICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEYgPSAoZWZmZXJlbnROb2Rlc0ZbXCIpICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyBcIl0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1GLWVmZmVyZW50Tm9kZXNGW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAoXCJdIDogMC4wO1xcbiAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RyA9IChlZmZlcmVudE5vZGVzR1tcIikgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUctZWZmZXJlbnROb2Rlc0dbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIChcIl0gOiAwLjA7XFxuICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICB9XCIpO1xuICAgICAgICAgICAgfXN0ciArPSBcIlxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgaWYoZm91dHB1dEEgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QSA9IDAuMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYoZm91dHB1dEIgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IDAuMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYoZm91dHB1dEMgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QyA9IDAuMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYoZm91dHB1dEQgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RCA9IDAuMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYoZm91dHB1dEUgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IDAuMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYoZm91dHB1dEYgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RiA9IDAuMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYoZm91dHB1dEcgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RyA9IDAuMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XCI7XG5cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhZGpNYXRyaXhfQXV0b2xpbmtfR0xTTEZ1bmN0aW9uU3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGpNYXRyaXhfQXV0b2xpbmtfR0xTTEZ1bmN0aW9uU3RyaW5nKGdlb21ldHJ5TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyAnZmxvYXQgR2V0QW5nbGUodmVjMyBBLCB2ZWMzIEIpIHsnICsgLy8gZnJvbSAtMTgwLjAgdG8gMTgwLjBcbiAgICAgICAgICAgICd2ZWMzIGNyID0gY3Jvc3MoQSwgQik7JyArICdmbG9hdCBkID0gZG90KEEsIEIpOycgKyAnaWYoY3IueSA8IDAuMCkgeycgKyAnaWYoZCA+IDAuMCkgeycgKyAnZCA9ICAgICAgICAoMS4wLWQpKjkwLjA7JyArICd9IGVsc2UgeycgKyAnZCA9IDkwLjArICAoYWJzKGQpKjkwLjApOycgKyAnfScgKyAnfSBlbHNlIHsnICsgJ2lmKGQgPiAwLjApIHsnICsgJ2QgPSAyNzAuMCsgKGQqOTAuMCk7JyArICd9IGVsc2UgeycgKyAnZCA9IDE4MC4wKyAoKDEuMC1hYnMoZCkpKjkwLjApOycgKyAnfScgKyAnfScgKyAncmV0dXJuIGQ7JyArICd9JyArICd2ZWM0IGlkQWRqTWF0cml4X0F1dG9saW5rKGZsb2F0IG5vZGVJZCwgdmVjMyBjdXJyZW50UG9zKSB7XFxuJyArXG4gICAgICAgICAgICAvLyBJTklUIFZBUlNcbiAgICAgICAgICAgICd2ZWMyIHRvdGFsSURyZWxhdGlvbiA9IHZlYzIoMC4wLCAwLjApOycgKyAnZmxvYXQgdG90YWxBbmdsZVJlbGF0aW9ucyA9IDAuMDsnICtcbiAgICAgICAgICAgIC8vIEVORCBJTklUIFZBUlNcblxuICAgICAgICAgICAgJ2lmKG5vZGVJZCA8IG5vZGVzQ291bnQpIHtcXG4nICsgJ2ZvcihpbnQgbj0wOyBuIDwgNDA5NjsgbisrKSB7XFxuJyArICdpZihmbG9hdChuKSA+PSBub2Rlc0NvdW50KSBicmVhaztcXG4nICsgJ2lmKGZsb2F0KG4pICE9IG5vZGVJZCkgeycgKyAndmVjMiB4QWRqTWF0Q3VycmVudCA9IGdldF9nbG9iYWxfaWQodmVjMihmbG9hdChuKSwgbm9kZUlkKSwgd2lkdGhBZGpNYXRyaXgpOycgKyAndmVjNCBwaXhBZGpNYXRBQ3VycmVudCA9IGFkamFjZW5jeU1hdHJpeFt4QWRqTWF0Q3VycmVudF07XFxuJyArXG5cbiAgICAgICAgICAgIC8vIFJFTEFUSU9OIEZPVU5EXG4gICAgICAgICAgICAnaWYocGl4QWRqTWF0QUN1cnJlbnQueCA+IDAuMCkgeycgKyAndmVjMiB4R2VvbU9wcG9zaXRlID0gZ2V0X2dsb2JhbF9pZChmbG9hdChuKSwgdUJ1ZmZlcldpZHRoLCAnICsgZ2VvbWV0cnlMZW5ndGgudG9GaXhlZCgxKSArICcpO1xcbicgKyAndmVjMyBjdXJyZW50UG9zQiA9IHBvc1hZWldbeEdlb21PcHBvc2l0ZV0ueHl6O1xcbicgKyAndmVjMyBkaXJUb0JOID0gbm9ybWFsaXplKGN1cnJlbnRQb3NCLWN1cnJlbnRQb3MpO1xcbicgKyAndmVjMiBJRHJlbGF0aW9uID0gdmVjMigwLjAsIDAuMCk7JyArICdmbG9hdCBhbmdsZVJlbGF0aW9ucyA9IDM2MC4wOycgKyAnaWYobm9kZUlkIDwgbm9kZXNDb3VudCkge1xcbicgKyAnZm9yKGludCBuQj0wOyBuQiA8IDQwOTY7IG5CKyspIHtcXG4nICsgJ2lmKGZsb2F0KG5CKSA+PSBub2Rlc0NvdW50KSBicmVhaztcXG4nICsgJ2lmKGZsb2F0KG5CKSAhPSBmbG9hdChuKSAmJiBmbG9hdChuQikgIT0gbm9kZUlkKSB7JyArICd2ZWMyIHhBZGpNYXRDdXJyZW50QiA9IGdldF9nbG9iYWxfaWQodmVjMihmbG9hdChuQiksIG5vZGVJZCksIHdpZHRoQWRqTWF0cml4KTsnICsgJ3ZlYzQgcGl4QWRqTWF0QUN1cnJlbnRfQiA9IGFkamFjZW5jeU1hdHJpeFt4QWRqTWF0Q3VycmVudEJdO1xcbicgKyAnaWYocGl4QWRqTWF0QUN1cnJlbnRfQi54ID4gMC4wKSB7JyArICd2ZWMyIHhHZW9tX29wcG9CID0gZ2V0X2dsb2JhbF9pZChmbG9hdChuQiksIHVCdWZmZXJXaWR0aCwgJyArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyAnKTtcXG4nICsgJ3ZlYzMgY3VycmVudFBvc0JCID0gcG9zWFlaV1t4R2VvbV9vcHBvQl0ueHl6O1xcbicgKyAndmVjMyBkaXJUb0JCTiA9IG5vcm1hbGl6ZShjdXJyZW50UG9zQkItY3VycmVudFBvcyk7XFxuJyArICdmbG9hdCBhbmdsZSA9IEdldEFuZ2xlKGRpclRvQk4sZGlyVG9CQk4pOycgKyAnaWYoYW5nbGUgPiAwLjAgJiYgYW5nbGUgPCBhbmdsZVJlbGF0aW9ucykgeycgKyAnSURyZWxhdGlvbiA9IHhHZW9tX29wcG9COycgKyAnYW5nbGVSZWxhdGlvbnMgPSBhbmdsZTsnICsgJ30nICsgJ30nICsgJ30nICsgJ30nICsgJ30nICsgJ2lmKGFuZ2xlUmVsYXRpb25zIDwgMzYwLjAgJiYgYW5nbGVSZWxhdGlvbnMgPiB0b3RhbEFuZ2xlUmVsYXRpb25zKSB7JyArICd0b3RhbElEcmVsYXRpb24gPSBJRHJlbGF0aW9uOycgKyAndG90YWxBbmdsZVJlbGF0aW9ucyA9IGFuZ2xlUmVsYXRpb25zOycgKyAnfScgKyAnfScgK1xuICAgICAgICAgICAgLy8gRU5EIFJFTEFUSU9OIEZPVU5EXG5cbiAgICAgICAgICAgICd9JyArICd9JyArXG4gICAgICAgICAgICAvLyBTVU1NQVRJT05cbiAgICAgICAgICAgIC8vIEVORCBTVU1NQVRJT05cblxuICAgICAgICAgICAgJ30nICsgJ3JldHVybiB2ZWM0KHRvdGFsSURyZWxhdGlvbiwgdG90YWxBbmdsZVJlbGF0aW9ucywgMC4wKTsnICsgJ30nO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEdyYXBoVXRpbHM7XG59KCk7XG5cbmdsb2JhbC5HcmFwaFV0aWxzID0gR3JhcGhVdGlscztcbm1vZHVsZS5leHBvcnRzLkdyYXBoVXRpbHMgPSBHcmFwaFV0aWxzOyJdfQ==
