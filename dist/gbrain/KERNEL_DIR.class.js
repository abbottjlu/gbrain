(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var KERNEL_DIR = exports.KERNEL_DIR = function () {
    function KERNEL_DIR() {
        _classCallCheck(this, KERNEL_DIR);
    }

    _createClass(KERNEL_DIR, null, [{
        key: "getSrc",
        value: function getSrc(customCode, geometryLength, afferentNodesCount, efferentStart, efferentNodesCount) {
            var outputArr = ["dir", "posXYZW", "dataB", "dataF", "dataG", "dataH"];
            var returnStr = 'return [vec4(currentDir, 1.0), vec4(currentPos.x, currentPos.y, currentPos.z, 1.0), currentDataB, currentDataF, currentDataG, currentDataH];';

            return ["x", outputArr,
            // head
            "",

            // source
            "float nodeId = data[x].x;\n            vec2 xGeometry = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n            vec3 currentPos = posXYZW[xGeometry].xyz;\n            vec3 currentDir = dir[xGeometry].xyz;\n\n\n            vec4 currentDataB = dataB[xGeometry];\n            vec4 currentDataF = dataF[xGeometry];\n            vec4 currentDataG = dataG[xGeometry];\n            vec4 currentDataH = dataH[xGeometry];\n\n            currentDir = vec3(0.0, 0.0, 0.0);\n\n            \n            vec3 atraction = vec3(0.0, 0.0, 0.0);\n            float acumAtraction = 1.0;\n            vec3 repulsion = vec3(0.0, 0.0, 0.0);\n\n            vec3 force = vec3(0.0, 0.0, 0.0);\n\n\n            float netChildInputSumA = 0.0;\n            float foutputA = 0.0;\n            float netParentErrorWeightA = 0.0;\n            \n            float netChildInputSumB = 0.0;\n            float foutputB = 0.0;\n            float netParentErrorWeightB = 0.0;\n            \n            float netChildInputSumC = 0.0;\n            float foutputC = 0.0;\n            float netParentErrorWeightC = 0.0;\n            \n            float netChildInputSumD = 0.0;\n            float foutputD = 0.0;\n            float netParentErrorWeightD = 0.0;\n            \n            float netChildInputSumE = 0.0;\n            float foutputE = 0.0;\n            float netParentErrorWeightE = 0.0;\n            \n            float netChildInputSumF = 0.0;\n            float foutputF = 0.0;\n            float netParentErrorWeightF = 0.0;\n            \n            float netChildInputSumG = 0.0;\n            float foutputG = 0.0;\n            float netParentErrorWeightG = 0.0;\n            \n\n            if(nodeId < nodesCount && enableTrain == 0.0) {\n                float currentActivationFn = 0.0;\n                vec2 xGeomCurrent = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n                for(int n=0; n < 4096; n++) {\n                    if(float(n) >= nodesCount) {break;}\n                    if(float(n) != nodeId) {\n                        vec2 xGeomOpposite = get_global_id(float(n), uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n                        vec2 xAdjMatCurrent = get_global_id(vec2(float(n), nodeId), widthAdjMatrix);\n                        vec2 xAdjMatOpposite = get_global_id(vec2(nodeId, float(n)), widthAdjMatrix);\n\n                        vec4 pixAdjMatACurrent = adjacencyMatrix[xAdjMatCurrent];\n                        vec4 pixAdjMatAOpposite = adjacencyMatrix[xAdjMatOpposite];\n\n                        vec4 pixAdjMatBCurrent = adjacencyMatrixB[xAdjMatCurrent];\n                        vec4 pixAdjMatBOpposite = adjacencyMatrixB[xAdjMatOpposite];\n\n\n                                                                    \n                        " + "\n                        float currentWeight = pixAdjMatACurrent.z;\n                        float currentIsParent = pixAdjMatACurrent.w;\n            \n                        " + "\n                        float oppositeWeight = pixAdjMatAOpposite.z;\n                        float oppositeIsParent = pixAdjMatAOpposite.w;\n            \n            \n                        " + "\n                        float currentLinkMultiplier = pixAdjMatBCurrent.x;\n                        float currentActivationFn = pixAdjMatBCurrent.y;\n            \n                        " + "\n                        float oppositeLinkMultiplier = pixAdjMatBOpposite.x;\n                        float oppositeActivationFn = pixAdjMatBOpposite.y;\n            \n            \n                        " + "\n                        " + "\n                        " + "\n                        " + "\n            \n                        " + "\n                        float oppositeBiasNode = dataB[xGeomOpposite].x;\n                        float oppositeNetOutputA = dataB[xGeomOpposite].z;\n                        float oppositeNetErrorA = dataB[xGeomOpposite].w;\n            \n                        float oppositeNetOutputB = dataF[xGeomOpposite].x;\n                        float oppositeNetErrorB = dataF[xGeomOpposite].y;\n                    \n                        float oppositeNetOutputC = dataF[xGeomOpposite].z;\n                        float oppositeNetErrorC = dataF[xGeomOpposite].w;\n                    \n                        float oppositeNetOutputD = dataG[xGeomOpposite].x;\n                        float oppositeNetErrorD = dataG[xGeomOpposite].y;\n                    \n                        float oppositeNetOutputE = dataG[xGeomOpposite].z;\n                        float oppositeNetErrorE = dataG[xGeomOpposite].w;\n                    \n                        float oppositeNetOutputF = dataH[xGeomOpposite].x;\n                        float oppositeNetErrorF = dataH[xGeomOpposite].y;\n                    \n                        float oppositeNetOutputG = dataH[xGeomOpposite].z;\n                        float oppositeNetErrorG = dataH[xGeomOpposite].w;\n            \n            \n                        " + "\n                        " + "\n                        " + "\n            \n                        " + "\n                        vec3 oppositePos = posXYZW[xGeomOpposite].xyz;\n                        vec3 oppositeDir = dir[xGeomOpposite].xyz;\n            \n                        " + "\n                        vec3 dirToOpposite = (oppositePos-currentPos);\n                        vec3 dirToOppositeN = normalize(dirToOpposite);\n            \n                        float dist = distance(oppositePos, currentPos); " + "\n                        float distN = max(0.0,dist)/100000.0;\n            \n                        float mm = 30.0;\n                        float m1 = 400000.0/mm;\n                        float m2 = 48.0/mm;\n                        if(currentIsParent == 1.0) {\n                            if(oppositeBiasNode == 0.0) {\n                                netChildInputSumA += oppositeNetOutputA*oppositeWeight;\n                                netChildInputSumB += oppositeNetOutputB*oppositeWeight;\n                                netChildInputSumC += oppositeNetOutputC*oppositeWeight;\n                                netChildInputSumD += oppositeNetOutputD*oppositeWeight;\n                                netChildInputSumE += oppositeNetOutputE*oppositeWeight;\n                                netChildInputSumF += oppositeNetOutputF*oppositeWeight;\n                                netChildInputSumG += oppositeNetOutputG*oppositeWeight;\n                            } else {\n                                netChildInputSumA += oppositeWeight;\n                                netChildInputSumB += oppositeWeight;\n                                netChildInputSumC += oppositeWeight;\n                                netChildInputSumD += oppositeWeight;\n                                netChildInputSumE += oppositeWeight;\n                                netChildInputSumF += oppositeWeight;\n                                netChildInputSumG += oppositeWeight;\n                            }\n                            atraction += dirToOppositeN*max(1.0, distN*abs(oppositeWeight)*(m1/2.0));\n                            repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(oppositeWeight)*(m2/2.0));\n                            acumAtraction += 1.0;\n                        } else if(currentIsParent == 0.5) {\n                            if(oppositeBiasNode == 0.0) {\n                                netParentErrorWeightA += oppositeNetErrorA*currentWeight;\n                                netParentErrorWeightB += oppositeNetErrorB*currentWeight;\n                                netParentErrorWeightC += oppositeNetErrorC*currentWeight;\n                                netParentErrorWeightD += oppositeNetErrorD*currentWeight;\n                                netParentErrorWeightE += oppositeNetErrorE*currentWeight;\n                                netParentErrorWeightF += oppositeNetErrorF*currentWeight;\n                                netParentErrorWeightG += oppositeNetErrorG*currentWeight;\n                            } else {\n                                netParentErrorWeightA += oppositeNetErrorA;\n                                netParentErrorWeightB += oppositeNetErrorB;\n                                netParentErrorWeightC += oppositeNetErrorC;\n                                netParentErrorWeightD += oppositeNetErrorD;\n                                netParentErrorWeightE += oppositeNetErrorE;\n                                netParentErrorWeightF += oppositeNetErrorF;\n                                netParentErrorWeightG += oppositeNetErrorG;\n                            }\n                            atraction += dirToOppositeN*max(1.0, distN*abs(currentWeight)*m1);\n                            repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*m2);\n                            acumAtraction += 1.0;\n                        }\n            \n                        repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*(m2/8.0));\n                        acumAtraction += 1.0;\n                    }\n                }\n                force += (atraction/acumAtraction);\n                force += (repulsion/acumAtraction);\n                currentDir += force;\n                \n                \n                float currentBiasNode = dataB[xGeomCurrent].x;\n                \n                " + KERNEL_DIR.efferentNodesStr(afferentNodesCount, efferentStart, efferentNodesCount) + "\n                \n                currentDataB = vec4(currentDataB.x, currentDataB.y, foutputA, netParentErrorWeightA);\n                currentDataF = vec4(foutputB, netParentErrorWeightB, foutputC, netParentErrorWeightC);\n                currentDataG = vec4(foutputD, netParentErrorWeightD, foutputE, netParentErrorWeightE);\n                currentDataH = vec4(foutputF, netParentErrorWeightF, foutputG, netParentErrorWeightG);\n            }\n\n            " + (customCode !== undefined ? customCode : '') + "\n\n            if(enableDrag == 1.0) {\n                if(nodeId == idToDrag) {\n                    currentPos = vec3(MouseDragTranslationX, MouseDragTranslationY, MouseDragTranslationZ);\n                }\n            }\n\n            currentPos += currentDir;\n            if(only2d == 1.0) {\n                currentPos.y = 0.0;\n            }\n\n            " + returnStr];
        }
    }, {
        key: "efferentNodesStr",
        value: function efferentNodesStr(afferentNodesCount, efferentStart, efferentNodesCount) {
            /////////////////////////////////////////////////
            // OUTPUT
            /////////////////////////////////////////////////
            var str = "\n            if(nodeId < afferentNodesCount) {\n                for(float n=0.0; n < 1024.0; n+=1.0) {\n                    if(n >= afferentNodesCount) {\n                        break;\n                    }\n                    if(nodeId == n) {\n                        foutputA = afferentNodesA[int(n)];\n                        foutputB = afferentNodesB[int(n)];\n                        foutputC = afferentNodesC[int(n)];\n                        foutputD = afferentNodesD[int(n)];\n                        foutputE = afferentNodesE[int(n)];\n                        foutputF = afferentNodesF[int(n)];\n                        foutputG = afferentNodesG[int(n)];\n                        break;\n                    }\n                }\n            } else {\n                if(currentBiasNode == 0.0) {                                     \n                    foutputA = max(0.0, netChildInputSumA); " + "\n                    foutputB = max(0.0, netChildInputSumB);\n                    foutputC = max(0.0, netChildInputSumC);\n                    foutputD = max(0.0, netChildInputSumD);\n                    foutputE = max(0.0, netChildInputSumE);\n                    foutputF = max(0.0, netChildInputSumF);\n                    foutputG = max(0.0, netChildInputSumG);\n                } else {\n                    foutputA = 1.0;\n                    foutputB = 1.0;\n                    foutputC = 1.0;\n                    foutputD = 1.0;\n                    foutputE = 1.0;\n                    foutputF = 1.0;\n                    foutputG = 1.0;\n                }\n            }";

            /////////////////////////////////////////////////
            // ERROR
            /////////////////////////////////////////////////
            for (var n = efferentStart; n < efferentStart + efferentNodesCount; n++) {
                var cond = n === efferentStart ? "if" : "else if";
                str += "\n            " + cond + "(nodeId == " + n.toFixed(1) + ") {\n                netParentErrorWeightA = (efferentNodesA[" + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumA-efferentNodesA[" + Math.round(n - efferentStart) + "] : 0.0;\n                netParentErrorWeightB = (efferentNodesB[" + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumB-efferentNodesB[" + Math.round(n - efferentStart) + "] : 0.0;\n                netParentErrorWeightC = (efferentNodesC[" + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumC-efferentNodesC[" + Math.round(n - efferentStart) + "] : 0.0;\n                netParentErrorWeightD = (efferentNodesD[" + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumD-efferentNodesD[" + Math.round(n - efferentStart) + "] : 0.0;\n                netParentErrorWeightE = (efferentNodesE[" + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumE-efferentNodesE[" + Math.round(n - efferentStart) + "] : 0.0;\n                netParentErrorWeightF = (efferentNodesF[" + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumF-efferentNodesF[" + Math.round(n - efferentStart) + "] : 0.0;\n                netParentErrorWeightG = (efferentNodesG[" + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumG-efferentNodesG[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                " + "\n                " + "\n                " + "\n                " + "\n                " + "\n                " + "\n            }");
            }
            str += "\n        else {\n            if(currentBiasNode == 0.0) {\n                if(foutputA <= 0.0) {\n                    netParentErrorWeightA = 0.0;\n                }\n                if(foutputB <= 0.0) {\n                    netParentErrorWeightB = 0.0;\n                }\n                if(foutputC <= 0.0) {\n                    netParentErrorWeightC = 0.0;\n                }\n                if(foutputD <= 0.0) {\n                    netParentErrorWeightD = 0.0;\n                }\n                if(foutputE <= 0.0) {\n                    netParentErrorWeightE = 0.0;\n                }\n                if(foutputF <= 0.0) {\n                    netParentErrorWeightF = 0.0;\n                }\n                if(foutputG <= 0.0) {\n                    netParentErrorWeightG = 0.0;\n                }\n            }\n        }";

            return str;
        }
    }, {
        key: "adjMatrix_ForceLayout_GLSLFunctionString",
        value: function adjMatrix_ForceLayout_GLSLFunctionString() {
            return "\n        float tanh(float val) {\n            float tmp = exp(val);\n            float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n            return tanH;\n        }\n        float sigm(float val) {\n            return (1.0 / (1.0 + exp(-val)));\n        }";
        }
    }]);

    return KERNEL_DIR;
}();

global.KERNEL_DIR = KERNEL_DIR;
module.exports.KERNEL_DIR = KERNEL_DIR;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZ2JyYWluL0tFUk5FTF9ESVIuY2xhc3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEtFUk5FTF9ESVIgPSBleHBvcnRzLktFUk5FTF9ESVIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gS0VSTkVMX0RJUigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtFUk5FTF9ESVIpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhLRVJORUxfRElSLCBudWxsLCBbe1xuICAgICAgICBrZXk6IFwiZ2V0U3JjXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTcmMoY3VzdG9tQ29kZSwgZ2VvbWV0cnlMZW5ndGgsIGFmZmVyZW50Tm9kZXNDb3VudCwgZWZmZXJlbnRTdGFydCwgZWZmZXJlbnROb2Rlc0NvdW50KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0QXJyID0gW1wiZGlyXCIsIFwicG9zWFlaV1wiLCBcImRhdGFCXCIsIFwiZGF0YUZcIiwgXCJkYXRhR1wiLCBcImRhdGFIXCJdO1xuICAgICAgICAgICAgdmFyIHJldHVyblN0ciA9ICdyZXR1cm4gW3ZlYzQoY3VycmVudERpciwgMS4wKSwgdmVjNChjdXJyZW50UG9zLngsIGN1cnJlbnRQb3MueSwgY3VycmVudFBvcy56LCAxLjApLCBjdXJyZW50RGF0YUIsIGN1cnJlbnREYXRhRiwgY3VycmVudERhdGFHLCBjdXJyZW50RGF0YUhdOyc7XG5cbiAgICAgICAgICAgIHJldHVybiBbXCJ4XCIsIG91dHB1dEFycixcbiAgICAgICAgICAgIC8vIGhlYWRcbiAgICAgICAgICAgIFwiXCIsXG5cbiAgICAgICAgICAgIC8vIHNvdXJjZVxuICAgICAgICAgICAgXCJmbG9hdCBub2RlSWQgPSBkYXRhW3hdLng7XFxuICAgICAgICAgICAgdmVjMiB4R2VvbWV0cnkgPSBnZXRfZ2xvYmFsX2lkKG5vZGVJZCwgdUJ1ZmZlcldpZHRoLCBcIiArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyBcIik7XFxuXFxuXFxuICAgICAgICAgICAgdmVjMyBjdXJyZW50UG9zID0gcG9zWFlaV1t4R2VvbWV0cnldLnh5ejtcXG4gICAgICAgICAgICB2ZWMzIGN1cnJlbnREaXIgPSBkaXJbeEdlb21ldHJ5XS54eXo7XFxuXFxuXFxuICAgICAgICAgICAgdmVjNCBjdXJyZW50RGF0YUIgPSBkYXRhQlt4R2VvbWV0cnldO1xcbiAgICAgICAgICAgIHZlYzQgY3VycmVudERhdGFGID0gZGF0YUZbeEdlb21ldHJ5XTtcXG4gICAgICAgICAgICB2ZWM0IGN1cnJlbnREYXRhRyA9IGRhdGFHW3hHZW9tZXRyeV07XFxuICAgICAgICAgICAgdmVjNCBjdXJyZW50RGF0YUggPSBkYXRhSFt4R2VvbWV0cnldO1xcblxcbiAgICAgICAgICAgIGN1cnJlbnREaXIgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcblxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHZlYzMgYXRyYWN0aW9uID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgICAgICBmbG9hdCBhY3VtQXRyYWN0aW9uID0gMS4wO1xcbiAgICAgICAgICAgIHZlYzMgcmVwdWxzaW9uID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXG4gICAgICAgICAgICB2ZWMzIGZvcmNlID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXG5cXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQSA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0QSA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEEgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUIgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEIgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRCID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1DID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRDID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QyA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRCA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0RCA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEQgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUUgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEUgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRFID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1GID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRGID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RiA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRyA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0RyA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEcgPSAwLjA7XFxuICAgICAgICAgICAgXFxuXFxuICAgICAgICAgICAgaWYobm9kZUlkIDwgbm9kZXNDb3VudCAmJiBlbmFibGVUcmFpbiA9PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudEFjdGl2YXRpb25GbiA9IDAuMDtcXG4gICAgICAgICAgICAgICAgdmVjMiB4R2VvbUN1cnJlbnQgPSBnZXRfZ2xvYmFsX2lkKG5vZGVJZCwgdUJ1ZmZlcldpZHRoLCBcIiArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyBcIik7XFxuICAgICAgICAgICAgICAgIGZvcihpbnQgbj0wOyBuIDwgNDA5NjsgbisrKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZihmbG9hdChuKSA+PSBub2Rlc0NvdW50KSB7YnJlYWs7fVxcbiAgICAgICAgICAgICAgICAgICAgaWYoZmxvYXQobikgIT0gbm9kZUlkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMiB4R2VvbU9wcG9zaXRlID0gZ2V0X2dsb2JhbF9pZChmbG9hdChuKSwgdUJ1ZmZlcldpZHRoLCBcIiArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyBcIik7XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMiB4QWRqTWF0Q3VycmVudCA9IGdldF9nbG9iYWxfaWQodmVjMihmbG9hdChuKSwgbm9kZUlkKSwgd2lkdGhBZGpNYXRyaXgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIgeEFkak1hdE9wcG9zaXRlID0gZ2V0X2dsb2JhbF9pZCh2ZWMyKG5vZGVJZCwgZmxvYXQobikpLCB3aWR0aEFkak1hdHJpeCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRBQ3VycmVudCA9IGFkamFjZW5jeU1hdHJpeFt4QWRqTWF0Q3VycmVudF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRBT3Bwb3NpdGUgPSBhZGphY2VuY3lNYXRyaXhbeEFkak1hdE9wcG9zaXRlXTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEJDdXJyZW50ID0gYWRqYWNlbmN5TWF0cml4Qlt4QWRqTWF0Q3VycmVudF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRCT3Bwb3NpdGUgPSBhZGphY2VuY3lNYXRyaXhCW3hBZGpNYXRPcHBvc2l0ZV07XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudFdlaWdodCA9IHBpeEFkak1hdEFDdXJyZW50Lno7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudElzUGFyZW50ID0gcGl4QWRqTWF0QUN1cnJlbnQudztcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVXZWlnaHQgPSBwaXhBZGpNYXRBT3Bwb3NpdGUuejtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUlzUGFyZW50ID0gcGl4QWRqTWF0QU9wcG9zaXRlLnc7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGN1cnJlbnRMaW5rTXVsdGlwbGllciA9IHBpeEFkak1hdEJDdXJyZW50Lng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY3VycmVudEFjdGl2YXRpb25GbiA9IHBpeEFkak1hdEJDdXJyZW50Lnk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTGlua011bHRpcGxpZXIgPSBwaXhBZGpNYXRCT3Bwb3NpdGUueDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUFjdGl2YXRpb25GbiA9IHBpeEFkak1hdEJPcHBvc2l0ZS55O1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVCaWFzTm9kZSA9IGRhdGFCW3hHZW9tT3Bwb3NpdGVdLng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRBID0gZGF0YUJbeEdlb21PcHBvc2l0ZV0uejtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yQSA9IGRhdGFCW3hHZW9tT3Bwb3NpdGVdLnc7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRCID0gZGF0YUZbeEdlb21PcHBvc2l0ZV0ueDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yQiA9IGRhdGFGW3hHZW9tT3Bwb3NpdGVdLnk7XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEMgPSBkYXRhRlt4R2VvbU9wcG9zaXRlXS56O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0RXJyb3JDID0gZGF0YUZbeEdlb21PcHBvc2l0ZV0udztcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0RCA9IGRhdGFHW3hHZW9tT3Bwb3NpdGVdLng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckQgPSBkYXRhR1t4R2VvbU9wcG9zaXRlXS55O1xcbiAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRFID0gZGF0YUdbeEdlb21PcHBvc2l0ZV0uejtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yRSA9IGRhdGFHW3hHZW9tT3Bwb3NpdGVdLnc7XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEYgPSBkYXRhSFt4R2VvbU9wcG9zaXRlXS54O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0RXJyb3JGID0gZGF0YUhbeEdlb21PcHBvc2l0ZV0ueTtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0RyA9IGRhdGFIW3hHZW9tT3Bwb3NpdGVdLno7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckcgPSBkYXRhSFt4R2VvbU9wcG9zaXRlXS53O1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMzIG9wcG9zaXRlUG9zID0gcG9zWFlaV1t4R2VvbU9wcG9zaXRlXS54eXo7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyBvcHBvc2l0ZURpciA9IGRpclt4R2VvbU9wcG9zaXRlXS54eXo7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgZGlyVG9PcHBvc2l0ZSA9IChvcHBvc2l0ZVBvcy1jdXJyZW50UG9zKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMzIGRpclRvT3Bwb3NpdGVOID0gbm9ybWFsaXplKGRpclRvT3Bwb3NpdGUpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGRpc3QgPSBkaXN0YW5jZShvcHBvc2l0ZVBvcywgY3VycmVudFBvcyk7IFwiICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkaXN0TiA9IG1heCgwLjAsZGlzdCkvMTAwMDAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbW0gPSAzMC4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG0xID0gNDAwMDAwLjAvbW07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbTIgPSA0OC4wL21tO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRJc1BhcmVudCA9PSAxLjApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob3Bwb3NpdGVCaWFzTm9kZSA9PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1BICs9IG9wcG9zaXRlTmV0T3V0cHV0QSpvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1CICs9IG9wcG9zaXRlTmV0T3V0cHV0QipvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1DICs9IG9wcG9zaXRlTmV0T3V0cHV0QypvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1EICs9IG9wcG9zaXRlTmV0T3V0cHV0RCpvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1FICs9IG9wcG9zaXRlTmV0T3V0cHV0RSpvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1GICs9IG9wcG9zaXRlTmV0T3V0cHV0RipvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1HICs9IG9wcG9zaXRlTmV0T3V0cHV0RypvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1BICs9IG9wcG9zaXRlV2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUIgKz0gb3Bwb3NpdGVXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQyArPSBvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1EICs9IG9wcG9zaXRlV2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUUgKz0gb3Bwb3NpdGVXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRiArPSBvcHBvc2l0ZVdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1HICs9IG9wcG9zaXRlV2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0cmFjdGlvbiArPSBkaXJUb09wcG9zaXRlTiptYXgoMS4wLCBkaXN0TiphYnMob3Bwb3NpdGVXZWlnaHQpKihtMS8yLjApKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwdWxzaW9uICs9IC1kaXJUb09wcG9zaXRlTiptYXgoMS4wLCAoMS4wLWRpc3ROKSphYnMob3Bwb3NpdGVXZWlnaHQpKihtMi8yLjApKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN1bUF0cmFjdGlvbiArPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGN1cnJlbnRJc1BhcmVudCA9PSAwLjUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob3Bwb3NpdGVCaWFzTm9kZSA9PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QSArPSBvcHBvc2l0ZU5ldEVycm9yQSpjdXJyZW50V2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRCICs9IG9wcG9zaXRlTmV0RXJyb3JCKmN1cnJlbnRXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEMgKz0gb3Bwb3NpdGVOZXRFcnJvckMqY3VycmVudFdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RCArPSBvcHBvc2l0ZU5ldEVycm9yRCpjdXJyZW50V2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRFICs9IG9wcG9zaXRlTmV0RXJyb3JFKmN1cnJlbnRXZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEYgKz0gb3Bwb3NpdGVOZXRFcnJvckYqY3VycmVudFdlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RyArPSBvcHBvc2l0ZU5ldEVycm9yRypjdXJyZW50V2VpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRBICs9IG9wcG9zaXRlTmV0RXJyb3JBO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRCICs9IG9wcG9zaXRlTmV0RXJyb3JCO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRDICs9IG9wcG9zaXRlTmV0RXJyb3JDO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHREICs9IG9wcG9zaXRlTmV0RXJyb3JEO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRFICs9IG9wcG9zaXRlTmV0RXJyb3JFO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRGICs9IG9wcG9zaXRlTmV0RXJyb3JGO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRHICs9IG9wcG9zaXRlTmV0RXJyb3JHO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0cmFjdGlvbiArPSBkaXJUb09wcG9zaXRlTiptYXgoMS4wLCBkaXN0TiphYnMoY3VycmVudFdlaWdodCkqbTEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXB1bHNpb24gKz0gLWRpclRvT3Bwb3NpdGVOKm1heCgxLjAsICgxLjAtZGlzdE4pKmFicyhjdXJyZW50V2VpZ2h0KSptMik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdW1BdHJhY3Rpb24gKz0gMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXB1bHNpb24gKz0gLWRpclRvT3Bwb3NpdGVOKm1heCgxLjAsICgxLjAtZGlzdE4pKmFicyhjdXJyZW50V2VpZ2h0KSoobTIvOC4wKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN1bUF0cmFjdGlvbiArPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZm9yY2UgKz0gKGF0cmFjdGlvbi9hY3VtQXRyYWN0aW9uKTtcXG4gICAgICAgICAgICAgICAgZm9yY2UgKz0gKHJlcHVsc2lvbi9hY3VtQXRyYWN0aW9uKTtcXG4gICAgICAgICAgICAgICAgY3VycmVudERpciArPSBmb3JjZTtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBmbG9hdCBjdXJyZW50Qmlhc05vZGUgPSBkYXRhQlt4R2VvbUN1cnJlbnRdLng7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBcIiArIEtFUk5FTF9ESVIuZWZmZXJlbnROb2Rlc1N0cihhZmZlcmVudE5vZGVzQ291bnQsIGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkgKyBcIlxcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGFCID0gdmVjNChjdXJyZW50RGF0YUIueCwgY3VycmVudERhdGFCLnksIGZvdXRwdXRBLCBuZXRQYXJlbnRFcnJvcldlaWdodEEpO1xcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0YUYgPSB2ZWM0KGZvdXRwdXRCLCBuZXRQYXJlbnRFcnJvcldlaWdodEIsIGZvdXRwdXRDLCBuZXRQYXJlbnRFcnJvcldlaWdodEMpO1xcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0YUcgPSB2ZWM0KGZvdXRwdXRELCBuZXRQYXJlbnRFcnJvcldlaWdodEQsIGZvdXRwdXRFLCBuZXRQYXJlbnRFcnJvcldlaWdodEUpO1xcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0YUggPSB2ZWM0KGZvdXRwdXRGLCBuZXRQYXJlbnRFcnJvcldlaWdodEYsIGZvdXRwdXRHLCBuZXRQYXJlbnRFcnJvcldlaWdodEcpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBcIiArIChjdXN0b21Db2RlICE9PSB1bmRlZmluZWQgPyBjdXN0b21Db2RlIDogJycpICsgXCJcXG5cXG4gICAgICAgICAgICBpZihlbmFibGVEcmFnID09IDEuMCkge1xcbiAgICAgICAgICAgICAgICBpZihub2RlSWQgPT0gaWRUb0RyYWcpIHtcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSB2ZWMzKE1vdXNlRHJhZ1RyYW5zbGF0aW9uWCwgTW91c2VEcmFnVHJhbnNsYXRpb25ZLCBNb3VzZURyYWdUcmFuc2xhdGlvblopO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gY3VycmVudERpcjtcXG4gICAgICAgICAgICBpZihvbmx5MmQgPT0gMS4wKSB7XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MueSA9IDAuMDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgXCIgKyByZXR1cm5TdHJdO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZWZmZXJlbnROb2Rlc1N0clwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZWZmZXJlbnROb2Rlc1N0cihhZmZlcmVudE5vZGVzQ291bnQsIGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkge1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gT1VUUFVUXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICB2YXIgc3RyID0gXCJcXG4gICAgICAgICAgICBpZihub2RlSWQgPCBhZmZlcmVudE5vZGVzQ291bnQpIHtcXG4gICAgICAgICAgICAgICAgZm9yKGZsb2F0IG49MC4wOyBuIDwgMTAyNC4wOyBuKz0xLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmKG4gPj0gYWZmZXJlbnROb2Rlc0NvdW50KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBpZihub2RlSWQgPT0gbikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRBID0gYWZmZXJlbnROb2Rlc0FbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QiA9IGFmZmVyZW50Tm9kZXNCW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEMgPSBhZmZlcmVudE5vZGVzQ1tpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXREID0gYWZmZXJlbnROb2Rlc0RbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RSA9IGFmZmVyZW50Tm9kZXNFW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEYgPSBhZmZlcmVudE5vZGVzRltpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRHID0gYWZmZXJlbnROb2Rlc0dbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRCaWFzTm9kZSA9PSAwLjApIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QSA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1BKTsgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEIgPSBtYXgoMC4wLCBuZXRDaGlsZElucHV0U3VtQik7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QyA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1DKTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXREID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUQpO1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEUgPSBtYXgoMC4wLCBuZXRDaGlsZElucHV0U3VtRSk7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RiA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1GKTtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRHID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUcpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEEgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QiA9IDEuMDtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRDID0gMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEQgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RSA9IDEuMDtcXG4gICAgICAgICAgICAgICAgICAgIGZvdXRwdXRGID0gMS4wO1xcbiAgICAgICAgICAgICAgICAgICAgZm91dHB1dEcgPSAxLjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XCI7XG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIEVSUk9SXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICBmb3IgKHZhciBuID0gZWZmZXJlbnRTdGFydDsgbiA8IGVmZmVyZW50U3RhcnQgKyBlZmZlcmVudE5vZGVzQ291bnQ7IG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBjb25kID0gbiA9PT0gZWZmZXJlbnRTdGFydCA/IFwiaWZcIiA6IFwiZWxzZSBpZlwiO1xuICAgICAgICAgICAgICAgIHN0ciArPSBcIlxcbiAgICAgICAgICAgIFwiICsgY29uZCArIFwiKG5vZGVJZCA9PSBcIiArIG4udG9GaXhlZCgxKSArIFwiKSB7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QSA9IChlZmZlcmVudE5vZGVzQVtcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtQS1lZmZlcmVudE5vZGVzQVtcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdIDogMC4wO1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEIgPSAoZWZmZXJlbnROb2Rlc0JbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUItZWZmZXJlbnROb2Rlc0JbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXSA6IDAuMDtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRDID0gKGVmZmVyZW50Tm9kZXNDW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyBcIl0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1DLWVmZmVyZW50Tm9kZXNDW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyBcIl0gOiAwLjA7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RCA9IChlZmZlcmVudE5vZGVzRFtcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtRC1lZmZlcmVudE5vZGVzRFtcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdIDogMC4wO1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEUgPSAoZWZmZXJlbnROb2Rlc0VbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUUtZWZmZXJlbnROb2Rlc0VbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXSA6IDAuMDtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRGID0gKGVmZmVyZW50Tm9kZXNGW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyBcIl0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1GLWVmZmVyZW50Tm9kZXNGW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyBcIl0gOiAwLjA7XFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RyA9IChlZmZlcmVudE5vZGVzR1tcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtRy1lZmZlcmVudE5vZGVzR1tcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgKFwiXSA6IDAuMDtcXG4gICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgIH1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgKz0gXCJcXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGlmKGN1cnJlbnRCaWFzTm9kZSA9PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgaWYoZm91dHB1dEEgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEEgPSAwLjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYoZm91dHB1dEIgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEIgPSAwLjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYoZm91dHB1dEMgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEMgPSAwLjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYoZm91dHB1dEQgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEQgPSAwLjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYoZm91dHB1dEUgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEUgPSAwLjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYoZm91dHB1dEYgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEYgPSAwLjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYoZm91dHB1dEcgPD0gMC4wKSB7XFxuICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEcgPSAwLjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XCI7XG5cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhZGpNYXRyaXhfRm9yY2VMYXlvdXRfR0xTTEZ1bmN0aW9uU3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGpNYXRyaXhfRm9yY2VMYXlvdXRfR0xTTEZ1bmN0aW9uU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBmbG9hdCB0YW5oKGZsb2F0IHZhbCkge1xcbiAgICAgICAgICAgIGZsb2F0IHRtcCA9IGV4cCh2YWwpO1xcbiAgICAgICAgICAgIGZsb2F0IHRhbkggPSAodG1wIC0gMS4wIC8gdG1wKSAvICh0bXAgKyAxLjAgLyB0bXApO1xcbiAgICAgICAgICAgIHJldHVybiB0YW5IO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgc2lnbShmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgICByZXR1cm4gKDEuMCAvICgxLjAgKyBleHAoLXZhbCkpKTtcXG4gICAgICAgIH1cIjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBLRVJORUxfRElSO1xufSgpO1xuXG5nbG9iYWwuS0VSTkVMX0RJUiA9IEtFUk5FTF9ESVI7XG5tb2R1bGUuZXhwb3J0cy5LRVJORUxfRElSID0gS0VSTkVMX0RJUjsiXX0=
