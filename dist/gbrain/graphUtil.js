(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GraphUtils = exports.GraphUtils = function () {
    function GraphUtils() {
        _classCallCheck(this, GraphUtils);
    }

    _createClass(GraphUtils, null, [{
        key: "nodesDrawMode",
        value: function nodesDrawMode(geometryLength) {
            if (geometryLength === 1) return "vec4(color.rgb, 1.0)";else return "vec4(tex.rgb*color.rgb, tex.a)";
        }
    }, {
        key: "adjMatrix_ForceLayout_GLSLFunctionString",
        value: function adjMatrix_ForceLayout_GLSLFunctionString(geometryLength, efferentStart, efferentNodesCount) {
            return '' + "vec3 sphericalColl(vec3 currentDir, vec3 currentDirB, vec3 dirToBN) {\n            vec3 currentDirN = normalize(currentDir);\n            float pPoint = abs(dot(currentDirN, dirToBN));\n            vec3 reflectV = reflect(currentDirN*-1.0, dirToBN);\n\n            vec3 currentDirBN = normalize(currentDirB);\n            float pPointB = abs(dot(currentDirBN, dirToBN));\n\n            vec3 repulsionForce = (reflectV*-1.0)* (((1.0-pPoint)*length(currentDir))+((pPointB)*length(currentDirB)));\n\n            return (repulsionForce.x > 0.0 && repulsionForce.y > 0.0 && repulsionForce.z > 0.0) ? repulsionForce : dirToBN*-0.1;\n        }\n\n        struct CalculationResponse {\n            vec3 atraction;\n            float acumAtraction;\n            vec3 repulsion;\n            float collisionExists;\n            float netChildInputSumA;\n            float netParentErrorWeightA;\n            float netChildInputSumB;\n            float netParentErrorWeightB;\n            float netChildInputSumC;\n            float netParentErrorWeightC;\n            float netChildInputSumD;\n            float netParentErrorWeightD;\n            float netChildInputSumE;\n            float netParentErrorWeightE;\n            float netChildInputSumF;\n            float netParentErrorWeightF;\n            float netChildInputSumG;\n            float netParentErrorWeightG;\n        };" +

            // pixAdjMatA (bornDate, dieDate, weight (parent:-2;child:w), isParent (1.0:parent;0.0:child))
            // pixAdjMatA (linkMultiplier, activationFunction)
            "CalculationResponse calculate(float nodeId,\n                                        vec4 pixAdjMatACurrent, vec4 pixAdjMatAOpposite,\n                                        vec4 pixAdjMatBCurrent, vec4 pixAdjMatBOpposite,\n                                        vec2 xGeomCurrent, vec2 xGeomOpposite,\n                                        vec3 currentPos, vec3 currentDir,\n                                        vec3 atraction, float acumAtraction, vec3 repulsion,\n                                        float enableNeuronalNetwork,\n                                        float netChildInputSumA, float netParentErrorWeightA,\n                                        float netChildInputSumB, float netParentErrorWeightB,\n                                        float netChildInputSumC, float netParentErrorWeightC,\n                                        float netChildInputSumD, float netParentErrorWeightD,\n                                        float netChildInputSumE, float netParentErrorWeightE,\n                                        float netChildInputSumF, float netParentErrorWeightF,\n                                        float netChildInputSumG, float netParentErrorWeightG) {" +
            // pixAdjMatACurrent
            "float currentBornDate = pixAdjMatACurrent.x;\n            float currentDieDate = pixAdjMatACurrent.y;\n            float currentWeight = pixAdjMatACurrent.z;\n            float currentIsParent = pixAdjMatACurrent.w;" +

            // pixAdjMatAOpposite
            "float oppositeBornDate = pixAdjMatAOpposite.x;\n            float oppositeDieDate = pixAdjMatAOpposite.y;\n            float oppositeWeight = pixAdjMatAOpposite.z;\n            float oppositeIsParent = pixAdjMatAOpposite.w;" +

            // pixAdjMatBCurrent
            "float currentLinkMultiplier = pixAdjMatBCurrent.x;\n            float currentActivationFn = pixAdjMatBCurrent.y;" +

            // pixAdjMatBOpposite
            "float oppositeLinkMultiplier = pixAdjMatBOpposite.x;\n            float oppositeActivationFn = pixAdjMatBOpposite.y;" +

            // dataB Current
            //'float currentBornDate = dataB[xGeomCurrent].x;'+
            //'float currentDieDate = dataB[xGeomCurrent].y;'+
            //'float currentNetOutput = dataB[xGeomCurrent].z;'+
            //'float currentNetError = dataB[xGeomCurrent].w;'+

            // dataB Opposite
            //'float oppositeBornDate = dataB[xGeomOpposite].x;'+
            //'float oppositeDieDate = dataB[xGeomOpposite].y;'+
            "float oppositeNetOutputA = dataB[xGeomOpposite].z;\n            float oppositeNetErrorA = dataB[xGeomOpposite].w;\n\n            float oppositeNetOutputB = dataF[xGeomOpposite].x;\n            float oppositeNetErrorB = dataF[xGeomOpposite].y;\n        \n            float oppositeNetOutputC = dataF[xGeomOpposite].z;\n            float oppositeNetErrorC = dataF[xGeomOpposite].w;\n        \n            float oppositeNetOutputD = dataG[xGeomOpposite].x;\n            float oppositeNetErrorD = dataG[xGeomOpposite].y;\n        \n            float oppositeNetOutputE = dataG[xGeomOpposite].z;\n            float oppositeNetErrorE = dataG[xGeomOpposite].w;\n        \n            float oppositeNetOutputF = dataH[xGeomOpposite].x;\n            float oppositeNetErrorF = dataH[xGeomOpposite].y;\n        \n            float oppositeNetOutputG = dataH[xGeomOpposite].z;\n            float oppositeNetErrorG = dataH[xGeomOpposite].w;" +

            // pos & dir Current
            //'vec3 currentPos = posXYZW[xGeomCurrent].xyz;\n'+
            //'vec3 currentDir = dir[xGeomCurrent].xyz;\n'+

            // pos & dir Opposite
            "vec3 oppositePos = posXYZW[xGeomOpposite].xyz;\n            vec3 oppositeDir = dir[xGeomOpposite].xyz;" +

            // dir / dist to opposite
            'vec3 dirToOpposite = (oppositePos-currentPos);\n' + 'vec3 dirToOppositeN = normalize(dirToOpposite);\n' + 'float dist = distance(oppositePos, currentPos);\n' + // near=0.0 ; far=1.0
            'float distN = max(0.0,dist)/100000.0;' + 'float p = 1.0;' + 'if(currentDieDate != 0.0 && (currentTimestamp < currentBornDate || currentTimestamp > currentDieDate)) ' + 'p = 0.0;' + 'if(oppositeDieDate != 0.0 && (currentTimestamp < oppositeBornDate || currentTimestamp > oppositeDieDate)) ' + 'p = 0.0;' + 'if(p == 1.0) {' + 'float m1 = (enableNeuronalNetwork == 1.0) ? 0.0 : 400000.0;' + 'float m2 = (enableNeuronalNetwork == 1.0) ? 0.0 : 48.0;' + 'if(currentIsParent == 1.0) {' +
            //'if(enableNeuronalNetwork == 1.0) '+
            'netChildInputSumA += oppositeNetOutputA*oppositeWeight;' + 'netChildInputSumB += oppositeNetOutputB*oppositeWeight;' + 'netChildInputSumC += oppositeNetOutputC*oppositeWeight;' + 'netChildInputSumD += oppositeNetOutputD*oppositeWeight;' + 'netChildInputSumE += oppositeNetOutputE*oppositeWeight;' + 'netChildInputSumF += oppositeNetOutputF*oppositeWeight;' + 'netChildInputSumG += oppositeNetOutputG*oppositeWeight;' +
            //'else {'+
            'atraction += dirToOppositeN*max(1.0, distN*abs(oppositeWeight)*(m1/2.0));\n' + 'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(oppositeWeight)*(m2/2.0));\n' + 'acumAtraction += 1.0;\n' +
            //'}'+
            '} else if(currentIsParent == 0.5) {' +
            //'if(enableNeuronalNetwork == 1.0) '+
            'netParentErrorWeightA += oppositeNetErrorA*currentWeight;' + 'netParentErrorWeightB += oppositeNetErrorB*currentWeight;' + 'netParentErrorWeightC += oppositeNetErrorC*currentWeight;' + 'netParentErrorWeightD += oppositeNetErrorD*currentWeight;' + 'netParentErrorWeightE += oppositeNetErrorE*currentWeight;' + 'netParentErrorWeightF += oppositeNetErrorF*currentWeight;' + 'netParentErrorWeightG += oppositeNetErrorG*currentWeight;' +
            //'else {'+
            'atraction += dirToOppositeN*max(1.0, distN*abs(currentWeight)*m1);\n' + 'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*m2);\n' + 'acumAtraction += 1.0;\n' +
            //'}'+
            '}' +

            //'if(enableNeuronalNetwork == 0.0) {'+
            'repulsion += -dirToOppositeN*max(1.0, (1.0-distN)*abs(currentWeight)*(m2/8.0));\n' + 'acumAtraction += 1.0;\n' +
            //'}'+
            '}' + ("float collisionExists = 0.0;\n            if(enableForceLayoutCollision == 1.0 && dist < 4.0) {\n                collisionExists = 1.0;\n                atraction = sphericalColl(currentDir, oppositeDir, dirToOppositeN);\n            }\n\n            return CalculationResponse(atraction, acumAtraction, repulsion, collisionExists,\n                                        netChildInputSumA, netParentErrorWeightA,\n                                        netChildInputSumB, netParentErrorWeightB,\n                                        netChildInputSumC, netParentErrorWeightC,\n                                        netChildInputSumD, netParentErrorWeightD,\n                                        netChildInputSumE, netParentErrorWeightE,\n                                        netChildInputSumF, netParentErrorWeightF,\n                                        netChildInputSumG, netParentErrorWeightG);\n        }\n        struct idAdjMatrixResponse {\n            vec3 force;\n            float collisionExists;\n            float netFOutputA;\n            float netErrorWeightA;\n            float netFOutputB;\n            float netErrorWeightB;\n            float netFOutputC;\n            float netErrorWeightC;\n            float netFOutputD;\n            float netErrorWeightD;\n            float netFOutputE;\n            float netErrorWeightE;\n            float netFOutputF;\n            float netErrorWeightF;\n            float netFOutputG;\n            float netErrorWeightG;\n        };\n        float tanh(float val) {\n            float tmp = exp(val);\n            float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n            return tanH;\n        }\n        float sigm(float val) {\n            return (1.0 / (1.0 + exp(-val)));\n        }\n        idAdjMatrixResponse idAdjMatrix_ForceLayout(float nodeId, vec3 currentPos, vec3 currentDir, float numOfConnections, float currentTimestamp, float bornDate, float dieDate, float enableNeuronalNetwork) {\n            vec3 atraction = vec3(0.0, 0.0, 0.0);\n            float acumAtraction = 1.0;\n            vec3 repulsion = vec3(0.0, 0.0, 0.0);\n\n            float collisionExists = 0.0;\n            vec3 force = vec3(0.0, 0.0, 0.0);\n\n\n            float netChildInputSumA = 0.0;\n            float foutputA = 0.0;\n            float netParentErrorWeightA = 0.0;\n            \n            float netChildInputSumB = 0.0;\n            float foutputB = 0.0;\n            float netParentErrorWeightB = 0.0;\n            \n            float netChildInputSumC = 0.0;\n            float foutputC = 0.0;\n            float netParentErrorWeightC = 0.0;\n            \n            float netChildInputSumD = 0.0;\n            float foutputD = 0.0;\n            float netParentErrorWeightD = 0.0;\n            \n            float netChildInputSumE = 0.0;\n            float foutputE = 0.0;\n            float netParentErrorWeightE = 0.0;\n            \n            float netChildInputSumF = 0.0;\n            float foutputF = 0.0;\n            float netParentErrorWeightF = 0.0;\n            \n            float netChildInputSumG = 0.0;\n            float foutputG = 0.0;\n            float netParentErrorWeightG = 0.0;\n            \n\n            if(nodeId < nodesCount) {\n                float currentActivationFn = 0.0;\n                vec2 xGeomCurrent = get_global_id(nodeId, uBufferWidth, " + geometryLength.toFixed(1) + ");\n                for(int n=0; n < 4096; n++) {\n                    if(float(n) >= nodesCount) {break;}\n                    if(float(n) != nodeId) {\n                        vec2 xGeomOpposite = get_global_id(float(n), uBufferWidth, " + geometryLength.toFixed(1) + ");\n\n\n                        vec2 xAdjMatCurrent = get_global_id(vec2(float(n), nodeId), widthAdjMatrix);\n                        vec2 xAdjMatOpposite = get_global_id(vec2(nodeId, float(n)), widthAdjMatrix);\n\n                        vec4 pixAdjMatACurrent = adjacencyMatrix[xAdjMatCurrent];\n                        vec4 pixAdjMatAOpposite = adjacencyMatrix[xAdjMatOpposite];\n\n                        vec4 pixAdjMatBCurrent = adjacencyMatrixB[xAdjMatCurrent];\n                        vec4 pixAdjMatBOpposite = adjacencyMatrixB[xAdjMatOpposite];\n\n\n                        CalculationResponse calcResponse = calculate(nodeId,\n                                                                    pixAdjMatACurrent, pixAdjMatAOpposite,\n                                                                    pixAdjMatBCurrent, pixAdjMatBOpposite,\n                                                                    xGeomCurrent, xGeomOpposite,\n                                                                    currentPos, currentDir,\n                                                                    atraction, acumAtraction, repulsion,\n                                                                    enableNeuronalNetwork,\n                                                                    netChildInputSumA, netParentErrorWeightA,\n                                                                    netChildInputSumB, netParentErrorWeightB,\n                                                                    netChildInputSumC, netParentErrorWeightC,\n                                                                    netChildInputSumD, netParentErrorWeightD,\n                                                                    netChildInputSumE, netParentErrorWeightE,\n                                                                    netChildInputSumF, netParentErrorWeightF,\n                                                                    netChildInputSumG, netParentErrorWeightG);\n                        atraction = calcResponse.atraction;\n                        acumAtraction = calcResponse.acumAtraction;\n                        repulsion = calcResponse.repulsion;\n                        \n                        \n                        netChildInputSumA = calcResponse.netChildInputSumA;\n                        netParentErrorWeightA = calcResponse.netParentErrorWeightA;\n                        \n                        netChildInputSumB = calcResponse.netChildInputSumB;\n                        netParentErrorWeightB = calcResponse.netParentErrorWeightB;\n                        \n                        netChildInputSumC = calcResponse.netChildInputSumC;\n                        netParentErrorWeightC = calcResponse.netParentErrorWeightC;\n                        \n                        netChildInputSumD = calcResponse.netChildInputSumD;\n                        netParentErrorWeightD = calcResponse.netParentErrorWeightD;\n                        \n                        netChildInputSumE = calcResponse.netChildInputSumE;\n                        netParentErrorWeightE = calcResponse.netParentErrorWeightE;\n                        \n                        netChildInputSumF = calcResponse.netChildInputSumF;\n                        netParentErrorWeightF = calcResponse.netParentErrorWeightF;\n                        \n                        netChildInputSumG = calcResponse.netChildInputSumG;\n                        netParentErrorWeightG = calcResponse.netParentErrorWeightG;\n\n\n                        if(calcResponse.collisionExists == 1.0) {\n                            collisionExists = 1.0;\n                            force = calcResponse.atraction;\n                            break;\n                        }\n\n                        if(dieDate != 0.0) {\n                            if(currentTimestamp < bornDate || currentTimestamp > dieDate) {\n                                force = vec3(0.0, 0.0, 0.0);\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if(collisionExists == 0.0) {\n                    force += (atraction/acumAtraction)*1.0;\n                    force += (repulsion/acumAtraction)*1.0;\n                }\n\n                if(enableNeuronalNetwork == 1.0) {\n                    " + GraphUtils.efferentNodesStr(efferentStart, efferentNodesCount) + "\n                }\n            }\n\n            return idAdjMatrixResponse(vec3(force), collisionExists,\n                                        foutputA, netParentErrorWeightA,\n                                        foutputB, netParentErrorWeightB,\n                                        foutputC, netParentErrorWeightC,\n                                        foutputD, netParentErrorWeightD,\n                                        foutputE, netParentErrorWeightE,\n                                        foutputF, netParentErrorWeightF,\n                                        foutputG, netParentErrorWeightG);\n        }");
        }
    }, {
        key: "efferentNodesStr",
        value: function efferentNodesStr(efferentStart, efferentNodesCount) {
            var str = "\n            if(nodeId < afferentNodesCount) {\n                for(float n=0.0; n < 1024.0; n+=1.0) {\n                    if(n >= afferentNodesCount) {\n                        break;\n                    }\n                    if(nodeId == n) {\n                        foutputA = afferentNodesA[int(n)];\n                        foutputB = afferentNodesB[int(n)];\n                        foutputC = afferentNodesC[int(n)];\n                        foutputD = afferentNodesD[int(n)];\n                        foutputE = afferentNodesE[int(n)];\n                        foutputF = afferentNodesF[int(n)];\n                        foutputG = afferentNodesG[int(n)];\n                        break;\n                    }\n                }\n            } else {\n                foutputA = max(0.0, netChildInputSumA); " + "\n                foutputB = max(0.0, netChildInputSumB);\n                foutputC = max(0.0, netChildInputSumC);\n                foutputD = max(0.0, netChildInputSumD);\n                foutputE = max(0.0, netChildInputSumE);\n                foutputF = max(0.0, netChildInputSumF);\n                foutputG = max(0.0, netChildInputSumG);\n            }";

            str += "\n        if(nodeId == " + efferentStart.toFixed(1) + (") {\n            netParentErrorWeightA = (efferentNodesA[0] != 0.0) ? netChildInputSumA-efferentNodesA[0] : 0.0;\n            " + "\n            netParentErrorWeightB = (efferentNodesB[0] != 0.0) ? netChildInputSumB-efferentNodesB[0] : 0.0;\n            " + "\n            netParentErrorWeightC = (efferentNodesC[0] != 0.0) ? netChildInputSumC-efferentNodesC[0] : 0.0;\n            " + "\n            netParentErrorWeightD = (efferentNodesD[0] != 0.0) ? netChildInputSumD-efferentNodesD[0] : 0.0;\n            " + "\n            netParentErrorWeightE = (efferentNodesE[0] != 0.0) ? netChildInputSumE-efferentNodesE[0] : 0.0;\n            " + "\n            netParentErrorWeightF = (efferentNodesF[0] != 0.0) ? netChildInputSumF-efferentNodesF[0] : 0.0;\n            " + "\n            netParentErrorWeightG = (efferentNodesG[0] != 0.0) ? netChildInputSumG-efferentNodesG[0] : 0.0;\n            " + "\n        }");
            for (var n = efferentStart + 1; n < efferentStart + efferentNodesCount; n++) {
                str += "\n            else if(nodeId == " + n.toFixed(1) + ") {\n                netParentErrorWeightA = (efferentNodesA[" + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumA-efferentNodesA[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightB = (efferentNodesB[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumB-efferentNodesB[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightC = (efferentNodesC[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumC-efferentNodesC[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightD = (efferentNodesD[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumD-efferentNodesD[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightE = (efferentNodesE[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumE-efferentNodesE[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightF = (efferentNodesF[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumF-efferentNodesF[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n                netParentErrorWeightG = (efferentNodesG[") + Math.round(n - efferentStart) + "] != 0.0) ? netChildInputSumG-efferentNodesG[" + Math.round(n - efferentStart) + ("] : 0.0;\n                " + "\n            }");
            }str += "\n        else {\n            if(foutputA <= 0.0) {\n                netParentErrorWeightA = 0.0;\n            }\n            if(foutputB <= 0.0) {\n                netParentErrorWeightB = 0.0;\n            }\n            if(foutputC <= 0.0) {\n                netParentErrorWeightC = 0.0;\n            }\n            if(foutputD <= 0.0) {\n                netParentErrorWeightD = 0.0;\n            }\n            if(foutputE <= 0.0) {\n                netParentErrorWeightE = 0.0;\n            }\n            if(foutputF <= 0.0) {\n                netParentErrorWeightF = 0.0;\n            }\n            if(foutputG <= 0.0) {\n                netParentErrorWeightG = 0.0;\n            }\n        }";

            return str;
        }
    }, {
        key: "adjMatrix_Autolink_GLSLFunctionString",
        value: function adjMatrix_Autolink_GLSLFunctionString(geometryLength) {
            return '' + 'float GetAngle(vec3 A, vec3 B) {' + // from -180.0 to 180.0
            'vec3 cr = cross(A, B);' + 'float d = dot(A, B);' + 'if(cr.y < 0.0) {' + 'if(d > 0.0) {' + 'd =        (1.0-d)*90.0;' + '} else {' + 'd = 90.0+  (abs(d)*90.0);' + '}' + '} else {' + 'if(d > 0.0) {' + 'd = 270.0+ (d*90.0);' + '} else {' + 'd = 180.0+ ((1.0-abs(d))*90.0);' + '}' + '}' + 'return d;' + '}' + 'vec4 idAdjMatrix_Autolink(float nodeId, vec3 currentPos) {\n' +
            // INIT VARS
            'vec2 totalIDrelation = vec2(0.0, 0.0);' + 'float totalAngleRelations = 0.0;' +
            // END INIT VARS

            'if(nodeId < nodesCount) {\n' + 'for(int n=0; n < 4096; n++) {\n' + 'if(float(n) >= nodesCount) break;\n' + 'if(float(n) != nodeId) {' + 'vec2 xAdjMatCurrent = get_global_id(vec2(float(n), nodeId), widthAdjMatrix);' + 'vec4 pixAdjMatACurrent = adjacencyMatrix[xAdjMatCurrent];\n' +

            // RELATION FOUND
            'if(pixAdjMatACurrent.x > 0.0) {' + 'vec2 xGeomOpposite = get_global_id(float(n), uBufferWidth, ' + geometryLength.toFixed(1) + ');\n' + 'vec3 currentPosB = posXYZW[xGeomOpposite].xyz;\n' + 'vec3 dirToBN = normalize(currentPosB-currentPos);\n' + 'vec2 IDrelation = vec2(0.0, 0.0);' + 'float angleRelations = 360.0;' + 'if(nodeId < nodesCount) {\n' + 'for(int nB=0; nB < 4096; nB++) {\n' + 'if(float(nB) >= nodesCount) break;\n' + 'if(float(nB) != float(n) && float(nB) != nodeId) {' + 'vec2 xAdjMatCurrentB = get_global_id(vec2(float(nB), nodeId), widthAdjMatrix);' + 'vec4 pixAdjMatACurrent_B = adjacencyMatrix[xAdjMatCurrentB];\n' + 'if(pixAdjMatACurrent_B.x > 0.0) {' + 'vec2 xGeom_oppoB = get_global_id(float(nB), uBufferWidth, ' + geometryLength.toFixed(1) + ');\n' + 'vec3 currentPosBB = posXYZW[xGeom_oppoB].xyz;\n' + 'vec3 dirToBBN = normalize(currentPosBB-currentPos);\n' + 'float angle = GetAngle(dirToBN,dirToBBN);' + 'if(angle > 0.0 && angle < angleRelations) {' + 'IDrelation = xGeom_oppoB;' + 'angleRelations = angle;' + '}' + '}' + '}' + '}' + '}' + 'if(angleRelations < 360.0 && angleRelations > totalAngleRelations) {' + 'totalIDrelation = IDrelation;' + 'totalAngleRelations = angleRelations;' + '}' + '}' +
            // END RELATION FOUND

            '}' + '}' +
            // SUMMATION
            // END SUMMATION

            '}' + 'return vec4(totalIDrelation, totalAngleRelations, 0.0);' + '}';
        }
    }]);

    return GraphUtils;
}();

global.GraphUtils = GraphUtils;
module.exports.GraphUtils = GraphUtils;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZ2JyYWluL2dyYXBoVXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgR3JhcGhVdGlscyA9IGV4cG9ydHMuR3JhcGhVdGlscyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmFwaFV0aWxzKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JhcGhVdGlscyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEdyYXBoVXRpbHMsIG51bGwsIFt7XG4gICAgICAgIGtleTogXCJub2Rlc0RyYXdNb2RlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBub2Rlc0RyYXdNb2RlKGdlb21ldHJ5TGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnlMZW5ndGggPT09IDEpIHJldHVybiBcInZlYzQoY29sb3IucmdiLCAxLjApXCI7ZWxzZSByZXR1cm4gXCJ2ZWM0KHRleC5yZ2IqY29sb3IucmdiLCB0ZXguYSlcIjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFkak1hdHJpeF9Gb3JjZUxheW91dF9HTFNMRnVuY3Rpb25TdHJpbmdcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkak1hdHJpeF9Gb3JjZUxheW91dF9HTFNMRnVuY3Rpb25TdHJpbmcoZ2VvbWV0cnlMZW5ndGgsIGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgXCJ2ZWMzIHNwaGVyaWNhbENvbGwodmVjMyBjdXJyZW50RGlyLCB2ZWMzIGN1cnJlbnREaXJCLCB2ZWMzIGRpclRvQk4pIHtcXG4gICAgICAgICAgICB2ZWMzIGN1cnJlbnREaXJOID0gbm9ybWFsaXplKGN1cnJlbnREaXIpO1xcbiAgICAgICAgICAgIGZsb2F0IHBQb2ludCA9IGFicyhkb3QoY3VycmVudERpck4sIGRpclRvQk4pKTtcXG4gICAgICAgICAgICB2ZWMzIHJlZmxlY3RWID0gcmVmbGVjdChjdXJyZW50RGlyTiotMS4wLCBkaXJUb0JOKTtcXG5cXG4gICAgICAgICAgICB2ZWMzIGN1cnJlbnREaXJCTiA9IG5vcm1hbGl6ZShjdXJyZW50RGlyQik7XFxuICAgICAgICAgICAgZmxvYXQgcFBvaW50QiA9IGFicyhkb3QoY3VycmVudERpckJOLCBkaXJUb0JOKSk7XFxuXFxuICAgICAgICAgICAgdmVjMyByZXB1bHNpb25Gb3JjZSA9IChyZWZsZWN0ViotMS4wKSogKCgoMS4wLXBQb2ludCkqbGVuZ3RoKGN1cnJlbnREaXIpKSsoKHBQb2ludEIpKmxlbmd0aChjdXJyZW50RGlyQikpKTtcXG5cXG4gICAgICAgICAgICByZXR1cm4gKHJlcHVsc2lvbkZvcmNlLnggPiAwLjAgJiYgcmVwdWxzaW9uRm9yY2UueSA+IDAuMCAmJiByZXB1bHNpb25Gb3JjZS56ID4gMC4wKSA/IHJlcHVsc2lvbkZvcmNlIDogZGlyVG9CTiotMC4xO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3RydWN0IENhbGN1bGF0aW9uUmVzcG9uc2Uge1xcbiAgICAgICAgICAgIHZlYzMgYXRyYWN0aW9uO1xcbiAgICAgICAgICAgIGZsb2F0IGFjdW1BdHJhY3Rpb247XFxuICAgICAgICAgICAgdmVjMyByZXB1bHNpb247XFxuICAgICAgICAgICAgZmxvYXQgY29sbGlzaW9uRXhpc3RzO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1BO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQjtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEI7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUM7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRDO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1EO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEU7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUY7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRGO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1HO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RztcXG4gICAgICAgIH07XCIgK1xuXG4gICAgICAgICAgICAvLyBwaXhBZGpNYXRBIChib3JuRGF0ZSwgZGllRGF0ZSwgd2VpZ2h0IChwYXJlbnQ6LTI7Y2hpbGQ6dyksIGlzUGFyZW50ICgxLjA6cGFyZW50OzAuMDpjaGlsZCkpXG4gICAgICAgICAgICAvLyBwaXhBZGpNYXRBIChsaW5rTXVsdGlwbGllciwgYWN0aXZhdGlvbkZ1bmN0aW9uKVxuICAgICAgICAgICAgXCJDYWxjdWxhdGlvblJlc3BvbnNlIGNhbGN1bGF0ZShmbG9hdCBub2RlSWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0QUN1cnJlbnQsIHZlYzQgcGl4QWRqTWF0QU9wcG9zaXRlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHBpeEFkak1hdEJDdXJyZW50LCB2ZWM0IHBpeEFkak1hdEJPcHBvc2l0ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMiB4R2VvbUN1cnJlbnQsIHZlYzIgeEdlb21PcHBvc2l0ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyBjdXJyZW50UG9zLCB2ZWMzIGN1cnJlbnREaXIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgYXRyYWN0aW9uLCBmbG9hdCBhY3VtQXRyYWN0aW9uLCB2ZWMzIHJlcHVsc2lvbixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZW5hYmxlTmV1cm9uYWxOZXR3b3JrLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQSwgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRBLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQiwgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRCLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQywgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRDLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRCwgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRELFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRSwgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRFLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRiwgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRGLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRywgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRHKSB7XCIgK1xuICAgICAgICAgICAgLy8gcGl4QWRqTWF0QUN1cnJlbnRcbiAgICAgICAgICAgIFwiZmxvYXQgY3VycmVudEJvcm5EYXRlID0gcGl4QWRqTWF0QUN1cnJlbnQueDtcXG4gICAgICAgICAgICBmbG9hdCBjdXJyZW50RGllRGF0ZSA9IHBpeEFkak1hdEFDdXJyZW50Lnk7XFxuICAgICAgICAgICAgZmxvYXQgY3VycmVudFdlaWdodCA9IHBpeEFkak1hdEFDdXJyZW50Lno7XFxuICAgICAgICAgICAgZmxvYXQgY3VycmVudElzUGFyZW50ID0gcGl4QWRqTWF0QUN1cnJlbnQudztcIiArXG5cbiAgICAgICAgICAgIC8vIHBpeEFkak1hdEFPcHBvc2l0ZVxuICAgICAgICAgICAgXCJmbG9hdCBvcHBvc2l0ZUJvcm5EYXRlID0gcGl4QWRqTWF0QU9wcG9zaXRlLng7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVEaWVEYXRlID0gcGl4QWRqTWF0QU9wcG9zaXRlLnk7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVXZWlnaHQgPSBwaXhBZGpNYXRBT3Bwb3NpdGUuejtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUlzUGFyZW50ID0gcGl4QWRqTWF0QU9wcG9zaXRlLnc7XCIgK1xuXG4gICAgICAgICAgICAvLyBwaXhBZGpNYXRCQ3VycmVudFxuICAgICAgICAgICAgXCJmbG9hdCBjdXJyZW50TGlua011bHRpcGxpZXIgPSBwaXhBZGpNYXRCQ3VycmVudC54O1xcbiAgICAgICAgICAgIGZsb2F0IGN1cnJlbnRBY3RpdmF0aW9uRm4gPSBwaXhBZGpNYXRCQ3VycmVudC55O1wiICtcblxuICAgICAgICAgICAgLy8gcGl4QWRqTWF0Qk9wcG9zaXRlXG4gICAgICAgICAgICBcImZsb2F0IG9wcG9zaXRlTGlua011bHRpcGxpZXIgPSBwaXhBZGpNYXRCT3Bwb3NpdGUueDtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZUFjdGl2YXRpb25GbiA9IHBpeEFkak1hdEJPcHBvc2l0ZS55O1wiICtcblxuICAgICAgICAgICAgLy8gZGF0YUIgQ3VycmVudFxuICAgICAgICAgICAgLy8nZmxvYXQgY3VycmVudEJvcm5EYXRlID0gZGF0YUJbeEdlb21DdXJyZW50XS54OycrXG4gICAgICAgICAgICAvLydmbG9hdCBjdXJyZW50RGllRGF0ZSA9IGRhdGFCW3hHZW9tQ3VycmVudF0ueTsnK1xuICAgICAgICAgICAgLy8nZmxvYXQgY3VycmVudE5ldE91dHB1dCA9IGRhdGFCW3hHZW9tQ3VycmVudF0uejsnK1xuICAgICAgICAgICAgLy8nZmxvYXQgY3VycmVudE5ldEVycm9yID0gZGF0YUJbeEdlb21DdXJyZW50XS53OycrXG5cbiAgICAgICAgICAgIC8vIGRhdGFCIE9wcG9zaXRlXG4gICAgICAgICAgICAvLydmbG9hdCBvcHBvc2l0ZUJvcm5EYXRlID0gZGF0YUJbeEdlb21PcHBvc2l0ZV0ueDsnK1xuICAgICAgICAgICAgLy8nZmxvYXQgb3Bwb3NpdGVEaWVEYXRlID0gZGF0YUJbeEdlb21PcHBvc2l0ZV0ueTsnK1xuICAgICAgICAgICAgXCJmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEEgPSBkYXRhQlt4R2VvbU9wcG9zaXRlXS56O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0RXJyb3JBID0gZGF0YUJbeEdlb21PcHBvc2l0ZV0udztcXG5cXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEIgPSBkYXRhRlt4R2VvbU9wcG9zaXRlXS54O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0RXJyb3JCID0gZGF0YUZbeEdlb21PcHBvc2l0ZV0ueTtcXG4gICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0QyA9IGRhdGFGW3hHZW9tT3Bwb3NpdGVdLno7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckMgPSBkYXRhRlt4R2VvbU9wcG9zaXRlXS53O1xcbiAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXREID0gZGF0YUdbeEdlb21PcHBvc2l0ZV0ueDtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yRCA9IGRhdGFHW3hHZW9tT3Bwb3NpdGVdLnk7XFxuICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldE91dHB1dEUgPSBkYXRhR1t4R2VvbU9wcG9zaXRlXS56O1xcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0RXJyb3JFID0gZGF0YUdbeEdlb21PcHBvc2l0ZV0udztcXG4gICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG9wcG9zaXRlTmV0T3V0cHV0RiA9IGRhdGFIW3hHZW9tT3Bwb3NpdGVdLng7XFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRFcnJvckYgPSBkYXRhSFt4R2VvbU9wcG9zaXRlXS55O1xcbiAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgb3Bwb3NpdGVOZXRPdXRwdXRHID0gZGF0YUhbeEdlb21PcHBvc2l0ZV0uejtcXG4gICAgICAgICAgICBmbG9hdCBvcHBvc2l0ZU5ldEVycm9yRyA9IGRhdGFIW3hHZW9tT3Bwb3NpdGVdLnc7XCIgK1xuXG4gICAgICAgICAgICAvLyBwb3MgJiBkaXIgQ3VycmVudFxuICAgICAgICAgICAgLy8ndmVjMyBjdXJyZW50UG9zID0gcG9zWFlaV1t4R2VvbUN1cnJlbnRdLnh5ejtcXG4nK1xuICAgICAgICAgICAgLy8ndmVjMyBjdXJyZW50RGlyID0gZGlyW3hHZW9tQ3VycmVudF0ueHl6O1xcbicrXG5cbiAgICAgICAgICAgIC8vIHBvcyAmIGRpciBPcHBvc2l0ZVxuICAgICAgICAgICAgXCJ2ZWMzIG9wcG9zaXRlUG9zID0gcG9zWFlaV1t4R2VvbU9wcG9zaXRlXS54eXo7XFxuICAgICAgICAgICAgdmVjMyBvcHBvc2l0ZURpciA9IGRpclt4R2VvbU9wcG9zaXRlXS54eXo7XCIgK1xuXG4gICAgICAgICAgICAvLyBkaXIgLyBkaXN0IHRvIG9wcG9zaXRlXG4gICAgICAgICAgICAndmVjMyBkaXJUb09wcG9zaXRlID0gKG9wcG9zaXRlUG9zLWN1cnJlbnRQb3MpO1xcbicgKyAndmVjMyBkaXJUb09wcG9zaXRlTiA9IG5vcm1hbGl6ZShkaXJUb09wcG9zaXRlKTtcXG4nICsgJ2Zsb2F0IGRpc3QgPSBkaXN0YW5jZShvcHBvc2l0ZVBvcywgY3VycmVudFBvcyk7XFxuJyArIC8vIG5lYXI9MC4wIDsgZmFyPTEuMFxuICAgICAgICAgICAgJ2Zsb2F0IGRpc3ROID0gbWF4KDAuMCxkaXN0KS8xMDAwMDAuMDsnICsgJ2Zsb2F0IHAgPSAxLjA7JyArICdpZihjdXJyZW50RGllRGF0ZSAhPSAwLjAgJiYgKGN1cnJlbnRUaW1lc3RhbXAgPCBjdXJyZW50Qm9ybkRhdGUgfHwgY3VycmVudFRpbWVzdGFtcCA+IGN1cnJlbnREaWVEYXRlKSkgJyArICdwID0gMC4wOycgKyAnaWYob3Bwb3NpdGVEaWVEYXRlICE9IDAuMCAmJiAoY3VycmVudFRpbWVzdGFtcCA8IG9wcG9zaXRlQm9ybkRhdGUgfHwgY3VycmVudFRpbWVzdGFtcCA+IG9wcG9zaXRlRGllRGF0ZSkpICcgKyAncCA9IDAuMDsnICsgJ2lmKHAgPT0gMS4wKSB7JyArICdmbG9hdCBtMSA9IChlbmFibGVOZXVyb25hbE5ldHdvcmsgPT0gMS4wKSA/IDAuMCA6IDQwMDAwMC4wOycgKyAnZmxvYXQgbTIgPSAoZW5hYmxlTmV1cm9uYWxOZXR3b3JrID09IDEuMCkgPyAwLjAgOiA0OC4wOycgKyAnaWYoY3VycmVudElzUGFyZW50ID09IDEuMCkgeycgK1xuICAgICAgICAgICAgLy8naWYoZW5hYmxlTmV1cm9uYWxOZXR3b3JrID09IDEuMCkgJytcbiAgICAgICAgICAgICduZXRDaGlsZElucHV0U3VtQSArPSBvcHBvc2l0ZU5ldE91dHB1dEEqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtQiArPSBvcHBvc2l0ZU5ldE91dHB1dEIqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtQyArPSBvcHBvc2l0ZU5ldE91dHB1dEMqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtRCArPSBvcHBvc2l0ZU5ldE91dHB1dEQqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtRSArPSBvcHBvc2l0ZU5ldE91dHB1dEUqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtRiArPSBvcHBvc2l0ZU5ldE91dHB1dEYqb3Bwb3NpdGVXZWlnaHQ7JyArICduZXRDaGlsZElucHV0U3VtRyArPSBvcHBvc2l0ZU5ldE91dHB1dEcqb3Bwb3NpdGVXZWlnaHQ7JyArXG4gICAgICAgICAgICAvLydlbHNlIHsnK1xuICAgICAgICAgICAgJ2F0cmFjdGlvbiArPSBkaXJUb09wcG9zaXRlTiptYXgoMS4wLCBkaXN0TiphYnMob3Bwb3NpdGVXZWlnaHQpKihtMS8yLjApKTtcXG4nICsgJ3JlcHVsc2lvbiArPSAtZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgKDEuMC1kaXN0TikqYWJzKG9wcG9zaXRlV2VpZ2h0KSoobTIvMi4wKSk7XFxuJyArICdhY3VtQXRyYWN0aW9uICs9IDEuMDtcXG4nICtcbiAgICAgICAgICAgIC8vJ30nK1xuICAgICAgICAgICAgJ30gZWxzZSBpZihjdXJyZW50SXNQYXJlbnQgPT0gMC41KSB7JyArXG4gICAgICAgICAgICAvLydpZihlbmFibGVOZXVyb25hbE5ldHdvcmsgPT0gMS4wKSAnK1xuICAgICAgICAgICAgJ25ldFBhcmVudEVycm9yV2VpZ2h0QSArPSBvcHBvc2l0ZU5ldEVycm9yQSpjdXJyZW50V2VpZ2h0OycgKyAnbmV0UGFyZW50RXJyb3JXZWlnaHRCICs9IG9wcG9zaXRlTmV0RXJyb3JCKmN1cnJlbnRXZWlnaHQ7JyArICduZXRQYXJlbnRFcnJvcldlaWdodEMgKz0gb3Bwb3NpdGVOZXRFcnJvckMqY3VycmVudFdlaWdodDsnICsgJ25ldFBhcmVudEVycm9yV2VpZ2h0RCArPSBvcHBvc2l0ZU5ldEVycm9yRCpjdXJyZW50V2VpZ2h0OycgKyAnbmV0UGFyZW50RXJyb3JXZWlnaHRFICs9IG9wcG9zaXRlTmV0RXJyb3JFKmN1cnJlbnRXZWlnaHQ7JyArICduZXRQYXJlbnRFcnJvcldlaWdodEYgKz0gb3Bwb3NpdGVOZXRFcnJvckYqY3VycmVudFdlaWdodDsnICsgJ25ldFBhcmVudEVycm9yV2VpZ2h0RyArPSBvcHBvc2l0ZU5ldEVycm9yRypjdXJyZW50V2VpZ2h0OycgK1xuICAgICAgICAgICAgLy8nZWxzZSB7JytcbiAgICAgICAgICAgICdhdHJhY3Rpb24gKz0gZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgZGlzdE4qYWJzKGN1cnJlbnRXZWlnaHQpKm0xKTtcXG4nICsgJ3JlcHVsc2lvbiArPSAtZGlyVG9PcHBvc2l0ZU4qbWF4KDEuMCwgKDEuMC1kaXN0TikqYWJzKGN1cnJlbnRXZWlnaHQpKm0yKTtcXG4nICsgJ2FjdW1BdHJhY3Rpb24gKz0gMS4wO1xcbicgK1xuICAgICAgICAgICAgLy8nfScrXG4gICAgICAgICAgICAnfScgK1xuXG4gICAgICAgICAgICAvLydpZihlbmFibGVOZXVyb25hbE5ldHdvcmsgPT0gMC4wKSB7JytcbiAgICAgICAgICAgICdyZXB1bHNpb24gKz0gLWRpclRvT3Bwb3NpdGVOKm1heCgxLjAsICgxLjAtZGlzdE4pKmFicyhjdXJyZW50V2VpZ2h0KSoobTIvOC4wKSk7XFxuJyArICdhY3VtQXRyYWN0aW9uICs9IDEuMDtcXG4nICtcbiAgICAgICAgICAgIC8vJ30nK1xuICAgICAgICAgICAgJ30nICsgKFwiZmxvYXQgY29sbGlzaW9uRXhpc3RzID0gMC4wO1xcbiAgICAgICAgICAgIGlmKGVuYWJsZUZvcmNlTGF5b3V0Q29sbGlzaW9uID09IDEuMCAmJiBkaXN0IDwgNC4wKSB7XFxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkV4aXN0cyA9IDEuMDtcXG4gICAgICAgICAgICAgICAgYXRyYWN0aW9uID0gc3BoZXJpY2FsQ29sbChjdXJyZW50RGlyLCBvcHBvc2l0ZURpciwgZGlyVG9PcHBvc2l0ZU4pO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm4gQ2FsY3VsYXRpb25SZXNwb25zZShhdHJhY3Rpb24sIGFjdW1BdHJhY3Rpb24sIHJlcHVsc2lvbiwgY29sbGlzaW9uRXhpc3RzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQSwgbmV0UGFyZW50RXJyb3JXZWlnaHRBLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQiwgbmV0UGFyZW50RXJyb3JXZWlnaHRCLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQywgbmV0UGFyZW50RXJyb3JXZWlnaHRDLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRCwgbmV0UGFyZW50RXJyb3JXZWlnaHRELFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRSwgbmV0UGFyZW50RXJyb3JXZWlnaHRFLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRiwgbmV0UGFyZW50RXJyb3JXZWlnaHRGLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRywgbmV0UGFyZW50RXJyb3JXZWlnaHRHKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHN0cnVjdCBpZEFkak1hdHJpeFJlc3BvbnNlIHtcXG4gICAgICAgICAgICB2ZWMzIGZvcmNlO1xcbiAgICAgICAgICAgIGZsb2F0IGNvbGxpc2lvbkV4aXN0cztcXG4gICAgICAgICAgICBmbG9hdCBuZXRGT3V0cHV0QTtcXG4gICAgICAgICAgICBmbG9hdCBuZXRFcnJvcldlaWdodEE7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Rk91dHB1dEI7XFxuICAgICAgICAgICAgZmxvYXQgbmV0RXJyb3JXZWlnaHRCO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEZPdXRwdXRDO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEVycm9yV2VpZ2h0QztcXG4gICAgICAgICAgICBmbG9hdCBuZXRGT3V0cHV0RDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRFcnJvcldlaWdodEQ7XFxuICAgICAgICAgICAgZmxvYXQgbmV0Rk91dHB1dEU7XFxuICAgICAgICAgICAgZmxvYXQgbmV0RXJyb3JXZWlnaHRFO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEZPdXRwdXRGO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldEVycm9yV2VpZ2h0RjtcXG4gICAgICAgICAgICBmbG9hdCBuZXRGT3V0cHV0RztcXG4gICAgICAgICAgICBmbG9hdCBuZXRFcnJvcldlaWdodEc7XFxuICAgICAgICB9O1xcbiAgICAgICAgZmxvYXQgdGFuaChmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgICBmbG9hdCB0bXAgPSBleHAodmFsKTtcXG4gICAgICAgICAgICBmbG9hdCB0YW5IID0gKHRtcCAtIDEuMCAvIHRtcCkgLyAodG1wICsgMS4wIC8gdG1wKTtcXG4gICAgICAgICAgICByZXR1cm4gdGFuSDtcXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IHNpZ20oZmxvYXQgdmFsKSB7XFxuICAgICAgICAgICAgcmV0dXJuICgxLjAgLyAoMS4wICsgZXhwKC12YWwpKSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZEFkak1hdHJpeFJlc3BvbnNlIGlkQWRqTWF0cml4X0ZvcmNlTGF5b3V0KGZsb2F0IG5vZGVJZCwgdmVjMyBjdXJyZW50UG9zLCB2ZWMzIGN1cnJlbnREaXIsIGZsb2F0IG51bU9mQ29ubmVjdGlvbnMsIGZsb2F0IGN1cnJlbnRUaW1lc3RhbXAsIGZsb2F0IGJvcm5EYXRlLCBmbG9hdCBkaWVEYXRlLCBmbG9hdCBlbmFibGVOZXVyb25hbE5ldHdvcmspIHtcXG4gICAgICAgICAgICB2ZWMzIGF0cmFjdGlvbiA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgICAgICAgZmxvYXQgYWN1bUF0cmFjdGlvbiA9IDEuMDtcXG4gICAgICAgICAgICB2ZWMzIHJlcHVsc2lvbiA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgY29sbGlzaW9uRXhpc3RzID0gMC4wO1xcbiAgICAgICAgICAgIHZlYzMgZm9yY2UgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcblxcblxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1BID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRBID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0QSA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtQiA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0QiA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEIgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUMgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEMgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRDID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1EID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXREID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RCA9IDAuMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCBuZXRDaGlsZElucHV0U3VtRSA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBmb3V0cHV0RSA9IDAuMDtcXG4gICAgICAgICAgICBmbG9hdCBuZXRQYXJlbnRFcnJvcldlaWdodEUgPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZmxvYXQgbmV0Q2hpbGRJbnB1dFN1bUYgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgZm91dHB1dEYgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgbmV0UGFyZW50RXJyb3JXZWlnaHRGID0gMC4wO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZsb2F0IG5ldENoaWxkSW5wdXRTdW1HID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGZvdXRwdXRHID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IG5ldFBhcmVudEVycm9yV2VpZ2h0RyA9IDAuMDtcXG4gICAgICAgICAgICBcXG5cXG4gICAgICAgICAgICBpZihub2RlSWQgPCBub2Rlc0NvdW50KSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGN1cnJlbnRBY3RpdmF0aW9uRm4gPSAwLjA7XFxuICAgICAgICAgICAgICAgIHZlYzIgeEdlb21DdXJyZW50ID0gZ2V0X2dsb2JhbF9pZChub2RlSWQsIHVCdWZmZXJXaWR0aCwgXCIgKyBnZW9tZXRyeUxlbmd0aC50b0ZpeGVkKDEpICsgXCIpO1xcbiAgICAgICAgICAgICAgICBmb3IoaW50IG49MDsgbiA8IDQwOTY7IG4rKykge1xcbiAgICAgICAgICAgICAgICAgICAgaWYoZmxvYXQobikgPj0gbm9kZXNDb3VudCkge2JyZWFrO31cXG4gICAgICAgICAgICAgICAgICAgIGlmKGZsb2F0KG4pICE9IG5vZGVJZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIgeEdlb21PcHBvc2l0ZSA9IGdldF9nbG9iYWxfaWQoZmxvYXQobiksIHVCdWZmZXJXaWR0aCwgXCIgKyBnZW9tZXRyeUxlbmd0aC50b0ZpeGVkKDEpICsgXCIpO1xcblxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIgeEFkak1hdEN1cnJlbnQgPSBnZXRfZ2xvYmFsX2lkKHZlYzIoZmxvYXQobiksIG5vZGVJZCksIHdpZHRoQWRqTWF0cml4KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyIHhBZGpNYXRPcHBvc2l0ZSA9IGdldF9nbG9iYWxfaWQodmVjMihub2RlSWQsIGZsb2F0KG4pKSwgd2lkdGhBZGpNYXRyaXgpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0QUN1cnJlbnQgPSBhZGphY2VuY3lNYXRyaXhbeEFkak1hdEN1cnJlbnRdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0QU9wcG9zaXRlID0gYWRqYWNlbmN5TWF0cml4W3hBZGpNYXRPcHBvc2l0ZV07XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwaXhBZGpNYXRCQ3VycmVudCA9IGFkamFjZW5jeU1hdHJpeEJbeEFkak1hdEN1cnJlbnRdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcGl4QWRqTWF0Qk9wcG9zaXRlID0gYWRqYWNlbmN5TWF0cml4Qlt4QWRqTWF0T3Bwb3NpdGVdO1xcblxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIENhbGN1bGF0aW9uUmVzcG9uc2UgY2FsY1Jlc3BvbnNlID0gY2FsY3VsYXRlKG5vZGVJZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpeEFkak1hdEFDdXJyZW50LCBwaXhBZGpNYXRBT3Bwb3NpdGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhBZGpNYXRCQ3VycmVudCwgcGl4QWRqTWF0Qk9wcG9zaXRlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeEdlb21DdXJyZW50LCB4R2VvbU9wcG9zaXRlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcywgY3VycmVudERpcixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0cmFjdGlvbiwgYWN1bUF0cmFjdGlvbiwgcmVwdWxzaW9uLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlTmV1cm9uYWxOZXR3b3JrLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUEsIG5ldFBhcmVudEVycm9yV2VpZ2h0QSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1CLCBuZXRQYXJlbnRFcnJvcldlaWdodEIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQywgbmV0UGFyZW50RXJyb3JXZWlnaHRDLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUQsIG5ldFBhcmVudEVycm9yV2VpZ2h0RCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1FLCBuZXRQYXJlbnRFcnJvcldlaWdodEUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRiwgbmV0UGFyZW50RXJyb3JXZWlnaHRGLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUcsIG5ldFBhcmVudEVycm9yV2VpZ2h0Ryk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYXRyYWN0aW9uID0gY2FsY1Jlc3BvbnNlLmF0cmFjdGlvbjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3VtQXRyYWN0aW9uID0gY2FsY1Jlc3BvbnNlLmFjdW1BdHJhY3Rpb247XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwdWxzaW9uID0gY2FsY1Jlc3BvbnNlLnJlcHVsc2lvbjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtQSA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtQTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEEgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JXZWlnaHRBO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1CID0gY2FsY1Jlc3BvbnNlLm5ldENoaWxkSW5wdXRTdW1CO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvcldlaWdodEI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUMgPSBjYWxjUmVzcG9uc2UubmV0Q2hpbGRJbnB1dFN1bUM7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRDID0gY2FsY1Jlc3BvbnNlLm5ldFBhcmVudEVycm9yV2VpZ2h0QztcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRCA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtRDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEQgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JXZWlnaHREO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldENoaWxkSW5wdXRTdW1FID0gY2FsY1Jlc3BvbnNlLm5ldENoaWxkSW5wdXRTdW1FO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IGNhbGNSZXNwb25zZS5uZXRQYXJlbnRFcnJvcldlaWdodEU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0Q2hpbGRJbnB1dFN1bUYgPSBjYWxjUmVzcG9uc2UubmV0Q2hpbGRJbnB1dFN1bUY7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRGID0gY2FsY1Jlc3BvbnNlLm5ldFBhcmVudEVycm9yV2VpZ2h0RjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRDaGlsZElucHV0U3VtRyA9IGNhbGNSZXNwb25zZS5uZXRDaGlsZElucHV0U3VtRztcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEcgPSBjYWxjUmVzcG9uc2UubmV0UGFyZW50RXJyb3JXZWlnaHRHO1xcblxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhbGNSZXNwb25zZS5jb2xsaXNpb25FeGlzdHMgPT0gMS4wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbkV4aXN0cyA9IDEuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2UgPSBjYWxjUmVzcG9uc2UuYXRyYWN0aW9uO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGllRGF0ZSAhPSAwLjApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudFRpbWVzdGFtcCA8IGJvcm5EYXRlIHx8IGN1cnJlbnRUaW1lc3RhbXAgPiBkaWVEYXRlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZSA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZihjb2xsaXNpb25FeGlzdHMgPT0gMC4wKSB7XFxuICAgICAgICAgICAgICAgICAgICBmb3JjZSArPSAoYXRyYWN0aW9uL2FjdW1BdHJhY3Rpb24pKjEuMDtcXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlICs9IChyZXB1bHNpb24vYWN1bUF0cmFjdGlvbikqMS4wO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmKGVuYWJsZU5ldXJvbmFsTmV0d29yayA9PSAxLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIFwiICsgR3JhcGhVdGlscy5lZmZlcmVudE5vZGVzU3RyKGVmZmVyZW50U3RhcnQsIGVmZmVyZW50Tm9kZXNDb3VudCkgKyBcIlxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiBpZEFkak1hdHJpeFJlc3BvbnNlKHZlYzMoZm9yY2UpLCBjb2xsaXNpb25FeGlzdHMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRBLCBuZXRQYXJlbnRFcnJvcldlaWdodEEsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRCLCBuZXRQYXJlbnRFcnJvcldlaWdodEIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRDLCBuZXRQYXJlbnRFcnJvcldlaWdodEMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRELCBuZXRQYXJlbnRFcnJvcldlaWdodEQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRFLCBuZXRQYXJlbnRFcnJvcldlaWdodEUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRGLCBuZXRQYXJlbnRFcnJvcldlaWdodEYsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRHLCBuZXRQYXJlbnRFcnJvcldlaWdodEcpO1xcbiAgICAgICAgfVwiKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVmZmVyZW50Tm9kZXNTdHJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVmZmVyZW50Tm9kZXNTdHIoZWZmZXJlbnRTdGFydCwgZWZmZXJlbnROb2Rlc0NvdW50KSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gXCJcXG4gICAgICAgICAgICBpZihub2RlSWQgPCBhZmZlcmVudE5vZGVzQ291bnQpIHtcXG4gICAgICAgICAgICAgICAgZm9yKGZsb2F0IG49MC4wOyBuIDwgMTAyNC4wOyBuKz0xLjApIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmKG4gPj0gYWZmZXJlbnROb2Rlc0NvdW50KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBpZihub2RlSWQgPT0gbikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRBID0gYWZmZXJlbnROb2Rlc0FbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0QiA9IGFmZmVyZW50Tm9kZXNCW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEMgPSBhZmZlcmVudE5vZGVzQ1tpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXREID0gYWZmZXJlbnROb2Rlc0RbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3V0cHV0RSA9IGFmZmVyZW50Tm9kZXNFW2ludChuKV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm91dHB1dEYgPSBhZmZlcmVudE5vZGVzRltpbnQobildO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdXRwdXRHID0gYWZmZXJlbnROb2Rlc0dbaW50KG4pXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGZvdXRwdXRBID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUEpOyBcIiArIFwiXFxuICAgICAgICAgICAgICAgIGZvdXRwdXRCID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUIpO1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0QyA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1DKTtcXG4gICAgICAgICAgICAgICAgZm91dHB1dEQgPSBtYXgoMC4wLCBuZXRDaGlsZElucHV0U3VtRCk7XFxuICAgICAgICAgICAgICAgIGZvdXRwdXRFID0gbWF4KDAuMCwgbmV0Q2hpbGRJbnB1dFN1bUUpO1xcbiAgICAgICAgICAgICAgICBmb3V0cHV0RiA9IG1heCgwLjAsIG5ldENoaWxkSW5wdXRTdW1GKTtcXG4gICAgICAgICAgICAgICAgZm91dHB1dEcgPSBtYXgoMC4wLCBuZXRDaGlsZElucHV0U3VtRyk7XFxuICAgICAgICAgICAgfVwiO1xuXG4gICAgICAgICAgICBzdHIgKz0gXCJcXG4gICAgICAgIGlmKG5vZGVJZCA9PSBcIiArIGVmZmVyZW50U3RhcnQudG9GaXhlZCgxKSArIChcIikge1xcbiAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QSA9IChlZmZlcmVudE5vZGVzQVswXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUEtZWZmZXJlbnROb2Rlc0FbMF0gOiAwLjA7XFxuICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IChlZmZlcmVudE5vZGVzQlswXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUItZWZmZXJlbnROb2Rlc0JbMF0gOiAwLjA7XFxuICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QyA9IChlZmZlcmVudE5vZGVzQ1swXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUMtZWZmZXJlbnROb2Rlc0NbMF0gOiAwLjA7XFxuICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RCA9IChlZmZlcmVudE5vZGVzRFswXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUQtZWZmZXJlbnROb2Rlc0RbMF0gOiAwLjA7XFxuICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IChlZmZlcmVudE5vZGVzRVswXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUUtZWZmZXJlbnROb2Rlc0VbMF0gOiAwLjA7XFxuICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RiA9IChlZmZlcmVudE5vZGVzRlswXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUYtZWZmZXJlbnROb2Rlc0ZbMF0gOiAwLjA7XFxuICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RyA9IChlZmZlcmVudE5vZGVzR1swXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUctZWZmZXJlbnROb2Rlc0dbMF0gOiAwLjA7XFxuICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgfVwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSBlZmZlcmVudFN0YXJ0ICsgMTsgbiA8IGVmZmVyZW50U3RhcnQgKyBlZmZlcmVudE5vZGVzQ291bnQ7IG4rKykge1xuICAgICAgICAgICAgICAgIHN0ciArPSBcIlxcbiAgICAgICAgICAgIGVsc2UgaWYobm9kZUlkID09IFwiICsgbi50b0ZpeGVkKDEpICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRBID0gKGVmZmVyZW50Tm9kZXNBW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyBcIl0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1BLWVmZmVyZW50Tm9kZXNBW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAoXCJdIDogMC4wO1xcbiAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0QiA9IChlZmZlcmVudE5vZGVzQltcIikgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUItZWZmZXJlbnROb2Rlc0JbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIChcIl0gOiAwLjA7XFxuICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRDID0gKGVmZmVyZW50Tm9kZXNDW1wiKSArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtQy1lZmZlcmVudE5vZGVzQ1tcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgKFwiXSA6IDAuMDtcXG4gICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEQgPSAoZWZmZXJlbnROb2Rlc0RbXCIpICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyBcIl0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1ELWVmZmVyZW50Tm9kZXNEW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAoXCJdIDogMC4wO1xcbiAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgICAgIG5ldFBhcmVudEVycm9yV2VpZ2h0RSA9IChlZmZlcmVudE5vZGVzRVtcIikgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIFwiXSAhPSAwLjApID8gbmV0Q2hpbGRJbnB1dFN1bUUtZWZmZXJlbnROb2Rlc0VbXCIgKyBNYXRoLnJvdW5kKG4gLSBlZmZlcmVudFN0YXJ0KSArIChcIl0gOiAwLjA7XFxuICAgICAgICAgICAgICAgIFwiICsgXCJcXG4gICAgICAgICAgICAgICAgbmV0UGFyZW50RXJyb3JXZWlnaHRGID0gKGVmZmVyZW50Tm9kZXNGW1wiKSArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgXCJdICE9IDAuMCkgPyBuZXRDaGlsZElucHV0U3VtRi1lZmZlcmVudE5vZGVzRltcIiArIE1hdGgucm91bmQobiAtIGVmZmVyZW50U3RhcnQpICsgKFwiXSA6IDAuMDtcXG4gICAgICAgICAgICAgICAgXCIgKyBcIlxcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEcgPSAoZWZmZXJlbnROb2Rlc0dbXCIpICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyBcIl0gIT0gMC4wKSA/IG5ldENoaWxkSW5wdXRTdW1HLWVmZmVyZW50Tm9kZXNHW1wiICsgTWF0aC5yb3VuZChuIC0gZWZmZXJlbnRTdGFydCkgKyAoXCJdIDogMC4wO1xcbiAgICAgICAgICAgICAgICBcIiArIFwiXFxuICAgICAgICAgICAgfVwiKTtcbiAgICAgICAgICAgIH1zdHIgKz0gXCJcXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGlmKGZvdXRwdXRBIDw9IDAuMCkge1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEEgPSAwLjA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmKGZvdXRwdXRCIDw9IDAuMCkge1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEIgPSAwLjA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmKGZvdXRwdXRDIDw9IDAuMCkge1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEMgPSAwLjA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmKGZvdXRwdXREIDw9IDAuMCkge1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEQgPSAwLjA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmKGZvdXRwdXRFIDw9IDAuMCkge1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEUgPSAwLjA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmKGZvdXRwdXRGIDw9IDAuMCkge1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEYgPSAwLjA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmKGZvdXRwdXRHIDw9IDAuMCkge1xcbiAgICAgICAgICAgICAgICBuZXRQYXJlbnRFcnJvcldlaWdodEcgPSAwLjA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVwiO1xuXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYWRqTWF0cml4X0F1dG9saW5rX0dMU0xGdW5jdGlvblN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRqTWF0cml4X0F1dG9saW5rX0dMU0xGdW5jdGlvblN0cmluZyhnZW9tZXRyeUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgJ2Zsb2F0IEdldEFuZ2xlKHZlYzMgQSwgdmVjMyBCKSB7JyArIC8vIGZyb20gLTE4MC4wIHRvIDE4MC4wXG4gICAgICAgICAgICAndmVjMyBjciA9IGNyb3NzKEEsIEIpOycgKyAnZmxvYXQgZCA9IGRvdChBLCBCKTsnICsgJ2lmKGNyLnkgPCAwLjApIHsnICsgJ2lmKGQgPiAwLjApIHsnICsgJ2QgPSAgICAgICAgKDEuMC1kKSo5MC4wOycgKyAnfSBlbHNlIHsnICsgJ2QgPSA5MC4wKyAgKGFicyhkKSo5MC4wKTsnICsgJ30nICsgJ30gZWxzZSB7JyArICdpZihkID4gMC4wKSB7JyArICdkID0gMjcwLjArIChkKjkwLjApOycgKyAnfSBlbHNlIHsnICsgJ2QgPSAxODAuMCsgKCgxLjAtYWJzKGQpKSo5MC4wKTsnICsgJ30nICsgJ30nICsgJ3JldHVybiBkOycgKyAnfScgKyAndmVjNCBpZEFkak1hdHJpeF9BdXRvbGluayhmbG9hdCBub2RlSWQsIHZlYzMgY3VycmVudFBvcykge1xcbicgK1xuICAgICAgICAgICAgLy8gSU5JVCBWQVJTXG4gICAgICAgICAgICAndmVjMiB0b3RhbElEcmVsYXRpb24gPSB2ZWMyKDAuMCwgMC4wKTsnICsgJ2Zsb2F0IHRvdGFsQW5nbGVSZWxhdGlvbnMgPSAwLjA7JyArXG4gICAgICAgICAgICAvLyBFTkQgSU5JVCBWQVJTXG5cbiAgICAgICAgICAgICdpZihub2RlSWQgPCBub2Rlc0NvdW50KSB7XFxuJyArICdmb3IoaW50IG49MDsgbiA8IDQwOTY7IG4rKykge1xcbicgKyAnaWYoZmxvYXQobikgPj0gbm9kZXNDb3VudCkgYnJlYWs7XFxuJyArICdpZihmbG9hdChuKSAhPSBub2RlSWQpIHsnICsgJ3ZlYzIgeEFkak1hdEN1cnJlbnQgPSBnZXRfZ2xvYmFsX2lkKHZlYzIoZmxvYXQobiksIG5vZGVJZCksIHdpZHRoQWRqTWF0cml4KTsnICsgJ3ZlYzQgcGl4QWRqTWF0QUN1cnJlbnQgPSBhZGphY2VuY3lNYXRyaXhbeEFkak1hdEN1cnJlbnRdO1xcbicgK1xuXG4gICAgICAgICAgICAvLyBSRUxBVElPTiBGT1VORFxuICAgICAgICAgICAgJ2lmKHBpeEFkak1hdEFDdXJyZW50LnggPiAwLjApIHsnICsgJ3ZlYzIgeEdlb21PcHBvc2l0ZSA9IGdldF9nbG9iYWxfaWQoZmxvYXQobiksIHVCdWZmZXJXaWR0aCwgJyArIGdlb21ldHJ5TGVuZ3RoLnRvRml4ZWQoMSkgKyAnKTtcXG4nICsgJ3ZlYzMgY3VycmVudFBvc0IgPSBwb3NYWVpXW3hHZW9tT3Bwb3NpdGVdLnh5ejtcXG4nICsgJ3ZlYzMgZGlyVG9CTiA9IG5vcm1hbGl6ZShjdXJyZW50UG9zQi1jdXJyZW50UG9zKTtcXG4nICsgJ3ZlYzIgSURyZWxhdGlvbiA9IHZlYzIoMC4wLCAwLjApOycgKyAnZmxvYXQgYW5nbGVSZWxhdGlvbnMgPSAzNjAuMDsnICsgJ2lmKG5vZGVJZCA8IG5vZGVzQ291bnQpIHtcXG4nICsgJ2ZvcihpbnQgbkI9MDsgbkIgPCA0MDk2OyBuQisrKSB7XFxuJyArICdpZihmbG9hdChuQikgPj0gbm9kZXNDb3VudCkgYnJlYWs7XFxuJyArICdpZihmbG9hdChuQikgIT0gZmxvYXQobikgJiYgZmxvYXQobkIpICE9IG5vZGVJZCkgeycgKyAndmVjMiB4QWRqTWF0Q3VycmVudEIgPSBnZXRfZ2xvYmFsX2lkKHZlYzIoZmxvYXQobkIpLCBub2RlSWQpLCB3aWR0aEFkak1hdHJpeCk7JyArICd2ZWM0IHBpeEFkak1hdEFDdXJyZW50X0IgPSBhZGphY2VuY3lNYXRyaXhbeEFkak1hdEN1cnJlbnRCXTtcXG4nICsgJ2lmKHBpeEFkak1hdEFDdXJyZW50X0IueCA+IDAuMCkgeycgKyAndmVjMiB4R2VvbV9vcHBvQiA9IGdldF9nbG9iYWxfaWQoZmxvYXQobkIpLCB1QnVmZmVyV2lkdGgsICcgKyBnZW9tZXRyeUxlbmd0aC50b0ZpeGVkKDEpICsgJyk7XFxuJyArICd2ZWMzIGN1cnJlbnRQb3NCQiA9IHBvc1hZWldbeEdlb21fb3Bwb0JdLnh5ejtcXG4nICsgJ3ZlYzMgZGlyVG9CQk4gPSBub3JtYWxpemUoY3VycmVudFBvc0JCLWN1cnJlbnRQb3MpO1xcbicgKyAnZmxvYXQgYW5nbGUgPSBHZXRBbmdsZShkaXJUb0JOLGRpclRvQkJOKTsnICsgJ2lmKGFuZ2xlID4gMC4wICYmIGFuZ2xlIDwgYW5nbGVSZWxhdGlvbnMpIHsnICsgJ0lEcmVsYXRpb24gPSB4R2VvbV9vcHBvQjsnICsgJ2FuZ2xlUmVsYXRpb25zID0gYW5nbGU7JyArICd9JyArICd9JyArICd9JyArICd9JyArICd9JyArICdpZihhbmdsZVJlbGF0aW9ucyA8IDM2MC4wICYmIGFuZ2xlUmVsYXRpb25zID4gdG90YWxBbmdsZVJlbGF0aW9ucykgeycgKyAndG90YWxJRHJlbGF0aW9uID0gSURyZWxhdGlvbjsnICsgJ3RvdGFsQW5nbGVSZWxhdGlvbnMgPSBhbmdsZVJlbGF0aW9uczsnICsgJ30nICsgJ30nICtcbiAgICAgICAgICAgIC8vIEVORCBSRUxBVElPTiBGT1VORFxuXG4gICAgICAgICAgICAnfScgKyAnfScgK1xuICAgICAgICAgICAgLy8gU1VNTUFUSU9OXG4gICAgICAgICAgICAvLyBFTkQgU1VNTUFUSU9OXG5cbiAgICAgICAgICAgICd9JyArICdyZXR1cm4gdmVjNCh0b3RhbElEcmVsYXRpb24sIHRvdGFsQW5nbGVSZWxhdGlvbnMsIDAuMCk7JyArICd9JztcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBHcmFwaFV0aWxzO1xufSgpO1xuXG5nbG9iYWwuR3JhcGhVdGlscyA9IEdyYXBoVXRpbHM7XG5tb2R1bGUuZXhwb3J0cy5HcmFwaFV0aWxzID0gR3JhcGhVdGlsczsiXX0=
