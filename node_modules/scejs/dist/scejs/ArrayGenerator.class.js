(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

var exp = { "WebCLGL": "./WebCLGL.class",
            "WebCLGLBuffer": "./WebCLGLBuffer.class.js",
            "WebCLGLFor": "./WebCLGLFor.class.js",
            "WebCLGLKernel": "./WebCLGLKernel.class.js",
            "WebCLGLUtils": "./WebCLGLUtils.class.js",
            "WebCLGLVertexFragmentProgram": "./WebCLGLVertexFragmentProgram.class.js"
};

for(var key in exp)
    exports[key] = require(exp[key]);
},{}],2:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ArrayGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Utils = require("./Utils.class");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* @class
* @constructor
*/
var ArrayGenerator = exports.ArrayGenerator = function () {
	function ArrayGenerator() {
		_classCallCheck(this, ArrayGenerator);
	}

	/**
 * @param {Object} jsonIn
 * @param {int} jsonIn.count - count
 * @param {number} jsonIn.offset - Offset
 * @param {String} jsonIn.type - "float" | "float4"
 * @param {number} [jsonIn.spacing=0.01] - Spacing
 * @return {Array<number>}
 */


	_createClass(ArrayGenerator, [{
		key: "volumeArray",

		/**
  * @param {StormVoxelizator} voxelizator
  */
		value: function volumeArray(voxelizator) {
			this.arrayNodeDestination = [];
			this.arrayNodeVertexColor = [];

			this.vo = voxelizator;
			if (this.vo instanceof StormVoxelizator === false) {
				alert("You must select a voxelizator object with albedo fillmode enabled.");return false;
			}
			if (this.vo.image3D_VoxelsColor === undefined || this.vo.image3D_VoxelsColor === null) {
				alert("You must select a voxelizator object with albedo fillmode enabled.");return false;
			}
			this.data = this.vo.clglBuff_VoxelsColor.items[0].inData;

			var numActCells = 0;
			for (var n = 0, f = this.data.length / 4; n < f; n++) {
				// num of active cells
				var id = n * 4;
				//if(data[id] > 30 && data[id+1] > 30 && data[id+2] > 30)
				if (this.data[id + 3] > 0) {
					numActCells++;
				}
			}
			var totalNodes = this.currentNodeId - 1;
			var nodesPerCell = totalNodes / numActCells;

			this.incremNodesCell = 0;
			var currentNodeId = -1;

			this.currentVoxelCell = null;
			this.CCX = 0;
			this.CCY = 0;
			this.CCZ = 0;
			this.CCXMAX = this.vo.resolution - 1, this.CCYMAX = this.vo.resolution - 1, this.CCZMAX = this.vo.resolution - 1;
			var separation = 1.0;
			var p = void 0;
			var c = void 0;
			var make = false;

			var next = function () {
				while (true) {
					if (this.CCX === this.CCXMAX && this.CCZ === this.CCZMAX && this.CCY === this.CCYMAX) {
						break;
					} else {
						if (this.CCX === this.CCXMAX && this.CCZ === this.CCZMAX) {
							this.CCX = 0;this.CCZ = 0;this.CCY++;
						} else {
							if (this.CCX === this.CCXMAX) {
								this.CCX = 0;this.CCZ++;
							} else {
								this.CCX++;
							}
						}
					}

					this.currentVoxelCell = this.CCY * (this.vo.resolution * this.vo.resolution) + this.CCZ * this.vo.resolution + this.CCX;

					if (this.data[this.currentVoxelCell * 4 + 3] > 0) {
						this.incremNodesCell += nodesPerCell;
						if (this.incremNodesCell >= 1.0) {
							this.incremNodesCell -= 1.0;
							break;
						}
					}
				}
			}.bind(this);

			for (var _n = 0; _n < this.arrayNodeId.length; _n++) {
				if (currentNodeId !== this.arrayNodeId[_n]) {
					currentNodeId = this.arrayNodeId[_n];

					if (this.incremNodesCell >= 1.0) {
						this.incremNodesCell -= 1.0;
					} else {
						next();
					}

					// position
					p = $V3([0.0, 0.0, 0.0]).add($V3([-(this.vo.size / 2.0), -(this.vo.size / 2.0), -(this.vo.size / 2.0)]));
					p = p.add($V3([this.vo.cs * this.CCX * separation, this.vo.cs * this.CCY * separation, this.vo.cs * (this.CCZMAX - this.CCZ) * separation]));
					p = p.add($V3([this.vo.cs * Math.random(), this.vo.cs * Math.random(), this.vo.cs * Math.random()]));

					// color
					c = $V3([this.data[this.currentVoxelCell * 4] / 255, this.data[this.currentVoxelCell * 4 + 1] / 255, this.data[this.currentVoxelCell * 4 + 2] / 255]);

					this.arrayNodeDestination.push(p.e[0], p.e[1], p.e[2], 1.0);
					this.arrayNodeVertexColor.push(c.e[0], c.e[1], c.e[2], 1.0);
				} else {
					this.arrayNodeDestination.push(p.e[0], p.e[1], p.e[2], 1.0);
					this.arrayNodeVertexColor.push(c.e[0], c.e[1], c.e[2], 1.0);
				}
			}
			comp_renderer_nodes.setArg("dest", function () {
				return this.arrayNodeDestination;
			}.bind(this), this.splitNodes);
			comp_renderer_nodes.setArg("nodeVertexCol", function () {
				return this.arrayNodeVertexColor;
			}.bind(this), this.splitNodes);
		}
	}], [{
		key: "randomArray",
		value: function randomArray(jsonIn) {
			var arr = [];
			for (var n = 0; n < jsonIn.count; n++) {
				if (jsonIn.type === "float") arr.push(-(jsonIn.offset / 2) + Math.random() * jsonIn.offset);else arr.push(-(jsonIn.offset / 2) + Math.random() * jsonIn.offset, -(jsonIn.offset / 2) + Math.random() * jsonIn.offset, -(jsonIn.offset / 2) + Math.random() * jsonIn.offset, -(jsonIn.offset / 2) + Math.random() * jsonIn.offset);
			}

			return arr;
		}
	}, {
		key: "widthHeightArray",

		/**
  * @param {Object} jsonIn
  * @param {int} jsonIn.count - count
  * @param {number} jsonIn.width - width
  * @param {number} jsonIn.height - height
  * @param {number} [jsonIn.spacing=0.01] - Spacing
  * @return {Array<number>}
  */
		value: function widthHeightArray(jsonIn) {
			var arr = [];

			var totalDestinations = jsonIn.width * jsonIn.height;
			var nodesPerCell = jsonIn.count / totalDestinations;
			var nodesInCell = 0;
			var x = 0;
			var z = 0;
			var spacing = jsonIn.spacing !== undefined && jsonIn.spacing !== null ? jsonIn.spacing : 0.01;
			for (var n = 0; n < jsonIn.count; n++) {
				if (nodesInCell >= nodesPerCell) {
					x++;
					if (x > jsonIn.width - 1) {
						x = 0;
						z++;
					}
					nodesInCell -= nodesPerCell;
				}
				nodesInCell += 1;

				arr.push(x * spacing, 0, z * spacing, 1.0);
			}

			return arr;
		}
	}, {
		key: "float4Array",

		/**
  * @param {Object} jsonIn
  * @param {int} jsonIn.count - count
  * @param {Array<number>} jsonIn.float4 - direction
  * @return {Array<number>}
  */
		value: function float4Array(jsonIn) {
			var arr = [];
			for (var n = 0; n < jsonIn.count; n++) {
				arr.push(jsonIn.float4[0], jsonIn.float4[1], jsonIn.float4[2], jsonIn.float4[3]);
			}

			return arr;
		}
	}, {
		key: "sphericalArray",

		/**
  * @param {Object} jsonIn
  * @param {int} jsonIn.count - count
  * @param {number} [jsonIn.radius=1.0] - radius
  * @return {Array<number>}
  */
		value: function sphericalArray(jsonIn) {
			var arr = [];
			var rad = jsonIn === undefined ? 1.0 : jsonIn.radius;

			for (var n = 0; n < jsonIn.count; n++) {
				var currAngleH = Math.random() * 360.0;
				var currAngleV = Math.random() * 180.0;
				arr.push(Math.cos(currAngleH) * Math.abs(Math.sin(currAngleV)) * rad, Math.cos(currAngleV) * rad * Math.random(), Math.sin(currAngleH) * Math.abs(Math.sin(currAngleV)) * rad, 1.0);
			}

			return arr;
		}
	}, {
		key: "hemArray",

		/**
   * hemArray
   * @param {Object} jsonIn
   * @param {int} jsonIn.count - count
   * @param {number} [jsonIn.radius=1.0] - radius
   * @param {StormV3} jsonIn.normalVector
   * @param {number} jsonIn.degrees
   */
		value: function hemArray(jsonIn) {
			var arr = [];
			var rad = jsonIn === undefined ? 1.0 : jsonIn.radius;

			for (var n = 0; n < jsonIn.count; n++) {
				var v3 = new _Utils.Utils().getVector(jsonIn.normalVector, jsonIn.degrees);

				arr.push(v3.e[0] * rad, v3.e[1] * rad, v3.e[2] * rad, 1.0);
			}

			return arr;
		}
	}, {
		key: "imageArray",

		/**
  * @param {Object} jsonIn
  * @param {int} jsonIn.count - count
  * @param {HTMLImageElement} jsonIn.image - image
  * @return {Array<number>}
  */
		value: function imageArray(jsonIn) {
			var imgarr = _Utils.Utils.getUint8ArrayFromHTMLImageElement(jsonIn.image);
			var arr = [];
			for (var n = 0; n < jsonIn.count; n++) {
				var id = n * 4;
				arr.push(parseFloat(imgarr[id] / 255), parseFloat(imgarr[id + 1] / 255), parseFloat(imgarr[id + 2] / 255), parseFloat(imgarr[id + 3] / 255));
			}

			return arr;
		}
	}]);

	return ArrayGenerator;
}();

global.ArrayGenerator = ArrayGenerator;
module.exports.ArrayGenerator = ArrayGenerator;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Utils.class":3}],3:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Utils = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

require("webclgl");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* @class
*/
var Utils = exports.Utils = function () {
    function Utils() {
        _classCallCheck(this, Utils);

        window.requestAnimFrame = function () {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
        }();
    }

    /**
    * Get HTMLCanvasElement from Uint8Array
    * @param {Uint8Array} uint8arr
    * @param {int} width
    * @param {int} height
     * @returns {HTMLCanvasElement}
    */


    _createClass(Utils, [{
        key: "getImageFromCanvas",

        /**
         * @callback Utils~getImageFromCanvas~onload
         * @param {HTMLImageElement} img
         */
        /**
        * Get HTMLImageElement from canvas
        * @param {HTMLCanvasElement} oldCanvas
        * @param {Utils~getImageFromCanvas~onload} onload
        */
        value: function getImageFromCanvas(oldCanvas, onload) {
            var imagen = document.createElement('img');
            imagen.onload = function () {
                onload(imagen);
            };
            imagen.src = oldCanvas.toDataURL();
        }
    }, {
        key: "pack",


        /**
         * Angle between two vectors viewing from top
         * @returns {number}
         * @param {StormV3} vectorA
         * @param {StormV3} vectorB
          Utils.prototype.angle = function(vA, vB) {
            let vAA = vA.normalize();
            let vBB = vB.normalize();
              let escalarProduct = Math.acos((vAA.e[0]*vBB.e[0])+(vAA.e[1]*vBB.e[1])+(vAA.e[2]*vBB.e[2]));
              let vCC = vAA.cross(vBB);
            //console.log(vCC.e[0]+" "+vCC.e[1]+" "+vCC.e[2]);
              if(vCC.e[1] == 1) {
                escalarProduct = (Math.PI+escalarProduct);
            }
              return escalarProduct;
        };*/

        /**
        * Pack 1float (0.0-1.0) to 4float rgba (0.0-1.0, 0.0-1.0, 0.0-1.0, 0.0-1.0)*
        * @param {number} value
        * @returns {Array<number>}
        *
        */
        value: function pack(value) {
            var bias = [1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0];

            var r = value;
            var g = Utils.fract(r * 255.0);
            var b = Utils.fract(g * 255.0);
            var a = Utils.fract(b * 255.0);
            var colour = [r, g, b, a];

            var dd = [colour[1] * bias[0], colour[2] * bias[1], colour[3] * bias[2], colour[3] * bias[3]];

            return [colour[0] - dd[0], colour[1] - dd[1], colour[2] - dd[2], colour[3] - dd[3]];
        }
    }, {
        key: "unpack",

        /**
        * Unpack 4float rgba (0.0-1.0, 0.0-1.0, 0.0-1.0, 0.0-1.0) to 1float (0.0-1.0)
        * @param {Array<number>} value
         * @returns {number}
        */
        value: function unpack(value) {
            var bitShifts = [1.0, 1.0 / 255.0, 1.0 / (255.0 * 255.0), 1.0 / (255.0 * 255.0 * 255.0)];
            return Utils.dot4(value, bitShifts);
        }
    }], [{
        key: "getCanvasFromUint8Array",
        value: function getCanvasFromUint8Array(uint8arr, width, height) {
            var e = document.createElement('canvas');
            e.width = width;
            e.height = height;
            var ctx2D = e.getContext("2d");
            var image = ctx2D.createImageData(width, height);
            for (var i = 0; i < image.data.length; i++) {
                image.data[i] = uint8arr[i];
            }ctx2D.putImageData(image, 0, 0);

            return e;
        }
    }, {
        key: "getUint8ArrayFromHTMLImageElement",


        /**
        * Get Uint8Array from HTMLImageElement
        * @param {HTMLImageElement} imageElement
         * @returns {Uint8ClampedArray}
        */
        value: function getUint8ArrayFromHTMLImageElement(imageElement) {
            var e = document.createElement('canvas');
            e.width = imageElement.width;
            e.height = imageElement.height;
            var ctx2D_tex = e.getContext("2d");
            ctx2D_tex.drawImage(imageElement, 0, 0);
            var arrayTex = ctx2D_tex.getImageData(0, 0, imageElement.width, imageElement.height);

            return arrayTex.data;
        }
    }, {
        key: "getVector",


        /**
        * Get random vector from vecNormal with deviation in degrees
        * @param {StormV3} vecNormal
        * @param {number} degrees
         * @returns {StormV3}
        */
        value: function getVector(vecNormal, degrees) {
            var ob = Utils.cartesianToSpherical(vecNormal);
            var angleLat = ob.lat;
            var angleLng = ob.lng;

            var desvLat = Math.random() * 180.0 - 90.0;
            var desvLng = Math.random() * 180.0 - 90.0;
            angleLat += degrees * desvLat;
            angleLng += degrees * desvLng;

            return Utils.sphericalToCartesian(1.0, angleLat, angleLng);
        }
    }, {
        key: "getVectorGLSLFunctionString",

        /**
        * Get random vector from vecNormal with deviation in degrees (GLSL)
        * @returns {String}
        */
        value: function getVectorGLSLFunctionString() {
            return 'vec3 getVector(vec3 vecNormal, float degrees, vec2 vecNoise) {\n' + 'vec3 ob = cartesianToSpherical(vecNormal);' + 'float angleLat = ob.y;' + 'float angleLng = ob.z;' + 'float desvLat = (vecNoise.x*180.0)-90.0;' + 'float desvLng = (vecNoise.y*180.0)-90.0;' + 'angleLat += (degrees*desvLat);' + 'angleLng += (degrees*desvLng);' + 'return sphericalToCartesian(vec3(1.0, angleLat, angleLng));' + '}\n';
        }
    }, {
        key: "cartesianToSpherical",


        /**
         * cartesianToSpherical
         * @param {StormV3} vec
         * @returns {Object}
         * @example
         * $V3([1,0,0])  return {radius: 1, lat: 90, lng: 0}
         * $V3([0,0,1])  return {radius: 1, lat: 90, lng: 90}
         * $V3([-1,0,0]) return {radius: 1, lat: 90, lng: 180}
         * $V3([0,0,-1]) return {radius: 1, lat: 90, lng: -90}
         */
        value: function cartesianToSpherical(vec) {
            var r = Math.sqrt(vec.e[0] * vec.e[0] + vec.e[1] * vec.e[1] + vec.e[2] * vec.e[2]);

            var angleLat = Utils.radToDeg(Math.acos(vec.e[1] / r));
            var angleLng = Utils.radToDeg(Math.atan2(vec.e[2], vec.e[0]));

            return { "radius": r,
                "lat": angleLat,
                "lng": angleLng };
        }
    }, {
        key: "cartesianToSphericalGLSLFunctionString",

        /**
         * cartesianToSpherical (GLSL)
        * @returns {String}
        */
        value: function cartesianToSphericalGLSLFunctionString() {
            return 'vec3 cartesianToSpherical(vec3 vect) {\n' + 'float r = sqrt(vect.x*vect.x + vect.y*vect.y + vect.z*vect.z);' + 'float angleLat = radToDeg(acos(vect.y/r));' + 'float angleLng = radToDeg(atan(vect.z, vect.x));' + 'return vec3(r, angleLat, angleLng);' + '}\n';
        }
    }, {
        key: "sphericalToCartesian",


        /**
         * sphericalToCartesian
         * @param {number} radius
         * @param {number} lat Lat in degrees
         * @param {number} lng Lng in degrees
         * @returns {StormV3}
         * @example
         * (1.0, 90.0, 0.0).e) return $V3([1,0,0])
         * (1.0, 90.0, 90.0).e) return $V3([0,0,1])
         * (1.0, 90.0, 180.0).e) return $V3([-1,0,0])
         * (1.0, 90.0, -90.0).e) return $V3([0,0,-1])
         **/
        value: function sphericalToCartesian(radius, lat, lng) {
            var r = radius;
            var angleLat = Utils.degToRad(lat);
            var angleLng = Utils.degToRad(lng);

            var x = r * Math.sin(angleLat) * Math.cos(angleLng);
            var z = r * Math.sin(angleLat) * Math.sin(angleLng);
            var y = r * Math.cos(angleLat);

            return new StormV3([x, y, z]);
        }
    }, {
        key: "sphericalToCartesianGLSLFunctionString",

        /**
         * sphericalToCartesian (GLSL)
        * @returns {String}
        */
        value: function sphericalToCartesianGLSLFunctionString() {
            return 'vec3 sphericalToCartesian(vec3 vect) {\n' + 'float r = vect.x;' + 'float angleLat = degToRad(vect.y);' + 'float angleLng = degToRad(vect.z);' + 'float x = r*sin(angleLat)*cos(angleLng);' + 'float z = r*sin(angleLat)*sin(angleLng);' + 'float y = r*cos(angleLat);' + 'return vec3(x,y,z);' + '}\n';
        }
    }, {
        key: "refract",


        /**
        * Refract
        * @param {StormV3} V
        * @param {StormV3} N
        * @param {number} n1 Refract index way 1
        * @param {number} n2 Refract index way 2
         * @returns {StormV3}
        */
        value: function refract(V, N, n1, n2) {
            var refrIndex = n1 / n2;
            var cosI = N.dot(V) * -1.0;
            var cosT2 = 1.0 - refrIndex * refrIndex * (1.0 - cosI * cosI);
            var vv = V.x(refrIndex);
            return vv.add(N.x(refrIndex * cosI - Math.sqrt(cosT2)));
        }
    }, {
        key: "degToRad",


        /**
        * Degrees to radians. Full circle = 360 degrees.
        * @param {number} degrees
         * @returns {number}
        */
        value: function degToRad(degrees) {
            return degrees * 3.14159 / 180;
        }
    }, {
        key: "degToRadGLSLFunctionString",

        /**
         * Degrees to radians. Full circle = 360 degrees. (GLSL)
        * @returns {String}
        */
        value: function degToRadGLSLFunctionString() {
            return 'float degToRad(float deg) {' + 'return (deg*3.14159)/180.0;' + '}';
        }
    }, {
        key: "radToDeg",


        /**
        * Radians to degrees
        * @param {number} radians
         * @returns {number}
        */
        value: function radToDeg(radians) {
            return radians * (180 / 3.14159);
        }
    }, {
        key: "radToDegGLSLFunctionString",

        /**
         * Radians to degrees (GLSL)
        * @returns {String}
        */
        value: function radToDegGLSLFunctionString() {
            return 'float radToDeg(float rad) {' + 'return rad*(180.0/3.14159);' + '}';
        }
    }, {
        key: "hexToRgb",


        /**
         * hexToRgb
         * @param {String} hex
         * @returns  {Array<number>} rgb values from 0 to 255
         */
        value: function hexToRgb(hex) {
            // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                return r + r + g + g + b + b;
            });

            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
    }, {
        key: "rgbToHex",

        /**
         * rgbToHex
         * @param {Array<number>} rgb values from 0 to 255
         * @returns {String}
         */
        value: function rgbToHex(rgb) {
            var rgbVal = rgb[2] | rgb[1] << 8 | rgb[0] << 16;
            return '#' + (0x1000000 + rgbVal).toString(16).slice(1);
        }
    }, {
        key: "invsqrt",


        /**
        * Inverse sqrt
        * @param {number} value
         * @returns {number}
        */
        value: function invsqrt(value) {
            return 1.0 / value;
        }
    }, {
        key: "smoothstep",


        /**
        * Smoothstep
        * @param {number} edge0
        * @param {number} edge1
        * @param {number} current
         * @returns {number}
        */
        value: function smoothstep(edge0, edge1, current) {
            if (current < edge0) return 0;
            if (current >= edge1) return 1;
            if (edge0 === edge1) return -1;
            var p = (current - edge0) / (edge1 - edge0);

            return p * p * (3 - 2 * p);
        }
    }, {
        key: "dot4",


        /**
        * Dot product vector4float
        * @param {Array<number>} vector4A Vector a
        * @param {Array<number>} vector4B Vector b
         * @returns {number}
        */
        value: function dot4(vector4A, vector4B) {
            return vector4A[0] * vector4B[0] + vector4A[1] * vector4B[1] + vector4A[2] * vector4B[2] + vector4A[3] * vector4B[3];
        }
    }, {
        key: "fract",


        /**
        * Compute the fractional part of the argument. Example: fract(pi)=0.14159265...
        * @param {number} value
         * @returns {number}
        */
        value: function fract(value) {
            return value > 0 ? value - Math.floor(value) : value - Math.ceil(value);
        }
    }, {
        key: "packGLSLFunctionString",

        /**
        * Get pack GLSL function string
        * @returns {String}
        */
        value: function packGLSLFunctionString() {
            return 'vec4 pack (float depth) {' + 'const vec4 bias = vec4( 1.0 / 255.0,' + '1.0 / 255.0,' + '1.0 / 255.0,' + '0.0);' + 'float r = depth;' + 'float g = fract(r * 255.0);' + 'float b = fract(g * 255.0);' + 'float a = fract(b * 255.0);' + 'vec4 colour = vec4(r, g, b, a);' + 'return colour - (colour.yzww * bias);' + '}';
        }
    }, {
        key: "unpackGLSLFunctionString",

        /**
        * Get unpack GLSL function string
        * @returns {String}
        */
        value: function unpackGLSLFunctionString() {
            return 'float unpack (vec4 colour) {' + 'const vec4 bitShifts = vec4(1.0,' + '1.0 / 255.0,' + '1.0 / (255.0 * 255.0),' + '1.0 / (255.0 * 255.0 * 255.0));' + 'return dot(colour, bitShifts);' + '}';
        }
    }, {
        key: "rayTraversalInitSTR",
        value: function rayTraversalInitSTR() {
            return '' + 'float wh = ceil(sqrt(uResolution*uResolution*uResolution));\n' + 'float cs = uGridsize/uResolution;\n' + // cell size
            'float chs = cs/2.0;\n' + // cell size
            'float texelSize = 1.0/(wh-1.0);\n' + // 1.0/(wh-1.0)??

            // Fast Voxel Traversal Algorithm for Ray Tracing. John Amanatides & Andrew Woo.
            // http://www.cse.chalmers.se/edu/course/TDA361/grid.pdf
            // More info:
            // http://www.clockworkcoders.com/oglsl/rt/gpurt3.htm
            'vec3 gl = vec3(-(uGridsize/2.0), -(uGridsize/2.0), -(uGridsize/2.0));\n' + 'vec3 _r = vec3(uGridsize, uGridsize, uGridsize);\n' + 'vec3 _rRes = vec3(uResolution, uResolution, uResolution);\n' + 'vec3 _len = _r/_rRes;\n' + 'vec3 worldToVoxel(vec3 world) {\n' + 'vec3 ijk = (world - gl) / _len;\n' + // (1.0-(-1.0)) / (2/64) = 64
            'ijk = vec3(floor(ijk.x), floor(ijk.y), floor(ijk.z));\n' + 'return ijk;\n' + '}\n' + 'float voxelToWorldX(float x) {return x * _len.x + gl.x;}\n' + // 64*(2/64)+(-1.0) = 1.0
            'float voxelToWorldY(float y) {return y * _len.y + gl.y;}\n' + 'float voxelToWorldZ(float z) {return z * _len.z + gl.z;}\n';
        }
    }, {
        key: "rayTraversalSTR",
        value: function rayTraversalSTR(resolution) {
            return '' + 'vec2 getId(vec3 voxel) {\n' + 'int tex3dId = (int(voxel.y)*(int(uResolution)*int(uResolution)))+(int(voxel.z)*(int(uResolution)))+int(voxel.x);\n' + 'float num = float(tex3dId)/wh;\n' + 'float col = fract(num)*wh;\n' + 'float row = floor(num);\n' + 'return vec2(col*texelSize, row*texelSize);\n' + '}\n' + 'vec4 getVoxel_Color(vec2 texVec, vec3 voxel, vec3 RayOrigin) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelColor[vec2(texVec.x, texVec.y)];\n' + 'if(texture.a/255.0 > 0.5) {\n' + // existen triángulos dentro?
            'rgba = vec4(texture.rgb/255.0,distance(vec3(voxelToWorldX(voxel.x), voxelToWorldX(voxel.y), voxelToWorldX(voxel.z)),RayOrigin));\n' + '}\n' + 'return rgba;\n' + '}\n' + 'vec4 getVoxel_Pos(vec2 texVec) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelPos[vec2(texVec.x, texVec.y)];\n' +
            //distance(vec3(voxelToWorldX(voxel.x), voxelToWorldX(voxel.y), voxelToWorldX(voxel.z)),RayOrigin)
            'rgba = vec4( ((texture.xyz/255.0)*uGridsize)-(uGridsize/2.0), 1.0);\n' + 'return rgba;\n' + '}\n' + 'vec4 getVoxel_Normal(vec2 texVec) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelNormal[vec2(texVec.x, texVec.y)];\n' + 'rgba = vec4(((texture.rgb/255.0)*2.0)-1.0, 1.0);\n' + 'return rgba;\n' + '}\n' + 'struct RayTraversalResponse {' + 'vec4 voxelColor;' + 'vec4 voxelPos;' + 'vec4 voxelNormal;' + '};' + 'RayTraversalResponse rayTraversal(vec3 RayOrigin, vec3 RayDir) {\n' + 'vec4 fvoxelColor = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec4 fvoxelPos = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec4 fvoxelNormal = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec3 voxel = worldToVoxel(RayOrigin);' + 'vec3 _dir = normalize(RayDir);' + 'vec3 tMax;' + 'if(RayDir.x < 0.0) tMax.x = (voxelToWorldX(voxel.x)-RayOrigin.x)/RayDir.x;' + 'if(RayDir.x > 0.0) tMax.x = (voxelToWorldX(voxel.x+1.0)-RayOrigin.x)/RayDir.x;' + 'if(RayDir.y < 0.0) tMax.y = (voxelToWorldY(voxel.y)-RayOrigin.y)/RayDir.y;' + 'if(RayDir.y < 0.0) tMax.y = (voxelToWorldY(voxel.y+1.0)-RayOrigin.y)/RayDir.y;' + 'if(RayDir.z < 0.0) tMax.z = (voxelToWorldZ(voxel.z)-RayOrigin.z)/RayDir.z;' + 'if(RayDir.z < 0.0) tMax.z = (voxelToWorldZ(voxel.z+1.0)-RayOrigin.z)/RayDir.z;' + 'float tDeltaX = _r.x/abs(RayDir.x);' + // hasta qué punto se debe avanzar en la dirección del rayo antes de que nos encontramos con un nuevo voxel en la dirección x
            'float tDeltaY = _r.y/abs(RayDir.y);' + 'float tDeltaZ = _r.z/abs(RayDir.z);' + 'float stepX = 1.0; float stepY = 1.0; float stepZ = 1.0;\n' + 'float outX = _r.x; float outY = _r.y; float outZ = _r.z;\n' + 'if(RayDir.x < 0.0) {stepX = -1.0; outX = -1.0;}' + 'if(RayDir.y < 0.0) {stepY = -1.0; outY = -1.0;}' + 'if(RayDir.z < 0.0) {stepZ = -1.0; outZ = -1.0;}' + 'vec4 color = vec4(0.0,0.0,0.0,0.0);\n' + 'bool c1; bool c2; bool c3; bool isOut;' + 'vec2 vid;' + 'for(int c = 0; c < ' + resolution + '*2; c++) {\n' + 'c1 = bool(tMax.x < tMax.y);' + 'c2 = bool(tMax.x < tMax.z);' + 'c3 = bool(tMax.y < tMax.z);' + 'isOut = false;' + 'if (c1 && c2) {' + 'voxel.x += stepX;' + 'if(voxel.x==outX) isOut=true;' + 'tMax.x += tDeltaX;' + '} else if(( (c1 && !c2) || (!c1 && !c3) )) {' + 'voxel.z += stepZ;' + 'if(voxel.z==outZ) isOut=true;' + 'tMax.z += tDeltaZ;' + '} else if(!c1 && c3) {' + 'voxel.y += stepY;' + 'if(voxel.y==outY) isOut=true;' + 'tMax.y += tDeltaY;' + '}' + 'if(isOut == true) break;\n' + 'else {' + 'if((voxel.x >= 0.0 && voxel.x <= _rRes.x && voxel.y >= 0.0 && voxel.y <= _rRes.y && voxel.z >= 0.0 && voxel.z <= _rRes.z)) {;\n' + 'vid = getId(voxel);' + 'vec4 vcc = getVoxel_Color(vid, voxel, RayOrigin);' + 'if(vcc.a != 0.0) {' + 'fvoxelColor = vcc;' + 'break;\n' + '}' + '}' + '}' + '}' + 'fvoxelPos = getVoxel_Pos(vid);' + 'fvoxelNormal = getVoxel_Normal(vid);' + 'return RayTraversalResponse(fvoxelColor, fvoxelPos, fvoxelNormal);' + '}\n';
        }
    }, {
        key: "isPowerOfTwo",
        value: function isPowerOfTwo(x) {
            return (x & x - 1) === 0;
        }
    }, {
        key: "nextHighestPowerOfTwo",
        value: function nextHighestPowerOfTwo(x) {
            --x;
            for (var i = 1; i < 32; i <<= 1) {
                x = x | x >> i;
            }
            return x + 1;
        }
    }, {
        key: "getElementPosition",
        value: function getElementPosition(element) {
            var elem = element,
                tagname = "",
                x = 0,
                y = 0;

            while ((typeof elem === "undefined" ? "undefined" : _typeof(elem)) === "object" && typeof elem.tagName !== "undefined") {
                y += elem.offsetTop;
                x += elem.offsetLeft;
                tagname = elem.tagName.toUpperCase();

                if (tagname === "BODY") elem = 0;

                if ((typeof elem === "undefined" ? "undefined" : _typeof(elem)) === "object") {
                    if (_typeof(elem.offsetParent) === "object") elem = elem.offsetParent;
                }
            }

            return { x: x, y: y };
        }
    }, {
        key: "getWebGLContextFromCanvas",
        value: function getWebGLContextFromCanvas(canvas, ctxOpt) {
            return WebCLGLUtils.getWebGLContextFromCanvas(canvas, ctxOpt);
        }
    }, {
        key: "fullScreen",
        value: function fullScreen() {
            if (!document.fullscreenElement && // alternative standard method
            !document.mozFullScreenElement && !document.webkitFullscreenElement) {
                // current working methods
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) {
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                }
            } else {
                if (document.cancelFullScreen) {
                    document.cancelFullScreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen();
                }
            }
        }
    }]);

    return Utils;
}();

global.Utils = Utils;
module.exports.Utils = Utils;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"webclgl":1}]},{},[2]);
