(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
									value: true
});
exports.VFP_RGB = VFP_RGB;
function VFP_RGB(textureUnitCount) {
									this.getSrc = function () {
																		return [["RGB"],
																		// vertex head
																		'varying vec4 vVN;\n' + 'varying vec4 vVT;\n' + 'varying float vVTU;\n',

																		// vertex source
																		'vec4 vp = vertexPos[];\n' + 'vec4 vn = vertexNormal[];\n' + 'vec4 vt = vertexTexture[];\n' + 'float vtu = vertexTextureUnit[];\n' + 'vVN = vn;' + 'vVT = vt;' + 'vVTU = vtu;' + 'gl_Position = PMatrix * cameraWMatrix * nodeWMatrix * vp;\n',

																		// fragment head
																		'varying vec4 vVN;\n' + 'varying vec4 vVT;\n' + 'varying float vVTU;\n',

																		// fragment source
																		'vec4 textureColor = texture2D(texAlbedo, vVT.xy);\n' +
																		// diffuse
																		'return [textureColor];\n'];
									};
}
global.VFP_RGB = VFP_RGB;
module.exports.VFP_RGB = VFP_RGB;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1]);
