(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

var exp = { "WebCLGL": "./WebCLGL.class",
            "WebCLGLBuffer": "./WebCLGLBuffer.class.js",
            "WebCLGLFor": "./WebCLGLFor.class.js",
            "WebCLGLKernel": "./WebCLGLKernel.class.js",
            "WebCLGLUtils": "./WebCLGLUtils.class.js",
            "WebCLGLVertexFragmentProgram": "./WebCLGLVertexFragmentProgram.class.js"
};

for(var key in exp)
    exports[key] = require(exp[key]);
},{}],2:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var Constants = exports.Constants = {
	"EVENT_TYPES": {
		"KEY_DOWN": 0,
		"KEY_UP": 1,
		"MOUSE_DOWN": 2,
		"MOUSE_UP": 3,
		"MOUSE_MOVE": 4,
		"MOUSE_WHEEL": 5
	},
	"COMPONENT_TYPES": {
		"KEYBOARD_EVENTS": 0,
		"MOUSE_EVENTS": 1,
		"TRANSFORM": 2,
		"TRANSFORM_TARGET": 3,
		"CONTROLLER_TRANSFORM_TARGET": 4,
		"PROJECTION": 5,
		"GPU": 6
	},
	"PROJECTION_TYPES": {
		"PERSPECTIVE": 0,
		"ORTHO": 1
	},
	"VIEW_TYPES": {
		"LEFT": 0,
		"RIGHT": 1,
		"FRONT": 2,
		"BACK": 3,
		"TOP": 4,
		"BOTTOM": 5
	},
	"BLENDING_MODES": {
		"ZERO": "ZERO",
		"ONE": "ONE",
		"SRC_COLOR": "SRC_COLOR",
		"ONE_MINUS_SRC_COLOR": "ONE_MINUS_SRC_COLOR",
		"DST_COLOR": "DST_COLOR",
		"ONE_MINUS_DST_COLOR": "ONE_MINUS_DST_COLOR",
		"SRC_ALPHA": "SRC_ALPHA",
		"ONE_MINUS_SRC_ALPHA": "ONE_MINUS_SRC_ALPHA",
		"DST_ALPHA": "DST_ALPHA",
		"ONE_MINUS_DST_ALPHA": "ONE_MINUS_DST_ALPHA",
		"SRC_ALPHA_SATURATE": "SRC_ALPHA_SATURATE",
		"CONSTANT_COLOR": "CONSTANT_COLOR",
		"ONE_MINUS_CONSTANT_COLOR": "ONE_MINUS_CONSTANT_COLOR",
		"CONSTANT_ALPHA": "CONSTANT_ALPHA",
		"ONE_MINUS_CONSTANT_ALPHA": "ONE_MINUS_CONSTANT_ALPHA"
	},
	"BLENDING_EQUATION_TYPES": {
		"FUNC_ADD": "FUNC_ADD",
		"FUNC_SUBTRACT": "FUNC_SUBTRACT",
		"FUNC_REVERSE_SUBTRACT": "FUNC_REVERSE_SUBTRACT"
	},
	"DRAW_MODES": {
		"POINTS": 0,
		"LINES": 1,
		"LINE_LOOP": 2,
		"LINE_STRIP": 3,
		"TRIANGLES": 4,
		"TRIANGLE_STRIP": 5,
		"TRIANGLE_FAN": 6
	}
};
global.Constants = Constants;
module.exports.Constants = Constants;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Voxelizator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Utils = require("../../Utils.class");

var _Constants = require("../../Constants");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* @class
*/
var Voxelizator = exports.Voxelizator = function () {
    function Voxelizator(sce) {
        _classCallCheck(this, Voxelizator);

        this._sce = sce;
        this._project = this._sce.getLoadedProject();
        this._gl = this._project.getActiveStage().getWebGLContext();
        this._utils = new _Utils.Utils();

        this._makeVoxels = false;
        this._mesh = null;
        this._size = null;
        this._resolution = null;
        this._cs = null;
        this._chs = null;
        this._wh = null;
        this._arr_VoxelsColor = null;
        this._arr_VoxelsPosition = null;
        this._arr_VoxelsNormal = null;
        this._typeFillMode = null;
        this._currentHeight = null;
        this._currentOffset = null;

        this._nativePosTarget = null;
        this._nativePosGoal = null;
        this._nativeTargetDistance = null;
        this._nativeDimensions = null;
        this._ongeneratefunction = null;

        this._image3D_VoxelsColor = null;
        this._image3D_VoxelsPosition = null;
        this._image3D_VoxelsNormal = null;

        this.nodes = new Node();
        this.nodes.setName("voxelizator");
        this._project.getActiveStage().addNode(this.nodes);

        // ComponentTransform
        var comp_transform = new ComponentTransform();
        this.nodes.addComponent(comp_transform);

        // Component_GPU
        this.comp_renderer_node = new Component_GPU();
        this.nodes.addComponent(this.comp_renderer_node);

        this.comp_renderer_node.setGPUFor(this.comp_renderer_node.gl, { // VFP_RGB
            "float4*attr vertexPos": function () {
                return null;
            }.bind(this),
            "float4*attr vertexNormal": function () {
                return null;
            }.bind(this),
            "float4*attr vertexTexture": function () {
                return null;
            }.bind(this),
            "float*attr vertexTextureUnit": function () {
                return null;
            }.bind(this),
            "indices": function () {
                return null;
            }.bind(this),
            "mat4 PMatrix": function () {
                return null;
            }.bind(this),
            "mat4 cameraWMatrix": function () {
                return null;
            }.bind(this),
            "mat4 nodeWMatrix": function () {
                return null;
            }.bind(this),

            'float uGridsize': function () {
                return null;
            }.bind(this),
            'float uResolution': function () {
                return null;
            }.bind(this),
            'float uCurrentOffset': function () {
                return null;
            }.bind(this),
            'float uCurrentHeight': function () {
                return null;
            }.bind(this),
            'float uTypeFillMode': function () {
                return null;
            }.bind(this),

            'float4* texAlbedo': function () {
                return null;
            }.bind(this) }, { "type": "GRAPHIC",
            "name": "VOXELIZATOR",
            "viewSource": false,
            "config": [undefined,
            // vertex head
            'varying vec4 vVPos;\n' + 'varying vec4 vVN;\n' + 'varying vec4 vVT;\n' + 'varying float vVTU;\n' + 'mat4 lookAt(vec3 eye, vec3 center, vec3 up) {' + 'vec3 zaxis = normalize(center - eye);' + 'vec3 xaxis = normalize(cross(up, zaxis));' + 'vec3 yaxis = cross(zaxis, xaxis);' + 'mat4 matrix;' +
            //Column Major
            'matrix[0][0] = xaxis.x;' + 'matrix[1][0] = yaxis.x;' + 'matrix[2][0] = zaxis.x;' + 'matrix[3][0] = 0.0;' + 'matrix[0][1] = xaxis.y;' + 'matrix[1][1] = yaxis.y;' + 'matrix[2][1] = zaxis.y;' + 'matrix[3][1] = 0.0;' + 'matrix[0][2] = xaxis.z;' + 'matrix[1][2] = yaxis.z;' + 'matrix[2][2] = zaxis.z;' + 'matrix[3][2] = 0.0;' + 'matrix[0][3] = -dot(xaxis, eye);' + 'matrix[1][3] = -dot(yaxis, eye);' + 'matrix[2][3] = -dot(zaxis, eye);' + 'matrix[3][3] = 1.0;' + 'return matrix;' + '}' + 'mat4 transpose(mat4 m) {' + 'return mat4(  m[0][0], m[1][0], m[2][0], m[3][0],' + 'm[0][1], m[1][1], m[2][1], m[3][1],' + 'm[0][2], m[1][2], m[2][2], m[3][2],' + 'm[0][3], m[1][3], m[2][3], m[3][3]);' + '}',

            // vertex source
            'float gridSize = uGridsize;' + 'int maxLevelCells = int(uResolution);' + 'float cs = gridSize/float(maxLevelCells);\n' + // cell size


            'mat4 mCam = transpose(lookAt( 	vec3(0.0, (-(gridSize/2.0)+(uCurrentHeight*cs)), 0.0),' + 'vec3(0.0, (-(gridSize/2.0)+(uCurrentHeight*cs))-1.0, 0.001),' + 'vec3(0.0, 1.0, 0.0)));' + 'vec3 vp = vertexPos[].xyz;\n' + 'vp = vp*vec3(1.0, 1.0, 1.0);' + 'vec4 vPosition = PMatrix*mCam*nodeWMatrix*vec4(vp,1.0);' + 'float lengthOffs = 0.005*gridSize*vPosition.z;' + 'int currOffs = int(uCurrentOffset);' + 'if(currOffs == 0) vp = vp+vec3(lengthOffs,	0.0,	lengthOffs);' + 'if(currOffs == 1) vp = vp+vec3(-lengthOffs,	0.0,	-lengthOffs);' + 'if(currOffs == 2) vp = vp+vec3(-lengthOffs,	0.0,	lengthOffs);' + 'if(currOffs == 3) vp = vp+vec3(lengthOffs,	0.0,	-lengthOffs);' + 'if(currOffs == 4) vp = vp+vec3(0.0,		0.0,	lengthOffs);' + 'if(currOffs == 5) vp = vp+vec3(0.0,		0.0,	-lengthOffs);' + 'if(currOffs == 6) vp = vp+vec3(lengthOffs,	0.0,	0.0);' + 'if(currOffs == 7) vp = vp+vec3(-lengthOffs,	0.0,	0.0);' + 'gl_Position = PMatrix * mCam * nodeWMatrix * vec4(vp, 1.0);\n' + 'vVPos = vec4(vertexPos[].xyz*vec3(1.0, 1.0, 1.0), 1.0);' + 'vVN = vertexNormal[]*vec4(1.0, 1.0, 1.0, 1.0);\n' + 'vVT = vertexTexture[];\n' + 'vVTU = vertexTextureUnit[];\n',

            // fragment head
            'varying vec4 vVPos;\n' + 'varying vec4 vVN;\n' + 'varying vec4 vVT;\n' + 'varying float vVTU;\n' + _Utils.Utils.packGLSLFunctionString(),

            // fragment source
            'int fillMode = int(uTypeFillMode);' + 'vec4 fColor;' + 'if(fillMode == 0) {' + // fill with albedo
            'fColor = texAlbedo[vVT.xy];\n' + '} else if(fillMode == 1) {' + // fill with position
            'float gridSize = uGridsize;' + 'int maxLevelCells = int(uResolution);' + 'float cs = gridSize/float(maxLevelCells);\n' + // cell size
            'float chs = cs/2.0;\n' + 'vec3 p = (vVPos.xyz+(gridSize/2.0))/gridSize;' + 'fColor = vec4(p, 1.0);\n' + '} else if(fillMode == 2) {' + // fill with normal
            'fColor = vec4((vVN.r+1.0)/2.0,(vVN.g+1.0)/2.0,(vVN.b+1.0)/2.0, 1.0);\n' + '}' + 'return fColor;'],
            "drawMode": 4,
            "depthTest": true,
            "blend": true,
            "blendEquation": _Constants.Constants.BLENDING_EQUATION_TYPES.FUNC_ADD,
            "blendSrcMode": _Constants.Constants.BLENDING_MODES.SRC_ALPHA,
            "blendDstMode": _Constants.Constants.BLENDING_MODES.ONE_MINUS_SRC_ALPHA });
        this.comp_renderer_node.gpufG.onPreProcessGraphic(0, function () {
            var comp_screenEffects = this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.GPU);
            //comp_screenEffects.gl.blendFunc(this.comp_renderer_node.gl[Constants.BLENDING_MODES.ONE_MINUS_SRC_COLOR], this.comp_renderer_node.gl[Constants.BLENDING_MODES.SRC_COLOR]);

            if (this._makeVoxels === true) {
                this.comp_renderer_node.setArg("uCurrentHeight", function () {
                    return this._currentHeight;
                }.bind(this));

                var fm = void 0;
                if (this._typeFillMode[0] === "albedo") fm = 0;else if (this._typeFillMode[0] === "position") fm = 1;else if (this._typeFillMode[0] === "normal") fm = 2;
                this.comp_renderer_node.setArg("uTypeFillMode", function () {
                    return fm;
                }.bind(this));

                // CAMERA CURRENT HEIGHT POSITION
                var p = $V3([0.0, 0.0, 0.0]);
                var pc = p.add($V3([0.0, -1.0, 0.0]));
                var comp_cam_tf_target = this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.TRANSFORM_TARGET);
                comp_cam_tf_target.setPositionTarget(p);
                comp_cam_tf_target.setPositionGoal(pc);
                comp_cam_tf_target.pitch(180);
                comp_cam_tf_target.yaw(-90);
                comp_cam_tf_target.setTargetDistance(0.00001);

                this.comp_renderer_node.setArg("uCurrentOffset", function () {
                    return this._currentOffset;
                }.bind(this));
                if (this._currentOffset === 0) {
                    //this._gl.clearColor(0.0,0.0,0.0,0.0);
                    //this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
                }
            }
        }.bind(this));
        this.comp_renderer_node.gpufG.onPostProcessGraphic(0, function () {
            if (this._makeVoxels === true) {
                var setadd = function (arrOrig, addarr, id) {
                    var idOrig = id / 4;
                    for (var n = 0; n < addarr.length / 4; n++) {
                        var iddOrig = idOrig * 4;
                        var iddAdd = n * 4;

                        if (arrOrig[iddOrig + 3] === 0) {
                            arrOrig[iddOrig] = addarr[iddAdd];
                            arrOrig[iddOrig + 1] = addarr[iddAdd + 1];
                            arrOrig[iddOrig + 2] = addarr[iddAdd + 2];
                            arrOrig[iddOrig + 3] = addarr[iddAdd + 3];
                        } else {
                            arrOrig[iddOrig] = arrOrig[iddOrig];
                            arrOrig[iddOrig + 1] = arrOrig[iddOrig + 1];
                            arrOrig[iddOrig + 2] = arrOrig[iddOrig + 2];
                            arrOrig[iddOrig + 3] = arrOrig[iddOrig + 3];
                        }

                        idOrig++;
                    }
                    return arrOrig;
                }.bind(this);

                var heightImageResult = new Uint8Array(this._resolution * this._resolution * 4);
                this._gl.readPixels(0, 0, this._resolution, this._resolution, this._gl.RGBA, this._gl.UNSIGNED_BYTE, heightImageResult);

                var idx3d = this._currentHeight * (this._resolution * this._resolution) * 4;
                var num = idx3d / this._wh;
                var col = _Utils.Utils.fract(num) * this._wh;
                var row = Math.floor(num);
                if (this._typeFillMode[0] === "albedo") this._arr_VoxelsColor = setadd(this._arr_VoxelsColor, heightImageResult, idx3d);else if (this._typeFillMode[0] === "position") this._arr_VoxelsPosition = setadd(this._arr_VoxelsPosition, heightImageResult, idx3d);else if (this._typeFillMode[0] === "normal") this._arr_VoxelsNormal = setadd(this._arr_VoxelsNormal, heightImageResult, idx3d);

                if (this._currentOffset === 7) {
                    this._currentHeight++;
                    this._currentOffset = 0;
                } else {
                    this._currentOffset++;
                }

                if (this._currentHeight === this._resolution) {
                    this._currentHeight = 0;

                    if (this._typeFillMode[0] === "albedo") this.setVoxels({ 'fillMode': 'albedo', 'arr3d': this._arr_VoxelsColor, 'wh': this._wh });else if (this._typeFillMode[0] === "position") this.setVoxels({ 'fillMode': 'position', 'arr3d': this._arr_VoxelsPosition, 'wh': this._wh });else if (this._typeFillMode[0] === "normal") this.setVoxels({ 'fillMode': 'normal', 'arr3d': this._arr_VoxelsNormal, 'wh': this._wh });

                    this._typeFillMode.shift();

                    if (this._typeFillMode.length === 0) {
                        this._makeVoxels = false;
                        this.comp_renderer_node.gpufG.disableGraphic(0);

                        var comp_projection = this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.PROJECTION);
                        comp_projection.setNear(-1000.0);
                        comp_projection.setFar(1000.0);
                        comp_projection.setProjection(_Constants.Constants.PROJECTION_TYPES.PERSPECTIVE);

                        this._sce.setDimensions(this._nativeDimensions.width, this._nativeDimensions.height);

                        var comp_cam_tf_target = this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.TRANSFORM_TARGET);
                        comp_cam_tf_target.setPositionTarget(this._nativePosTarget);
                        comp_cam_tf_target.setPositionGoal(this._nativePosGoal);
                        comp_cam_tf_target.setTargetDistance(this._nativeTargetDistance);
                    }
                }
            }
        }.bind(this));
        this.comp_renderer_node.gpufG.disableGraphic(0);
    }

    _createClass(Voxelizator, [{
        key: "setVoxels",
        value: function setVoxels(jsonIn) {
            if (jsonIn.fillMode === "albedo") {
                var canvas = jsonIn.arr3d instanceof Uint8Array ? _Utils.Utils.getCanvasFromUint8Array(jsonIn.arr3d, jsonIn.wh, jsonIn.wh) : _Utils.Utils.getCanvasFromUint8Array(_Utils.Utils.getUint8ArrayFromHTMLImageElement(jsonIn.arr3d), jsonIn.wh, jsonIn.wh);
                this._utils.getImageFromCanvas(canvas, function (img) {
                    this._image3D_VoxelsColor = img;
                }.bind(this));
            } else if (jsonIn.fillMode === "position") {
                var _canvas = jsonIn.arr3d instanceof Uint8Array ? _Utils.Utils.getCanvasFromUint8Array(jsonIn.arr3d, jsonIn.wh, jsonIn.wh) : _Utils.Utils.getCanvasFromUint8Array(_Utils.Utils.getUint8ArrayFromHTMLImageElement(jsonIn.arr3d), jsonIn.wh, jsonIn.wh);
                this._utils.getImageFromCanvas(_canvas, function (img) {
                    this._image3D_VoxelsPosition = img;
                }.bind(this));
            } else if (jsonIn.fillMode === "normal") {
                var _canvas2 = jsonIn.arr3d instanceof Uint8Array ? _Utils.Utils.getCanvasFromUint8Array(jsonIn.arr3d, jsonIn.wh, jsonIn.wh) : _Utils.Utils.getCanvasFromUint8Array(_Utils.Utils.getUint8ArrayFromHTMLImageElement(jsonIn.arr3d), jsonIn.wh, jsonIn.wh);
                this._utils.getImageFromCanvas(_canvas2, function (img) {
                    this._image3D_VoxelsNormal = img;
                    if (this._ongeneratefunction !== undefined) this._ongeneratefunction();
                }.bind(this));
            }
        }
    }, {
        key: "setMesh",


        /**
        * setMesh
        * @param {Mesh} mesh
        */
        value: function setMesh(mesh) {
            this._mesh = mesh;

            this.comp_renderer_node.setArg("vertexPos", function () {
                return this._mesh.vertexArray;
            }.bind(this));
            this.comp_renderer_node.setArg("vertexNormal", function () {
                return this._mesh.normalArray;
            }.bind(this));
            this.comp_renderer_node.setArg("vertexTexture", function () {
                return this._mesh.textureArray;
            }.bind(this));
            this.comp_renderer_node.setArg("vertexTextureUnit", function () {
                return this._mesh.textureUnitArray;
            }.bind(this));

            this.comp_renderer_node.setArg("indices", function () {
                return this._mesh.indexArray;
            }.bind(this));

            this.comp_renderer_node.setArg("PMatrix", function () {
                return this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.PROJECTION).getMatrix().transpose().e;
            }.bind(this));
            this.comp_renderer_node.setArgUpdatable("PMatrix", true);
            this.comp_renderer_node.setArg("cameraWMatrix", function () {
                return this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.TRANSFORM_TARGET).getMatrix().transpose().e;
            }.bind(this));
            this.comp_renderer_node.setArgUpdatable("cameraWMatrix", true);
            this.comp_renderer_node.setArg("nodeWMatrix", function () {
                return this.nodes.getComponent(_Constants.Constants.COMPONENT_TYPES.TRANSFORM).getMatrixPosition().transpose().e;
            }.bind(this));
            this.comp_renderer_node.setArgUpdatable("nodeWMatrix", true);

            this.comp_renderer_node.setArg("texAlbedo", function () {
                return this._mesh.vertexArray;
            }.bind(this));
        }
    }, {
        key: "setImage",


        /**
        * setImage
        * @param {String} url
        */
        value: function setImage(url) {
            var _this = this;

            var image = new Image();
            image.onload = function () {
                _this.comp_renderer_node.setArg("texAlbedo", function () {
                    return image;
                });
            };
            image.src = url;
        }
    }, {
        key: "generate",


        /**
        * Generate the voxelizator
        * @param	{Object} jsonIn
        * @param {number} [jsonIn.size=2.1] Grid size.
        * @param {int} [jsonIn.resolution=32] Grid resolution.
        * @param {Array<String>} [jsonIn.fillmode=["albedo"]] Modes of data fill. "albedo"|"position"|"normal"
        * @param {Function} [jsonIn.ongenerate] On generate event.
        */
        value: function generate(jsonIn) {
            this._ongeneratefunction = jsonIn.ongenerate;

            this._size = jsonIn.size !== undefined ? jsonIn.size : 2.1;
            this._resolution = jsonIn.resolution !== undefined ? jsonIn.resolution : 32;
            this._cs = this._size / this._resolution;
            this._chs = this._cs / 2.0;
            this._wh = Math.ceil(Math.sqrt(this._resolution * this._resolution * this._resolution));

            this._typeFillMode = jsonIn.fillmode === undefined ? ["albedo"] : jsonIn.fillmode;
            this._currentHeight = 0;
            this._currentOffset = 0;

            var comp_projection = this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.PROJECTION);
            comp_projection.setProjection(_Constants.Constants.PROJECTION_TYPES.ORTHO);
            comp_projection.setFov(this._size / 2);
            comp_projection.setNear(-this._chs);
            comp_projection.setFar(this._cs);

            this.comp_renderer_node.setArg("uGridsize", function () {
                return this._size;
            }.bind(this));
            this.comp_renderer_node.setArg("uResolution", function () {
                return this._resolution;
            }.bind(this));

            this._arr_VoxelsColor = new Uint8Array(this._wh * this._wh * 4);
            this._arr_VoxelsPosition = new Uint8Array(this._wh * this._wh * 4);
            this._arr_VoxelsNormal = new Uint8Array(this._wh * this._wh * 4);

            var comp_cam_tf_target = this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.TRANSFORM_TARGET);
            this._nativePosTarget = comp_cam_tf_target.getPositionTarget();
            this._nativePosGoal = comp_cam_tf_target.getPositionGoal();
            this._nativeTargetDistance = comp_cam_tf_target.getTargetDistance();
            this._nativeDimensions = this._sce.getDimensions();

            this._sce.setDimensions(this._resolution, this._resolution);

            this._makeVoxels = true;
            this.comp_renderer_node.gpufG.enableGraphic(0);
        }
    }, {
        key: "getGeneratedArrays",


        /**
         * @typedef {Object} Voxelizator~getGeneratedArrays
         * @property {Array<Uint8Array>} Voxelizator~getGeneratedArrays.albedo
         * @property {Array<Uint8Array>} Voxelizator~getGeneratedArrays.position
         * @property {Array<Uint8Array>} Voxelizator~getGeneratedArrays.normal
         */
        /**
         * @returns {Voxelizator~getGeneratedArrays}
         */
        value: function getGeneratedArrays() {
            return { "albedo": this._arr_VoxelsColor,
                "position": this._arr_VoxelsPosition,
                "normal": this._arr_VoxelsNormal };
        }
    }, {
        key: "getGeneratedImages",


        /**
         * @typedef {Object} Voxelizator~getGeneratedImages
         * @property {HTMLImageElement} Voxelizator~getGeneratedImages.albedo
         * @property {HTMLImageElement} Voxelizator~getGeneratedImages.position
         * @property {HTMLImageElement} Voxelizator~getGeneratedImages.normal
         */
        /**
         * @returns {Voxelizator~getGeneratedImages}
         */
        value: function getGeneratedImages() {
            return { "albedo": this._image3D_VoxelsColor,
                "position": this._image3D_VoxelsPosition,
                "normal": this._image3D_VoxelsNormal };
        }
    }, {
        key: "disable",
        value: function disable() {
            this.comp_renderer_node.gpufG.disableGraphic(0);
        }
    }]);

    return Voxelizator;
}();

global.Voxelizator = Voxelizator;
module.exports.Voxelizator = Voxelizator;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../Constants":2,"../../Utils.class":4}],4:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Utils = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

require("webclgl");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* @class
*/
var Utils = exports.Utils = function () {
    function Utils() {
        _classCallCheck(this, Utils);

        window.requestAnimFrame = function () {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
        }();
    }

    /**
    * Get HTMLCanvasElement from Uint8Array
    * @param {Uint8Array} uint8arr
    * @param {int} width
    * @param {int} height
     * @returns {HTMLCanvasElement}
    */


    _createClass(Utils, [{
        key: "getImageFromCanvas",

        /**
         * @callback Utils~getImageFromCanvas~onload
         * @param {HTMLImageElement} img
         */
        /**
        * Get HTMLImageElement from canvas
        * @param {HTMLCanvasElement} oldCanvas
        * @param {Utils~getImageFromCanvas~onload} onload
        */
        value: function getImageFromCanvas(oldCanvas, onload) {
            var imagen = document.createElement('img');
            imagen.onload = function () {
                onload(imagen);
            };
            imagen.src = oldCanvas.toDataURL();
        }
    }, {
        key: "pack",


        /**
         * Angle between two vectors viewing from top
         * @returns {number}
         * @param {StormV3} vectorA
         * @param {StormV3} vectorB
          Utils.prototype.angle = function(vA, vB) {
            let vAA = vA.normalize();
            let vBB = vB.normalize();
              let escalarProduct = Math.acos((vAA.e[0]*vBB.e[0])+(vAA.e[1]*vBB.e[1])+(vAA.e[2]*vBB.e[2]));
              let vCC = vAA.cross(vBB);
            //console.log(vCC.e[0]+" "+vCC.e[1]+" "+vCC.e[2]);
              if(vCC.e[1] == 1) {
                escalarProduct = (Math.PI+escalarProduct);
            }
              return escalarProduct;
        };*/

        /**
        * Pack 1float (0.0-1.0) to 4float rgba (0.0-1.0, 0.0-1.0, 0.0-1.0, 0.0-1.0)*
        * @param {number} value
        * @returns {Array<number>}
        *
        */
        value: function pack(value) {
            var bias = [1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0];

            var r = value;
            var g = Utils.fract(r * 255.0);
            var b = Utils.fract(g * 255.0);
            var a = Utils.fract(b * 255.0);
            var colour = [r, g, b, a];

            var dd = [colour[1] * bias[0], colour[2] * bias[1], colour[3] * bias[2], colour[3] * bias[3]];

            return [colour[0] - dd[0], colour[1] - dd[1], colour[2] - dd[2], colour[3] - dd[3]];
        }
    }, {
        key: "unpack",

        /**
        * Unpack 4float rgba (0.0-1.0, 0.0-1.0, 0.0-1.0, 0.0-1.0) to 1float (0.0-1.0)
        * @param {Array<number>} value
         * @returns {number}
        */
        value: function unpack(value) {
            var bitShifts = [1.0, 1.0 / 255.0, 1.0 / (255.0 * 255.0), 1.0 / (255.0 * 255.0 * 255.0)];
            return Utils.dot4(value, bitShifts);
        }
    }], [{
        key: "getCanvasFromUint8Array",
        value: function getCanvasFromUint8Array(uint8arr, width, height) {
            var e = document.createElement('canvas');
            e.width = width;
            e.height = height;
            var ctx2D = e.getContext("2d");
            var image = ctx2D.createImageData(width, height);
            for (var i = 0; i < image.data.length; i++) {
                image.data[i] = uint8arr[i];
            }ctx2D.putImageData(image, 0, 0);

            return e;
        }
    }, {
        key: "getUint8ArrayFromHTMLImageElement",


        /**
        * Get Uint8Array from HTMLImageElement
        * @param {HTMLImageElement} imageElement
         * @returns {Uint8ClampedArray}
        */
        value: function getUint8ArrayFromHTMLImageElement(imageElement) {
            var e = document.createElement('canvas');
            e.width = imageElement.width;
            e.height = imageElement.height;
            var ctx2D_tex = e.getContext("2d");
            ctx2D_tex.drawImage(imageElement, 0, 0);
            var arrayTex = ctx2D_tex.getImageData(0, 0, imageElement.width, imageElement.height);

            return arrayTex.data;
        }
    }, {
        key: "getVector",


        /**
        * Get random vector from vecNormal with deviation in degrees
        * @param {StormV3} vecNormal
        * @param {number} degrees
         * @returns {StormV3}
        */
        value: function getVector(vecNormal, degrees) {
            var ob = Utils.cartesianToSpherical(vecNormal);
            var angleLat = ob.lat;
            var angleLng = ob.lng;

            var desvLat = Math.random() * 180.0 - 90.0;
            var desvLng = Math.random() * 180.0 - 90.0;
            angleLat += degrees * desvLat;
            angleLng += degrees * desvLng;

            return Utils.sphericalToCartesian(1.0, angleLat, angleLng);
        }
    }, {
        key: "getVectorGLSLFunctionString",

        /**
        * Get random vector from vecNormal with deviation in degrees (GLSL)
        * @returns {String}
        */
        value: function getVectorGLSLFunctionString() {
            return 'vec3 getVector(vec3 vecNormal, float degrees, vec2 vecNoise) {\n' + 'vec3 ob = cartesianToSpherical(vecNormal);' + 'float angleLat = ob.y;' + 'float angleLng = ob.z;' + 'float desvLat = (vecNoise.x*180.0)-90.0;' + 'float desvLng = (vecNoise.y*180.0)-90.0;' + 'angleLat += (degrees*desvLat);' + 'angleLng += (degrees*desvLng);' + 'return sphericalToCartesian(vec3(1.0, angleLat, angleLng));' + '}\n';
        }
    }, {
        key: "cartesianToSpherical",


        /**
         * cartesianToSpherical
         * @param {StormV3} vec
         * @returns {Object}
         * @example
         * $V3([1,0,0])  return {radius: 1, lat: 90, lng: 0}
         * $V3([0,0,1])  return {radius: 1, lat: 90, lng: 90}
         * $V3([-1,0,0]) return {radius: 1, lat: 90, lng: 180}
         * $V3([0,0,-1]) return {radius: 1, lat: 90, lng: -90}
         */
        value: function cartesianToSpherical(vec) {
            var r = Math.sqrt(vec.e[0] * vec.e[0] + vec.e[1] * vec.e[1] + vec.e[2] * vec.e[2]);

            var angleLat = Utils.radToDeg(Math.acos(vec.e[1] / r));
            var angleLng = Utils.radToDeg(Math.atan2(vec.e[2], vec.e[0]));

            return { "radius": r,
                "lat": angleLat,
                "lng": angleLng };
        }
    }, {
        key: "cartesianToSphericalGLSLFunctionString",

        /**
         * cartesianToSpherical (GLSL)
        * @returns {String}
        */
        value: function cartesianToSphericalGLSLFunctionString() {
            return 'vec3 cartesianToSpherical(vec3 vect) {\n' + 'float r = sqrt(vect.x*vect.x + vect.y*vect.y + vect.z*vect.z);' + 'float angleLat = radToDeg(acos(vect.y/r));' + 'float angleLng = radToDeg(atan(vect.z, vect.x));' + 'return vec3(r, angleLat, angleLng);' + '}\n';
        }
    }, {
        key: "sphericalToCartesian",


        /**
         * sphericalToCartesian
         * @param {number} radius
         * @param {number} lat Lat in degrees
         * @param {number} lng Lng in degrees
         * @returns {StormV3}
         * @example
         * (1.0, 90.0, 0.0).e) return $V3([1,0,0])
         * (1.0, 90.0, 90.0).e) return $V3([0,0,1])
         * (1.0, 90.0, 180.0).e) return $V3([-1,0,0])
         * (1.0, 90.0, -90.0).e) return $V3([0,0,-1])
         **/
        value: function sphericalToCartesian(radius, lat, lng) {
            var r = radius;
            var angleLat = Utils.degToRad(lat);
            var angleLng = Utils.degToRad(lng);

            var x = r * Math.sin(angleLat) * Math.cos(angleLng);
            var z = r * Math.sin(angleLat) * Math.sin(angleLng);
            var y = r * Math.cos(angleLat);

            return new StormV3([x, y, z]);
        }
    }, {
        key: "sphericalToCartesianGLSLFunctionString",

        /**
         * sphericalToCartesian (GLSL)
        * @returns {String}
        */
        value: function sphericalToCartesianGLSLFunctionString() {
            return 'vec3 sphericalToCartesian(vec3 vect) {\n' + 'float r = vect.x;' + 'float angleLat = degToRad(vect.y);' + 'float angleLng = degToRad(vect.z);' + 'float x = r*sin(angleLat)*cos(angleLng);' + 'float z = r*sin(angleLat)*sin(angleLng);' + 'float y = r*cos(angleLat);' + 'return vec3(x,y,z);' + '}\n';
        }
    }, {
        key: "refract",


        /**
        * Refract
        * @param {StormV3} V
        * @param {StormV3} N
        * @param {number} n1 Refract index way 1
        * @param {number} n2 Refract index way 2
         * @returns {StormV3}
        */
        value: function refract(V, N, n1, n2) {
            var refrIndex = n1 / n2;
            var cosI = N.dot(V) * -1.0;
            var cosT2 = 1.0 - refrIndex * refrIndex * (1.0 - cosI * cosI);
            var vv = V.x(refrIndex);
            return vv.add(N.x(refrIndex * cosI - Math.sqrt(cosT2)));
        }
    }, {
        key: "degToRad",


        /**
        * Degrees to radians. Full circle = 360 degrees.
        * @param {number} degrees
         * @returns {number}
        */
        value: function degToRad(degrees) {
            return degrees * 3.14159 / 180;
        }
    }, {
        key: "degToRadGLSLFunctionString",

        /**
         * Degrees to radians. Full circle = 360 degrees. (GLSL)
        * @returns {String}
        */
        value: function degToRadGLSLFunctionString() {
            return 'float degToRad(float deg) {' + 'return (deg*3.14159)/180.0;' + '}';
        }
    }, {
        key: "radToDeg",


        /**
        * Radians to degrees
        * @param {number} radians
         * @returns {number}
        */
        value: function radToDeg(radians) {
            return radians * (180 / 3.14159);
        }
    }, {
        key: "radToDegGLSLFunctionString",

        /**
         * Radians to degrees (GLSL)
        * @returns {String}
        */
        value: function radToDegGLSLFunctionString() {
            return 'float radToDeg(float rad) {' + 'return rad*(180.0/3.14159);' + '}';
        }
    }, {
        key: "hexToRgb",


        /**
         * hexToRgb
         * @param {String} hex
         * @returns  {Array<number>} rgb values from 0 to 255
         */
        value: function hexToRgb(hex) {
            // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                return r + r + g + g + b + b;
            });

            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
    }, {
        key: "rgbToHex",

        /**
         * rgbToHex
         * @param {Array<number>} rgb values from 0 to 255
         * @returns {String}
         */
        value: function rgbToHex(rgb) {
            var rgbVal = rgb[2] | rgb[1] << 8 | rgb[0] << 16;
            return '#' + (0x1000000 + rgbVal).toString(16).slice(1);
        }
    }, {
        key: "invsqrt",


        /**
        * Inverse sqrt
        * @param {number} value
         * @returns {number}
        */
        value: function invsqrt(value) {
            return 1.0 / value;
        }
    }, {
        key: "smoothstep",


        /**
        * Smoothstep
        * @param {number} edge0
        * @param {number} edge1
        * @param {number} current
         * @returns {number}
        */
        value: function smoothstep(edge0, edge1, current) {
            if (current < edge0) return 0;
            if (current >= edge1) return 1;
            if (edge0 === edge1) return -1;
            var p = (current - edge0) / (edge1 - edge0);

            return p * p * (3 - 2 * p);
        }
    }, {
        key: "dot4",


        /**
        * Dot product vector4float
        * @param {Array<number>} vector4A Vector a
        * @param {Array<number>} vector4B Vector b
         * @returns {number}
        */
        value: function dot4(vector4A, vector4B) {
            return vector4A[0] * vector4B[0] + vector4A[1] * vector4B[1] + vector4A[2] * vector4B[2] + vector4A[3] * vector4B[3];
        }
    }, {
        key: "fract",


        /**
        * Compute the fractional part of the argument. Example: fract(pi)=0.14159265...
        * @param {number} value
         * @returns {number}
        */
        value: function fract(value) {
            return value > 0 ? value - Math.floor(value) : value - Math.ceil(value);
        }
    }, {
        key: "packGLSLFunctionString",

        /**
        * Get pack GLSL function string
        * @returns {String}
        */
        value: function packGLSLFunctionString() {
            return 'vec4 pack (float depth) {' + 'const vec4 bias = vec4( 1.0 / 255.0,' + '1.0 / 255.0,' + '1.0 / 255.0,' + '0.0);' + 'float r = depth;' + 'float g = fract(r * 255.0);' + 'float b = fract(g * 255.0);' + 'float a = fract(b * 255.0);' + 'vec4 colour = vec4(r, g, b, a);' + 'return colour - (colour.yzww * bias);' + '}';
        }
    }, {
        key: "unpackGLSLFunctionString",

        /**
        * Get unpack GLSL function string
        * @returns {String}
        */
        value: function unpackGLSLFunctionString() {
            return 'float unpack (vec4 colour) {' + 'const vec4 bitShifts = vec4(1.0,' + '1.0 / 255.0,' + '1.0 / (255.0 * 255.0),' + '1.0 / (255.0 * 255.0 * 255.0));' + 'return dot(colour, bitShifts);' + '}';
        }
    }, {
        key: "rayTraversalInitSTR",
        value: function rayTraversalInitSTR() {
            return '' + 'float wh = ceil(sqrt(uResolution*uResolution*uResolution));\n' + 'float cs = uGridsize/uResolution;\n' + // cell size
            'float chs = cs/2.0;\n' + // cell size
            'float texelSize = 1.0/(wh-1.0);\n' + // 1.0/(wh-1.0)??

            // Fast Voxel Traversal Algorithm for Ray Tracing. John Amanatides & Andrew Woo.
            // http://www.cse.chalmers.se/edu/course/TDA361/grid.pdf
            // More info:
            // http://www.clockworkcoders.com/oglsl/rt/gpurt3.htm
            'vec3 gl = vec3(-(uGridsize/2.0), -(uGridsize/2.0), -(uGridsize/2.0));\n' + 'vec3 _r = vec3(uGridsize, uGridsize, uGridsize);\n' + 'vec3 _rRes = vec3(uResolution, uResolution, uResolution);\n' + 'vec3 _len = _r/_rRes;\n' + 'vec3 worldToVoxel(vec3 world) {\n' + 'vec3 ijk = (world - gl) / _len;\n' + // (1.0-(-1.0)) / (2/64) = 64
            'ijk = vec3(floor(ijk.x), floor(ijk.y), floor(ijk.z));\n' + 'return ijk;\n' + '}\n' + 'float voxelToWorldX(float x) {return x * _len.x + gl.x;}\n' + // 64*(2/64)+(-1.0) = 1.0
            'float voxelToWorldY(float y) {return y * _len.y + gl.y;}\n' + 'float voxelToWorldZ(float z) {return z * _len.z + gl.z;}\n';
        }
    }, {
        key: "rayTraversalSTR",
        value: function rayTraversalSTR(resolution) {
            return '' + 'vec2 getId(vec3 voxel) {\n' + 'int tex3dId = (int(voxel.y)*(int(uResolution)*int(uResolution)))+(int(voxel.z)*(int(uResolution)))+int(voxel.x);\n' + 'float num = float(tex3dId)/wh;\n' + 'float col = fract(num)*wh;\n' + 'float row = floor(num);\n' + 'return vec2(col*texelSize, row*texelSize);\n' + '}\n' + 'vec4 getVoxel_Color(vec2 texVec, vec3 voxel, vec3 RayOrigin) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelColor[vec2(texVec.x, texVec.y)];\n' + 'if(texture.a/255.0 > 0.5) {\n' + // existen triángulos dentro?
            'rgba = vec4(texture.rgb/255.0,distance(vec3(voxelToWorldX(voxel.x), voxelToWorldX(voxel.y), voxelToWorldX(voxel.z)),RayOrigin));\n' + '}\n' + 'return rgba;\n' + '}\n' + 'vec4 getVoxel_Pos(vec2 texVec) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelPos[vec2(texVec.x, texVec.y)];\n' +
            //distance(vec3(voxelToWorldX(voxel.x), voxelToWorldX(voxel.y), voxelToWorldX(voxel.z)),RayOrigin)
            'rgba = vec4( ((texture.xyz/255.0)*uGridsize)-(uGridsize/2.0), 1.0);\n' + 'return rgba;\n' + '}\n' + 'vec4 getVoxel_Normal(vec2 texVec) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelNormal[vec2(texVec.x, texVec.y)];\n' + 'rgba = vec4(((texture.rgb/255.0)*2.0)-1.0, 1.0);\n' + 'return rgba;\n' + '}\n' + 'struct RayTraversalResponse {' + 'vec4 voxelColor;' + 'vec4 voxelPos;' + 'vec4 voxelNormal;' + '};' + 'RayTraversalResponse rayTraversal(vec3 RayOrigin, vec3 RayDir) {\n' + 'vec4 fvoxelColor = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec4 fvoxelPos = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec4 fvoxelNormal = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec3 voxel = worldToVoxel(RayOrigin);' + 'vec3 _dir = normalize(RayDir);' + 'vec3 tMax;' + 'if(RayDir.x < 0.0) tMax.x = (voxelToWorldX(voxel.x)-RayOrigin.x)/RayDir.x;' + 'if(RayDir.x > 0.0) tMax.x = (voxelToWorldX(voxel.x+1.0)-RayOrigin.x)/RayDir.x;' + 'if(RayDir.y < 0.0) tMax.y = (voxelToWorldY(voxel.y)-RayOrigin.y)/RayDir.y;' + 'if(RayDir.y < 0.0) tMax.y = (voxelToWorldY(voxel.y+1.0)-RayOrigin.y)/RayDir.y;' + 'if(RayDir.z < 0.0) tMax.z = (voxelToWorldZ(voxel.z)-RayOrigin.z)/RayDir.z;' + 'if(RayDir.z < 0.0) tMax.z = (voxelToWorldZ(voxel.z+1.0)-RayOrigin.z)/RayDir.z;' + 'float tDeltaX = _r.x/abs(RayDir.x);' + // hasta qué punto se debe avanzar en la dirección del rayo antes de que nos encontramos con un nuevo voxel en la dirección x
            'float tDeltaY = _r.y/abs(RayDir.y);' + 'float tDeltaZ = _r.z/abs(RayDir.z);' + 'float stepX = 1.0; float stepY = 1.0; float stepZ = 1.0;\n' + 'float outX = _r.x; float outY = _r.y; float outZ = _r.z;\n' + 'if(RayDir.x < 0.0) {stepX = -1.0; outX = -1.0;}' + 'if(RayDir.y < 0.0) {stepY = -1.0; outY = -1.0;}' + 'if(RayDir.z < 0.0) {stepZ = -1.0; outZ = -1.0;}' + 'vec4 color = vec4(0.0,0.0,0.0,0.0);\n' + 'bool c1; bool c2; bool c3; bool isOut;' + 'vec2 vid;' + 'for(int c = 0; c < ' + resolution + '*2; c++) {\n' + 'c1 = bool(tMax.x < tMax.y);' + 'c2 = bool(tMax.x < tMax.z);' + 'c3 = bool(tMax.y < tMax.z);' + 'isOut = false;' + 'if (c1 && c2) {' + 'voxel.x += stepX;' + 'if(voxel.x==outX) isOut=true;' + 'tMax.x += tDeltaX;' + '} else if(( (c1 && !c2) || (!c1 && !c3) )) {' + 'voxel.z += stepZ;' + 'if(voxel.z==outZ) isOut=true;' + 'tMax.z += tDeltaZ;' + '} else if(!c1 && c3) {' + 'voxel.y += stepY;' + 'if(voxel.y==outY) isOut=true;' + 'tMax.y += tDeltaY;' + '}' + 'if(isOut == true) break;\n' + 'else {' + 'if((voxel.x >= 0.0 && voxel.x <= _rRes.x && voxel.y >= 0.0 && voxel.y <= _rRes.y && voxel.z >= 0.0 && voxel.z <= _rRes.z)) {;\n' + 'vid = getId(voxel);' + 'vec4 vcc = getVoxel_Color(vid, voxel, RayOrigin);' + 'if(vcc.a != 0.0) {' + 'fvoxelColor = vcc;' + 'break;\n' + '}' + '}' + '}' + '}' + 'fvoxelPos = getVoxel_Pos(vid);' + 'fvoxelNormal = getVoxel_Normal(vid);' + 'return RayTraversalResponse(fvoxelColor, fvoxelPos, fvoxelNormal);' + '}\n';
        }
    }, {
        key: "isPowerOfTwo",
        value: function isPowerOfTwo(x) {
            return (x & x - 1) === 0;
        }
    }, {
        key: "nextHighestPowerOfTwo",
        value: function nextHighestPowerOfTwo(x) {
            --x;
            for (var i = 1; i < 32; i <<= 1) {
                x = x | x >> i;
            }
            return x + 1;
        }
    }, {
        key: "getElementPosition",
        value: function getElementPosition(element) {
            var elem = element,
                tagname = "",
                x = 0,
                y = 0;

            while ((typeof elem === "undefined" ? "undefined" : _typeof(elem)) === "object" && typeof elem.tagName !== "undefined") {
                y += elem.offsetTop;
                x += elem.offsetLeft;
                tagname = elem.tagName.toUpperCase();

                if (tagname === "BODY") elem = 0;

                if ((typeof elem === "undefined" ? "undefined" : _typeof(elem)) === "object") {
                    if (_typeof(elem.offsetParent) === "object") elem = elem.offsetParent;
                }
            }

            return { x: x, y: y };
        }
    }, {
        key: "getWebGLContextFromCanvas",
        value: function getWebGLContextFromCanvas(canvas, ctxOpt) {
            return WebCLGLUtils.getWebGLContextFromCanvas(canvas, ctxOpt);
        }
    }, {
        key: "fullScreen",
        value: function fullScreen() {
            if (!document.fullscreenElement && // alternative standard method
            !document.mozFullScreenElement && !document.webkitFullscreenElement) {
                // current working methods
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) {
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                }
            } else {
                if (document.cancelFullScreen) {
                    document.cancelFullScreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen();
                }
            }
        }
    }]);

    return Utils;
}();

global.Utils = Utils;
module.exports.Utils = Utils;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"webclgl":1}]},{},[3]);
