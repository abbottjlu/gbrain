(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

var exp = { "WebCLGL": "./WebCLGL.class",
            "WebCLGLBuffer": "./WebCLGLBuffer.class.js",
            "WebCLGLFor": "./WebCLGLFor.class.js",
            "WebCLGLKernel": "./WebCLGLKernel.class.js",
            "WebCLGLUtils": "./WebCLGLUtils.class.js",
            "WebCLGLVertexFragmentProgram": "./WebCLGLVertexFragmentProgram.class.js"
};

for(var key in exp)
    exports[key] = require(exp[key]);
},{}],2:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var Constants = exports.Constants = {
	"EVENT_TYPES": {
		"KEY_DOWN": 0,
		"KEY_UP": 1,
		"MOUSE_DOWN": 2,
		"MOUSE_UP": 3,
		"MOUSE_MOVE": 4,
		"MOUSE_WHEEL": 5
	},
	"COMPONENT_TYPES": {
		"KEYBOARD_EVENTS": 0,
		"MOUSE_EVENTS": 1,
		"TRANSFORM": 2,
		"TRANSFORM_TARGET": 3,
		"CONTROLLER_TRANSFORM_TARGET": 4,
		"PROJECTION": 5,
		"GPU": 6
	},
	"PROJECTION_TYPES": {
		"PERSPECTIVE": 0,
		"ORTHO": 1
	},
	"VIEW_TYPES": {
		"LEFT": 0,
		"RIGHT": 1,
		"FRONT": 2,
		"BACK": 3,
		"TOP": 4,
		"BOTTOM": 5
	},
	"BLENDING_MODES": {
		"ZERO": "ZERO",
		"ONE": "ONE",
		"SRC_COLOR": "SRC_COLOR",
		"ONE_MINUS_SRC_COLOR": "ONE_MINUS_SRC_COLOR",
		"DST_COLOR": "DST_COLOR",
		"ONE_MINUS_DST_COLOR": "ONE_MINUS_DST_COLOR",
		"SRC_ALPHA": "SRC_ALPHA",
		"ONE_MINUS_SRC_ALPHA": "ONE_MINUS_SRC_ALPHA",
		"DST_ALPHA": "DST_ALPHA",
		"ONE_MINUS_DST_ALPHA": "ONE_MINUS_DST_ALPHA",
		"SRC_ALPHA_SATURATE": "SRC_ALPHA_SATURATE",
		"CONSTANT_COLOR": "CONSTANT_COLOR",
		"ONE_MINUS_CONSTANT_COLOR": "ONE_MINUS_CONSTANT_COLOR",
		"CONSTANT_ALPHA": "CONSTANT_ALPHA",
		"ONE_MINUS_CONSTANT_ALPHA": "ONE_MINUS_CONSTANT_ALPHA"
	},
	"BLENDING_EQUATION_TYPES": {
		"FUNC_ADD": "FUNC_ADD",
		"FUNC_SUBTRACT": "FUNC_SUBTRACT",
		"FUNC_REVERSE_SUBTRACT": "FUNC_REVERSE_SUBTRACT"
	},
	"DRAW_MODES": {
		"POINTS": 0,
		"LINES": 1,
		"LINE_LOOP": 2,
		"LINE_STRIP": 3,
		"TRIANGLES": 4,
		"TRIANGLE_STRIP": 5,
		"TRIANGLE_FAN": 6
	}
};
global.Constants = Constants;
module.exports.Constants = Constants;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
                                        value: true
});
exports.GI = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Utils = require("../../Utils.class");

var _Constants = require("../../Constants");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* @class
*/
var GI = exports.GI = function () {
                                        function GI(sce) {
                                                                                _classCallCheck(this, GI);

                                                                                this._sce = sce;
                                                                                this._project = this._sce.getLoadedProject();
                                                                                this._gl = this._project.getActiveStage().getWebGLContext();
                                                                                this._utils = new _Utils.Utils();

                                                                                this.nodes = new Node();
                                                                                this.nodes.setName("GI");
                                                                                this._project.getActiveStage().addNode(this.nodes);

                                                                                // ComponentTransform
                                                                                var comp_transform = new ComponentTransform();
                                                                                this.nodes.addComponent(comp_transform);

                                                                                // Component_GPU
                                                                                this.comp_renderer_node = new Component_GPU();
                                                                                this.nodes.addComponent(this.comp_renderer_node);

                                                                                this._runGI = false;
                                        }

                                        /**
                                        * setResolution
                                        * @param {number} resolution
                                        */


                                        _createClass(GI, [{
                                                                                key: "setResolution",
                                                                                value: function setResolution(resolution) {
                                                                                                                        this.comp_renderer_node.setGPUFor(this.comp_renderer_node.gl, { // VFP_RGB
                                                                                                                                                                "float4*attr vertexPos": function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                "float4*attr vertexNormal": function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                "float4*attr vertexTexture": function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                "float*attr vertexTextureUnit": function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                "indices": function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                "mat4 PMatrix": function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                "mat4 cameraWMatrix": function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                "mat4 nodeWMatrix": function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                'float nodesSize': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                'float4* texAlbedo': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),

                                                                                                                                                                // VFP_GI
                                                                                                                                                                'float4* sampler_voxelColor': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                'float4* sampler_voxelPos': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                'float4* sampler_voxelNormal': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),

                                                                                                                                                                'float4* sampler_screenColor': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                'float4* sampler_screenPos': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                'float4* sampler_screenNormal': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),

                                                                                                                                                                'float4* sampler_GIVoxel': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),

                                                                                                                                                                'float randX1': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                'float randY1': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                'float uTypePass': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),

                                                                                                                                                                'float uGridsize': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this),
                                                                                                                                                                'float uResolution': function () {
                                                                                                                                                                                                        return null;
                                                                                                                                                                }.bind(this) }, { "type": "GRAPHIC",
                                                                                                                                                                "name": "GI_VFP_RGB",
                                                                                                                                                                "viewSource": false,
                                                                                                                                                                "config": new VFP_RGB(1).getSrc(),
                                                                                                                                                                "drawMode": 4,
                                                                                                                                                                "depthTest": true,
                                                                                                                                                                "blend": true,
                                                                                                                                                                "blendEquation": _Constants.Constants.BLENDING_EQUATION_TYPES.FUNC_ADD,
                                                                                                                                                                "blendSrcMode": _Constants.Constants.BLENDING_MODES.SRC_ALPHA,
                                                                                                                                                                "blendDstMode": _Constants.Constants.BLENDING_MODES.ONE_MINUS_SRC_ALPHA }, { "type": "GRAPHIC",
                                                                                                                                                                "name": "GI_CALC",
                                                                                                                                                                "viewSource": false,
                                                                                                                                                                "config": [["sampler_screenColor", "sampler_screenPos", "sampler_screenNormal", "sampler_GIVoxel"],
                                                                                                                                                                // vertex head
                                                                                                                                                                'varying vec4 vposition;\n' + 'varying vec4 vnormal;\n' + 'varying vec4 vposScreen;\n' + 'const mat4 ScaleMatrix = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);',

                                                                                                                                                                // vertex source
                                                                                                                                                                'vec3 vp = vec3(vertexPos[].x, vertexPos[].y, vertexPos[].z);\n' + 'vposition = nodeWMatrix * vec4(vp*vec3(1.0,1.0,1.0), 1.0);\n' + 'vnormal = vec4(vertexNormal[].xyz*vec3(1.0,1.0,1.0), 1.0);\n' + 'vec4 pos = PMatrix * cameraWMatrix * nodeWMatrix * vec4(vp, 1.0);' + 'vposScreen = ScaleMatrix * pos;\n' + 'gl_Position = pos;\n',

                                                                                                                                                                // fragment head
                                                                                                                                                                'varying vec4 vposition;\n' + 'varying vec4 vnormal;\n' + 'varying vec4 vposScreen;\n' + _Utils.Utils.degToRadGLSLFunctionString() + _Utils.Utils.radToDegGLSLFunctionString() + _Utils.Utils.cartesianToSphericalGLSLFunctionString() + _Utils.Utils.sphericalToCartesianGLSLFunctionString() + _Utils.Utils.getVectorGLSLFunctionString() + _Utils.Utils.unpackGLSLFunctionString() + _Utils.Utils.rayTraversalInitSTR() + _Utils.Utils.rayTraversalSTR(resolution),

                                                                                                                                                                // fragment source
                                                                                                                                                                'vec3 pixelCoord = vposScreen.xyz / vposScreen.w;' + 'float maxang=0.7;' + 'float maxBounds = 1.0;' + 'vec4 texScreenColor = sampler_screenColor[vec2(pixelCoord.x,pixelCoord.y)];\n' + 'vec4 texScreenPos = sampler_screenPos[vec2(pixelCoord.x,pixelCoord.y)];\n' + 'vec4 texScreenNormal = sampler_screenNormal[vec2(pixelCoord.x,pixelCoord.y)];\n' + 'vec4 texScreenGIVoxel = sampler_GIVoxel[vec2(pixelCoord.x,pixelCoord.y)];\n' + 'vec4 f_sampler_screenColor;' + 'vec4 f_sampler_screenPos;' + 'vec4 f_sampler_screenNormal;' + 'vec4 f_sampler_GIVoxel;' + 'vec3 ro; vec3 rd; RayTraversalResponse rayT;' + 'if(texScreenNormal.a == 0.0) {' + // start
                                                                                                                                                                'ro = vposition.xyz*vec3(1.0,1.0,1.0);' + 'rd = vnormal.xyz*vec3(1.0,1.0,1.0);' + 'vec3 vectorRandom = getVector(rd, maxang, vec2(randX1,randY1));' + 'rayT = rayTraversal(ro+(rd*(cs+cs)), vectorRandom);\n' + '} else if(texScreenNormal.a == 1.0) {' + 'ro = texScreenPos.xyz;' + 'rd = texScreenNormal.xyz;' +
                                                                                                                                                                //'rd = reflect(normalize(ro),rd);'+

                                                                                                                                                                'vec3 vectorRandom = getVector(rd, maxang, vec2(randX1,randY1));' + 'rayT = rayTraversal(ro+(rd*(cs)), vectorRandom);\n' + '}' + 'if(rayT.voxelColor.a > 0.0) {' + // hit in solid
                                                                                                                                                                'vec4 rtColor = rayT.voxelColor;' + 'vec4 rtPos = rayT.voxelPos;' + 'vec4 rtNormal = rayT.voxelNormal;' + 'f_sampler_screenColor = vec4(texScreenColor.r*rtColor.r,texScreenColor.g*rtColor.g,texScreenColor.b*rtColor.b, texScreenColor.a+(rtColor.a/uGridsize));\n' + // -(rtColor.a/uGridsize)

                                                                                                                                                                'float aum = (texScreenNormal.a == 0.0) ? 1.0 : texScreenPos.a+1.0;' + 'f_sampler_screenPos = vec4(rtPos.r,rtPos.g,rtPos.b, aum);\n' + 'float proc = (aum == maxBounds) ? 0.0 : 1.0;' + 'f_sampler_screenNormal = vec4(rtNormal.r,rtNormal.g,rtNormal.b, proc);\n' + '} else {' + // hit in light
                                                                                                                                                                'f_sampler_screenColor = vec4(texScreenColor.r,texScreenColor.g,texScreenColor.b, texScreenColor.a);\n' + 'float aum = (texScreenNormal.a == 0.0) ? 0.0 : texScreenPos.a+1.0;' + 'f_sampler_screenPos = vec4(1.0,1.0,1.0, aum);\n' + 'f_sampler_screenNormal = vec4(1.0,1.0,1.0, 0.0);\n' + // (make process and return to origin alpha 0.0).
                                                                                                                                                                '}' + 'if(f_sampler_screenNormal.a == 0.0) {' + // make process
                                                                                                                                                                'float cum = texScreenGIVoxel.r+(1.0-(f_sampler_screenPos.a/maxBounds));' + 'f_sampler_GIVoxel = vec4(cum, cum, cum, texScreenGIVoxel.a+1.0);' + '} else {' + // hit in solid. do nothing
                                                                                                                                                                'f_sampler_GIVoxel = texScreenGIVoxel;' + '}' + 'return [f_sampler_screenColor, f_sampler_screenPos, f_sampler_screenNormal, f_sampler_GIVoxel];\n'],
                                                                                                                                                                "drawMode": 4,
                                                                                                                                                                "depthTest": true,
                                                                                                                                                                "blend": false,
                                                                                                                                                                "blendEquation": _Constants.Constants.BLENDING_EQUATION_TYPES.FUNC_ADD,
                                                                                                                                                                "blendSrcMode": _Constants.Constants.BLENDING_MODES.ONE,
                                                                                                                                                                "blendDstMode": _Constants.Constants.BLENDING_MODES.ZERO });
                                                                                                                        this.comp_renderer_node.getComponentBufferArg("RGB", this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.GPU));
                                                                                                                        this.comp_renderer_node.gpufG.onPreProcessGraphic(0, function () {
                                                                                                                                                                //comp_screenEffects.gl.clear(comp_screenEffects.gl.COLOR_BUFFER_BIT | comp_screenEffects.gl.DEPTH_BUFFER_BIT);
                                                                                                                                                                //this.comp_renderer_node.gl.blendFunc(this.comp_renderer_node.gl[Constants.BLENDING_MODES.SRC_ALPHA], this.comp_renderer_node.gl[Constants.BLENDING_MODES.ONE_MINUS_SRC_ALPHA]);
                                                                                                                        }.bind(this));
                                                                                                                        this.comp_renderer_node.gpufG.onPreProcessGraphic(1, function () {
                                                                                                                                                                //this.comp_renderer_node.gl.blendFunc(this.comp_renderer_node.gl[Constants.BLENDING_MODES.SRC_ALPHA], this.comp_renderer_node.gl[Constants.BLENDING_MODES.ONE_MINUS_SRC_ALPHA]);
                                                                                                                                                                if (this._runGI === true) {
                                                                                                                                                                                                        this.comp_renderer_node.setArg("randX1", function () {
                                                                                                                                                                                                                                                return Math.random();
                                                                                                                                                                                                        }.bind(this));
                                                                                                                                                                                                        this.comp_renderer_node.setArg("randY1", function () {
                                                                                                                                                                                                                                                return Math.random();
                                                                                                                                                                                                        }.bind(this));
                                                                                                                                                                }
                                                                                                                        }.bind(this));
                                                                                                                        this.comp_renderer_node.gpufG.disableGraphic(1);

                                                                                                                        this.comp_renderer_node.setArg("uResolution", function () {
                                                                                                                                                                return resolution;
                                                                                                                        }.bind(this));
                                                                                }
                                        }, {
                                                                                key: "setGridSize",


                                                                                /**
                                                                                * setGridSize
                                                                                * @param {number} size
                                                                                */
                                                                                value: function setGridSize(size) {
                                                                                                                        this.comp_renderer_node.setArg("uGridsize", function () {
                                                                                                                                                                return size;
                                                                                                                        }.bind(this));
                                                                                }
                                        }, {
                                                                                key: "setMesh",


                                                                                /**
                                                                                * setMesh
                                                                                * @param {Mesh} mesh
                                                                                */
                                                                                value: function setMesh(mesh) {
                                                                                                                        var _this = this;

                                                                                                                        this.comp_renderer_node.setArg("vertexPos", function () {
                                                                                                                                                                return mesh.vertexArray;
                                                                                                                        }.bind(this));
                                                                                                                        this.comp_renderer_node.setArg("vertexNormal", function () {
                                                                                                                                                                return mesh.normalArray;
                                                                                                                        }.bind(this));
                                                                                                                        this.comp_renderer_node.setArg("vertexTexture", function () {
                                                                                                                                                                return mesh.textureArray;
                                                                                                                        }.bind(this));
                                                                                                                        this.comp_renderer_node.setArg("vertexTextureUnit", function () {
                                                                                                                                                                return mesh.textureUnitArray;
                                                                                                                        }.bind(this));

                                                                                                                        this.comp_renderer_node.setArg("indices", function () {
                                                                                                                                                                return mesh.indexArray;
                                                                                                                        }.bind(this));

                                                                                                                        this.comp_renderer_node.setArg("PMatrix", function () {
                                                                                                                                                                return this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.PROJECTION).getMatrix().transpose().e;
                                                                                                                        }.bind(this));
                                                                                                                        this.comp_renderer_node.setArgUpdatable("PMatrix", true);
                                                                                                                        this.comp_renderer_node.setArg("cameraWMatrix", function () {
                                                                                                                                                                return this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.TRANSFORM_TARGET).getMatrix().transpose().e;
                                                                                                                        }.bind(this));
                                                                                                                        this.comp_renderer_node.setArgUpdatable("cameraWMatrix", true);
                                                                                                                        this.comp_renderer_node.setArg("nodeWMatrix", function () {
                                                                                                                                                                return _this.nodes.getComponent(_Constants.Constants.COMPONENT_TYPES.TRANSFORM).getMatrixPosition().transpose().e;
                                                                                                                        });
                                                                                                                        this.comp_renderer_node.setArgUpdatable("nodeWMatrix", true);

                                                                                                                        this.comp_renderer_node.setArg("texAlbedo", function () {
                                                                                                                                                                return mesh.vertexArray;
                                                                                                                        }.bind(this));
                                                                                }
                                        }, {
                                                                                key: "setImage",


                                                                                /**
                                                                                * setImage
                                                                                * @param {String} url
                                                                                */
                                                                                value: function setImage(url) {
                                                                                                                        var _this2 = this;

                                                                                                                        var image = new Image();
                                                                                                                        image.onload = function () {
                                                                                                                                                                _this2.comp_renderer_node.setArg("texAlbedo", function () {
                                                                                                                                                                                                        return image;
                                                                                                                                                                });
                                                                                                                        };
                                                                                                                        image.src = url;
                                                                                }
                                        }, {
                                                                                key: "setVoxelsArrays",


                                                                                /**
                                                                                * setVoxelsArrays
                                                                                * @param {Object} jsonIn
                                                                                * @param {Array<number>|Float32Array|Uint8Array|WebGLTexture|HTMLImageElement} [jsonIn.albedo=undefined]
                                                                                * @param {Array<number>|Float32Array|Uint8Array|WebGLTexture|HTMLImageElement} [jsonIn.position=undefined]
                                                                                * @param {Array<number>|Float32Array|Uint8Array|WebGLTexture|HTMLImageElement} [jsonIn.normal=undefined]
                                                                                */
                                                                                value: function setVoxelsArrays(jsonIn) {
                                                                                                                        if (jsonIn.hasOwnProperty("albedo") === true) this.comp_renderer_node.setArg("sampler_voxelColor", function () {
                                                                                                                                                                return jsonIn.albedo;
                                                                                                                        }.bind(this));

                                                                                                                        if (jsonIn.hasOwnProperty("position") === true) this.comp_renderer_node.setArg("sampler_voxelPos", function () {
                                                                                                                                                                return jsonIn.position;
                                                                                                                        }.bind(this));

                                                                                                                        if (jsonIn.hasOwnProperty("normal") === true) this.comp_renderer_node.setArg("sampler_voxelNormal", function () {
                                                                                                                                                                return jsonIn.normal;
                                                                                                                        }.bind(this));
                                                                                }
                                        }, {
                                                                                key: "runGI",


                                                                                /**
                                                                                * runGI
                                                                                */
                                                                                value: function runGI() {
                                                                                                                        //        this.comp_renderer_node.addArgument("float4* sampler_GIVoxel", (function(){return null;}).bind(this), null ,"FLOAT4");

                                                                                                                        var comp_screenEffects = this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.GPU);
                                                                                                                        comp_screenEffects.getComponentBufferArg("sampler_GIVoxel", this.comp_renderer_node);
                                                                                                                        comp_screenEffects.gpufG.addKernel({
                                                                                                                                                                "type": "KERNEL",
                                                                                                                                                                "name": "GIsum",
                                                                                                                                                                "viewSource": false,
                                                                                                                                                                "config": ["x", undefined,
                                                                                                                                                                // head
                                                                                                                                                                '',
                                                                                                                                                                // source
                                                                                                                                                                // GI
                                                                                                                                                                'vec4 textureFBGIVoxel = sampler_GIVoxel[x];\n' + 'vec3 GIweight = vec3((textureFBGIVoxel.r/textureFBGIVoxel.a), (textureFBGIVoxel.g/textureFBGIVoxel.a), (textureFBGIVoxel.b/textureFBGIVoxel.a));' + 'return vec4(GIweight, 1.0);' +

                                                                                                                                                                //'return vec4(textureFBGIVoxel.xyz, 1.0);'+
                                                                                                                                                                ''],
                                                                                                                                                                "drawMode": 4,
                                                                                                                                                                "depthTest": false,
                                                                                                                                                                "blend": false,
                                                                                                                                                                "blendEquation": _Constants.Constants.BLENDING_EQUATION_TYPES.FUNC_ADD,
                                                                                                                                                                "blendSrcMode": _Constants.Constants.BLENDING_MODES.ONE,
                                                                                                                                                                "blendDstMode": _Constants.Constants.BLENDING_MODES.ZERO });

                                                                                                                        var arr = new Float32Array(this._sce.getDimensions().width * this._sce.getDimensions().height * 4);
                                                                                                                        this.comp_renderer_node.setArg("sampler_screenColor", function () {
                                                                                                                                                                return arr;
                                                                                                                        }.bind(this));
                                                                                                                        this.comp_renderer_node.setArg("sampler_screenPos", function () {
                                                                                                                                                                return arr;
                                                                                                                        }.bind(this));
                                                                                                                        this.comp_renderer_node.setArg("sampler_screenNormal", function () {
                                                                                                                                                                return arr;
                                                                                                                        }.bind(this));
                                                                                                                        this.comp_renderer_node.setArg("sampler_GIVoxel", function () {
                                                                                                                                                                return arr;
                                                                                                                        }.bind(this));

                                                                                                                        this.comp_renderer_node.gpufG.fillArg("sampler_screenColor", [1.0, 1.0, 1.0, 1.0]);
                                                                                                                        this.comp_renderer_node.gpufG.fillArg("sampler_screenPos", [1.0, 1.0, 1.0, 1.0]);
                                                                                                                        this.comp_renderer_node.gpufG.fillArg("sampler_screenNormal", [1.0, 1.0, 1.0, 0.0]);
                                                                                                                        this.comp_renderer_node.gpufG.fillArg("sampler_GIVoxel", [1.0, 1.0, 1.0, 1.0]);

                                                                                                                        this.comp_renderer_node.gpufG.enableGraphic(1);
                                                                                                                        this._runGI = true;
                                                                                }
                                        }, {
                                                                                key: "getComponentRendererNode",
                                                                                value: function getComponentRendererNode() {
                                                                                                                        return this.comp_renderer_node;
                                                                                }
                                        }, {
                                                                                key: "isRunned",


                                                                                /**
                                                                                * isRunned
                                                                                * @returns {boolean}
                                                                                */
                                                                                value: function isRunned() {
                                                                                                                        return this._runGI;
                                                                                }
                                        }, {
                                                                                key: "stop",


                                                                                /**
                                                                                * stop
                                                                                */
                                                                                value: function stop() {
                                                                                                                        var comp_screenEffects = this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.GPU);
                                                                                }
                                        }, {
                                                                                key: "resume",


                                                                                /**
                                                                                * resume
                                                                                */
                                                                                value: function resume() {
                                                                                                                        this.comp_renderer_node.gpufG.fillArg("sampler_screenColor", [1.0, 1.0, 1.0, 1.0]);
                                                                                                                        this.comp_renderer_node.gpufG.fillArg("sampler_screenPos", [1.0, 1.0, 1.0, 1.0]);
                                                                                                                        this.comp_renderer_node.gpufG.fillArg("sampler_screenNormal", [1.0, 1.0, 1.0, 0.0]);
                                                                                                                        this.comp_renderer_node.gpufG.fillArg("sampler_GIVoxel", [1.0, 1.0, 1.0, 1.0]);

                                                                                                                        var comp_screenEffects = this._project.getActiveStage().getActiveCamera().getComponent(_Constants.Constants.COMPONENT_TYPES.GPU);
                                                                                }
                                        }]);

                                        return GI;
}();

global.GI = GI;
module.exports.GI = GI;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../Constants":2,"../../Utils.class":4}],4:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Utils = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

require("webclgl");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* @class
*/
var Utils = exports.Utils = function () {
    function Utils() {
        _classCallCheck(this, Utils);

        window.requestAnimFrame = function () {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
        }();
    }

    /**
    * Get HTMLCanvasElement from Uint8Array
    * @param {Uint8Array} uint8arr
    * @param {int} width
    * @param {int} height
     * @returns {HTMLCanvasElement}
    */


    _createClass(Utils, [{
        key: "getImageFromCanvas",

        /**
         * @callback Utils~getImageFromCanvas~onload
         * @param {HTMLImageElement} img
         */
        /**
        * Get HTMLImageElement from canvas
        * @param {HTMLCanvasElement} oldCanvas
        * @param {Utils~getImageFromCanvas~onload} onload
        */
        value: function getImageFromCanvas(oldCanvas, onload) {
            var imagen = document.createElement('img');
            imagen.onload = function () {
                onload(imagen);
            };
            imagen.src = oldCanvas.toDataURL();
        }
    }, {
        key: "pack",


        /**
         * Angle between two vectors viewing from top
         * @returns {number}
         * @param {StormV3} vectorA
         * @param {StormV3} vectorB
          Utils.prototype.angle = function(vA, vB) {
            let vAA = vA.normalize();
            let vBB = vB.normalize();
              let escalarProduct = Math.acos((vAA.e[0]*vBB.e[0])+(vAA.e[1]*vBB.e[1])+(vAA.e[2]*vBB.e[2]));
              let vCC = vAA.cross(vBB);
            //console.log(vCC.e[0]+" "+vCC.e[1]+" "+vCC.e[2]);
              if(vCC.e[1] == 1) {
                escalarProduct = (Math.PI+escalarProduct);
            }
              return escalarProduct;
        };*/

        /**
        * Pack 1float (0.0-1.0) to 4float rgba (0.0-1.0, 0.0-1.0, 0.0-1.0, 0.0-1.0)*
        * @param {number} value
        * @returns {Array<number>}
        *
        */
        value: function pack(value) {
            var bias = [1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0];

            var r = value;
            var g = Utils.fract(r * 255.0);
            var b = Utils.fract(g * 255.0);
            var a = Utils.fract(b * 255.0);
            var colour = [r, g, b, a];

            var dd = [colour[1] * bias[0], colour[2] * bias[1], colour[3] * bias[2], colour[3] * bias[3]];

            return [colour[0] - dd[0], colour[1] - dd[1], colour[2] - dd[2], colour[3] - dd[3]];
        }
    }, {
        key: "unpack",

        /**
        * Unpack 4float rgba (0.0-1.0, 0.0-1.0, 0.0-1.0, 0.0-1.0) to 1float (0.0-1.0)
        * @param {Array<number>} value
         * @returns {number}
        */
        value: function unpack(value) {
            var bitShifts = [1.0, 1.0 / 255.0, 1.0 / (255.0 * 255.0), 1.0 / (255.0 * 255.0 * 255.0)];
            return Utils.dot4(value, bitShifts);
        }
    }], [{
        key: "getCanvasFromUint8Array",
        value: function getCanvasFromUint8Array(uint8arr, width, height) {
            var e = document.createElement('canvas');
            e.width = width;
            e.height = height;
            var ctx2D = e.getContext("2d");
            var image = ctx2D.createImageData(width, height);
            for (var i = 0; i < image.data.length; i++) {
                image.data[i] = uint8arr[i];
            }ctx2D.putImageData(image, 0, 0);

            return e;
        }
    }, {
        key: "getUint8ArrayFromHTMLImageElement",


        /**
        * Get Uint8Array from HTMLImageElement
        * @param {HTMLImageElement} imageElement
         * @returns {Uint8ClampedArray}
        */
        value: function getUint8ArrayFromHTMLImageElement(imageElement) {
            var e = document.createElement('canvas');
            e.width = imageElement.width;
            e.height = imageElement.height;
            var ctx2D_tex = e.getContext("2d");
            ctx2D_tex.drawImage(imageElement, 0, 0);
            var arrayTex = ctx2D_tex.getImageData(0, 0, imageElement.width, imageElement.height);

            return arrayTex.data;
        }
    }, {
        key: "getVector",


        /**
        * Get random vector from vecNormal with deviation in degrees
        * @param {StormV3} vecNormal
        * @param {number} degrees
         * @returns {StormV3}
        */
        value: function getVector(vecNormal, degrees) {
            var ob = Utils.cartesianToSpherical(vecNormal);
            var angleLat = ob.lat;
            var angleLng = ob.lng;

            var desvLat = Math.random() * 180.0 - 90.0;
            var desvLng = Math.random() * 180.0 - 90.0;
            angleLat += degrees * desvLat;
            angleLng += degrees * desvLng;

            return Utils.sphericalToCartesian(1.0, angleLat, angleLng);
        }
    }, {
        key: "getVectorGLSLFunctionString",

        /**
        * Get random vector from vecNormal with deviation in degrees (GLSL)
        * @returns {String}
        */
        value: function getVectorGLSLFunctionString() {
            return 'vec3 getVector(vec3 vecNormal, float degrees, vec2 vecNoise) {\n' + 'vec3 ob = cartesianToSpherical(vecNormal);' + 'float angleLat = ob.y;' + 'float angleLng = ob.z;' + 'float desvLat = (vecNoise.x*180.0)-90.0;' + 'float desvLng = (vecNoise.y*180.0)-90.0;' + 'angleLat += (degrees*desvLat);' + 'angleLng += (degrees*desvLng);' + 'return sphericalToCartesian(vec3(1.0, angleLat, angleLng));' + '}\n';
        }
    }, {
        key: "cartesianToSpherical",


        /**
         * cartesianToSpherical
         * @param {StormV3} vec
         * @returns {Object}
         * @example
         * $V3([1,0,0])  return {radius: 1, lat: 90, lng: 0}
         * $V3([0,0,1])  return {radius: 1, lat: 90, lng: 90}
         * $V3([-1,0,0]) return {radius: 1, lat: 90, lng: 180}
         * $V3([0,0,-1]) return {radius: 1, lat: 90, lng: -90}
         */
        value: function cartesianToSpherical(vec) {
            var r = Math.sqrt(vec.e[0] * vec.e[0] + vec.e[1] * vec.e[1] + vec.e[2] * vec.e[2]);

            var angleLat = Utils.radToDeg(Math.acos(vec.e[1] / r));
            var angleLng = Utils.radToDeg(Math.atan2(vec.e[2], vec.e[0]));

            return { "radius": r,
                "lat": angleLat,
                "lng": angleLng };
        }
    }, {
        key: "cartesianToSphericalGLSLFunctionString",

        /**
         * cartesianToSpherical (GLSL)
        * @returns {String}
        */
        value: function cartesianToSphericalGLSLFunctionString() {
            return 'vec3 cartesianToSpherical(vec3 vect) {\n' + 'float r = sqrt(vect.x*vect.x + vect.y*vect.y + vect.z*vect.z);' + 'float angleLat = radToDeg(acos(vect.y/r));' + 'float angleLng = radToDeg(atan(vect.z, vect.x));' + 'return vec3(r, angleLat, angleLng);' + '}\n';
        }
    }, {
        key: "sphericalToCartesian",


        /**
         * sphericalToCartesian
         * @param {number} radius
         * @param {number} lat Lat in degrees
         * @param {number} lng Lng in degrees
         * @returns {StormV3}
         * @example
         * (1.0, 90.0, 0.0).e) return $V3([1,0,0])
         * (1.0, 90.0, 90.0).e) return $V3([0,0,1])
         * (1.0, 90.0, 180.0).e) return $V3([-1,0,0])
         * (1.0, 90.0, -90.0).e) return $V3([0,0,-1])
         **/
        value: function sphericalToCartesian(radius, lat, lng) {
            var r = radius;
            var angleLat = Utils.degToRad(lat);
            var angleLng = Utils.degToRad(lng);

            var x = r * Math.sin(angleLat) * Math.cos(angleLng);
            var z = r * Math.sin(angleLat) * Math.sin(angleLng);
            var y = r * Math.cos(angleLat);

            return new StormV3([x, y, z]);
        }
    }, {
        key: "sphericalToCartesianGLSLFunctionString",

        /**
         * sphericalToCartesian (GLSL)
        * @returns {String}
        */
        value: function sphericalToCartesianGLSLFunctionString() {
            return 'vec3 sphericalToCartesian(vec3 vect) {\n' + 'float r = vect.x;' + 'float angleLat = degToRad(vect.y);' + 'float angleLng = degToRad(vect.z);' + 'float x = r*sin(angleLat)*cos(angleLng);' + 'float z = r*sin(angleLat)*sin(angleLng);' + 'float y = r*cos(angleLat);' + 'return vec3(x,y,z);' + '}\n';
        }
    }, {
        key: "refract",


        /**
        * Refract
        * @param {StormV3} V
        * @param {StormV3} N
        * @param {number} n1 Refract index way 1
        * @param {number} n2 Refract index way 2
         * @returns {StormV3}
        */
        value: function refract(V, N, n1, n2) {
            var refrIndex = n1 / n2;
            var cosI = N.dot(V) * -1.0;
            var cosT2 = 1.0 - refrIndex * refrIndex * (1.0 - cosI * cosI);
            var vv = V.x(refrIndex);
            return vv.add(N.x(refrIndex * cosI - Math.sqrt(cosT2)));
        }
    }, {
        key: "degToRad",


        /**
        * Degrees to radians. Full circle = 360 degrees.
        * @param {number} degrees
         * @returns {number}
        */
        value: function degToRad(degrees) {
            return degrees * 3.14159 / 180;
        }
    }, {
        key: "degToRadGLSLFunctionString",

        /**
         * Degrees to radians. Full circle = 360 degrees. (GLSL)
        * @returns {String}
        */
        value: function degToRadGLSLFunctionString() {
            return 'float degToRad(float deg) {' + 'return (deg*3.14159)/180.0;' + '}';
        }
    }, {
        key: "radToDeg",


        /**
        * Radians to degrees
        * @param {number} radians
         * @returns {number}
        */
        value: function radToDeg(radians) {
            return radians * (180 / 3.14159);
        }
    }, {
        key: "radToDegGLSLFunctionString",

        /**
         * Radians to degrees (GLSL)
        * @returns {String}
        */
        value: function radToDegGLSLFunctionString() {
            return 'float radToDeg(float rad) {' + 'return rad*(180.0/3.14159);' + '}';
        }
    }, {
        key: "hexToRgb",


        /**
         * hexToRgb
         * @param {String} hex
         * @returns  {Array<number>} rgb values from 0 to 255
         */
        value: function hexToRgb(hex) {
            // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                return r + r + g + g + b + b;
            });

            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
    }, {
        key: "rgbToHex",

        /**
         * rgbToHex
         * @param {Array<number>} rgb values from 0 to 255
         * @returns {String}
         */
        value: function rgbToHex(rgb) {
            var rgbVal = rgb[2] | rgb[1] << 8 | rgb[0] << 16;
            return '#' + (0x1000000 + rgbVal).toString(16).slice(1);
        }
    }, {
        key: "invsqrt",


        /**
        * Inverse sqrt
        * @param {number} value
         * @returns {number}
        */
        value: function invsqrt(value) {
            return 1.0 / value;
        }
    }, {
        key: "smoothstep",


        /**
        * Smoothstep
        * @param {number} edge0
        * @param {number} edge1
        * @param {number} current
         * @returns {number}
        */
        value: function smoothstep(edge0, edge1, current) {
            if (current < edge0) return 0;
            if (current >= edge1) return 1;
            if (edge0 === edge1) return -1;
            var p = (current - edge0) / (edge1 - edge0);

            return p * p * (3 - 2 * p);
        }
    }, {
        key: "dot4",


        /**
        * Dot product vector4float
        * @param {Array<number>} vector4A Vector a
        * @param {Array<number>} vector4B Vector b
         * @returns {number}
        */
        value: function dot4(vector4A, vector4B) {
            return vector4A[0] * vector4B[0] + vector4A[1] * vector4B[1] + vector4A[2] * vector4B[2] + vector4A[3] * vector4B[3];
        }
    }, {
        key: "fract",


        /**
        * Compute the fractional part of the argument. Example: fract(pi)=0.14159265...
        * @param {number} value
         * @returns {number}
        */
        value: function fract(value) {
            return value > 0 ? value - Math.floor(value) : value - Math.ceil(value);
        }
    }, {
        key: "packGLSLFunctionString",

        /**
        * Get pack GLSL function string
        * @returns {String}
        */
        value: function packGLSLFunctionString() {
            return 'vec4 pack (float depth) {' + 'const vec4 bias = vec4( 1.0 / 255.0,' + '1.0 / 255.0,' + '1.0 / 255.0,' + '0.0);' + 'float r = depth;' + 'float g = fract(r * 255.0);' + 'float b = fract(g * 255.0);' + 'float a = fract(b * 255.0);' + 'vec4 colour = vec4(r, g, b, a);' + 'return colour - (colour.yzww * bias);' + '}';
        }
    }, {
        key: "unpackGLSLFunctionString",

        /**
        * Get unpack GLSL function string
        * @returns {String}
        */
        value: function unpackGLSLFunctionString() {
            return 'float unpack (vec4 colour) {' + 'const vec4 bitShifts = vec4(1.0,' + '1.0 / 255.0,' + '1.0 / (255.0 * 255.0),' + '1.0 / (255.0 * 255.0 * 255.0));' + 'return dot(colour, bitShifts);' + '}';
        }
    }, {
        key: "rayTraversalInitSTR",
        value: function rayTraversalInitSTR() {
            return '' + 'float wh = ceil(sqrt(uResolution*uResolution*uResolution));\n' + 'float cs = uGridsize/uResolution;\n' + // cell size
            'float chs = cs/2.0;\n' + // cell size
            'float texelSize = 1.0/(wh-1.0);\n' + // 1.0/(wh-1.0)??

            // Fast Voxel Traversal Algorithm for Ray Tracing. John Amanatides & Andrew Woo.
            // http://www.cse.chalmers.se/edu/course/TDA361/grid.pdf
            // More info:
            // http://www.clockworkcoders.com/oglsl/rt/gpurt3.htm
            'vec3 gl = vec3(-(uGridsize/2.0), -(uGridsize/2.0), -(uGridsize/2.0));\n' + 'vec3 _r = vec3(uGridsize, uGridsize, uGridsize);\n' + 'vec3 _rRes = vec3(uResolution, uResolution, uResolution);\n' + 'vec3 _len = _r/_rRes;\n' + 'vec3 worldToVoxel(vec3 world) {\n' + 'vec3 ijk = (world - gl) / _len;\n' + // (1.0-(-1.0)) / (2/64) = 64
            'ijk = vec3(floor(ijk.x), floor(ijk.y), floor(ijk.z));\n' + 'return ijk;\n' + '}\n' + 'float voxelToWorldX(float x) {return x * _len.x + gl.x;}\n' + // 64*(2/64)+(-1.0) = 1.0
            'float voxelToWorldY(float y) {return y * _len.y + gl.y;}\n' + 'float voxelToWorldZ(float z) {return z * _len.z + gl.z;}\n';
        }
    }, {
        key: "rayTraversalSTR",
        value: function rayTraversalSTR(resolution) {
            return '' + 'vec2 getId(vec3 voxel) {\n' + 'int tex3dId = (int(voxel.y)*(int(uResolution)*int(uResolution)))+(int(voxel.z)*(int(uResolution)))+int(voxel.x);\n' + 'float num = float(tex3dId)/wh;\n' + 'float col = fract(num)*wh;\n' + 'float row = floor(num);\n' + 'return vec2(col*texelSize, row*texelSize);\n' + '}\n' + 'vec4 getVoxel_Color(vec2 texVec, vec3 voxel, vec3 RayOrigin) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelColor[vec2(texVec.x, texVec.y)];\n' + 'if(texture.a/255.0 > 0.5) {\n' + // existen triángulos dentro?
            'rgba = vec4(texture.rgb/255.0,distance(vec3(voxelToWorldX(voxel.x), voxelToWorldX(voxel.y), voxelToWorldX(voxel.z)),RayOrigin));\n' + '}\n' + 'return rgba;\n' + '}\n' + 'vec4 getVoxel_Pos(vec2 texVec) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelPos[vec2(texVec.x, texVec.y)];\n' +
            //distance(vec3(voxelToWorldX(voxel.x), voxelToWorldX(voxel.y), voxelToWorldX(voxel.z)),RayOrigin)
            'rgba = vec4( ((texture.xyz/255.0)*uGridsize)-(uGridsize/2.0), 1.0);\n' + 'return rgba;\n' + '}\n' + 'vec4 getVoxel_Normal(vec2 texVec) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelNormal[vec2(texVec.x, texVec.y)];\n' + 'rgba = vec4(((texture.rgb/255.0)*2.0)-1.0, 1.0);\n' + 'return rgba;\n' + '}\n' + 'struct RayTraversalResponse {' + 'vec4 voxelColor;' + 'vec4 voxelPos;' + 'vec4 voxelNormal;' + '};' + 'RayTraversalResponse rayTraversal(vec3 RayOrigin, vec3 RayDir) {\n' + 'vec4 fvoxelColor = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec4 fvoxelPos = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec4 fvoxelNormal = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec3 voxel = worldToVoxel(RayOrigin);' + 'vec3 _dir = normalize(RayDir);' + 'vec3 tMax;' + 'if(RayDir.x < 0.0) tMax.x = (voxelToWorldX(voxel.x)-RayOrigin.x)/RayDir.x;' + 'if(RayDir.x > 0.0) tMax.x = (voxelToWorldX(voxel.x+1.0)-RayOrigin.x)/RayDir.x;' + 'if(RayDir.y < 0.0) tMax.y = (voxelToWorldY(voxel.y)-RayOrigin.y)/RayDir.y;' + 'if(RayDir.y < 0.0) tMax.y = (voxelToWorldY(voxel.y+1.0)-RayOrigin.y)/RayDir.y;' + 'if(RayDir.z < 0.0) tMax.z = (voxelToWorldZ(voxel.z)-RayOrigin.z)/RayDir.z;' + 'if(RayDir.z < 0.0) tMax.z = (voxelToWorldZ(voxel.z+1.0)-RayOrigin.z)/RayDir.z;' + 'float tDeltaX = _r.x/abs(RayDir.x);' + // hasta qué punto se debe avanzar en la dirección del rayo antes de que nos encontramos con un nuevo voxel en la dirección x
            'float tDeltaY = _r.y/abs(RayDir.y);' + 'float tDeltaZ = _r.z/abs(RayDir.z);' + 'float stepX = 1.0; float stepY = 1.0; float stepZ = 1.0;\n' + 'float outX = _r.x; float outY = _r.y; float outZ = _r.z;\n' + 'if(RayDir.x < 0.0) {stepX = -1.0; outX = -1.0;}' + 'if(RayDir.y < 0.0) {stepY = -1.0; outY = -1.0;}' + 'if(RayDir.z < 0.0) {stepZ = -1.0; outZ = -1.0;}' + 'vec4 color = vec4(0.0,0.0,0.0,0.0);\n' + 'bool c1; bool c2; bool c3; bool isOut;' + 'vec2 vid;' + 'for(int c = 0; c < ' + resolution + '*2; c++) {\n' + 'c1 = bool(tMax.x < tMax.y);' + 'c2 = bool(tMax.x < tMax.z);' + 'c3 = bool(tMax.y < tMax.z);' + 'isOut = false;' + 'if (c1 && c2) {' + 'voxel.x += stepX;' + 'if(voxel.x==outX) isOut=true;' + 'tMax.x += tDeltaX;' + '} else if(( (c1 && !c2) || (!c1 && !c3) )) {' + 'voxel.z += stepZ;' + 'if(voxel.z==outZ) isOut=true;' + 'tMax.z += tDeltaZ;' + '} else if(!c1 && c3) {' + 'voxel.y += stepY;' + 'if(voxel.y==outY) isOut=true;' + 'tMax.y += tDeltaY;' + '}' + 'if(isOut == true) break;\n' + 'else {' + 'if((voxel.x >= 0.0 && voxel.x <= _rRes.x && voxel.y >= 0.0 && voxel.y <= _rRes.y && voxel.z >= 0.0 && voxel.z <= _rRes.z)) {;\n' + 'vid = getId(voxel);' + 'vec4 vcc = getVoxel_Color(vid, voxel, RayOrigin);' + 'if(vcc.a != 0.0) {' + 'fvoxelColor = vcc;' + 'break;\n' + '}' + '}' + '}' + '}' + 'fvoxelPos = getVoxel_Pos(vid);' + 'fvoxelNormal = getVoxel_Normal(vid);' + 'return RayTraversalResponse(fvoxelColor, fvoxelPos, fvoxelNormal);' + '}\n';
        }
    }, {
        key: "isPowerOfTwo",
        value: function isPowerOfTwo(x) {
            return (x & x - 1) === 0;
        }
    }, {
        key: "nextHighestPowerOfTwo",
        value: function nextHighestPowerOfTwo(x) {
            --x;
            for (var i = 1; i < 32; i <<= 1) {
                x = x | x >> i;
            }
            return x + 1;
        }
    }, {
        key: "getElementPosition",
        value: function getElementPosition(element) {
            var elem = element,
                tagname = "",
                x = 0,
                y = 0;

            while ((typeof elem === "undefined" ? "undefined" : _typeof(elem)) === "object" && typeof elem.tagName !== "undefined") {
                y += elem.offsetTop;
                x += elem.offsetLeft;
                tagname = elem.tagName.toUpperCase();

                if (tagname === "BODY") elem = 0;

                if ((typeof elem === "undefined" ? "undefined" : _typeof(elem)) === "object") {
                    if (_typeof(elem.offsetParent) === "object") elem = elem.offsetParent;
                }
            }

            return { x: x, y: y };
        }
    }, {
        key: "getWebGLContextFromCanvas",
        value: function getWebGLContextFromCanvas(canvas, ctxOpt) {
            return WebCLGLUtils.getWebGLContextFromCanvas(canvas, ctxOpt);
        }
    }, {
        key: "fullScreen",
        value: function fullScreen() {
            if (!document.fullscreenElement && // alternative standard method
            !document.mozFullScreenElement && !document.webkitFullscreenElement) {
                // current working methods
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) {
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                }
            } else {
                if (document.cancelFullScreen) {
                    document.cancelFullScreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen();
                }
            }
        }
    }]);

    return Utils;
}();

global.Utils = Utils;
module.exports.Utils = Utils;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"webclgl":1}]},{},[3]);
