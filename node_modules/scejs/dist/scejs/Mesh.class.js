(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

var exp = { "WebCLGL": "./WebCLGL.class",
            "WebCLGLBuffer": "./WebCLGLBuffer.class.js",
            "WebCLGLFor": "./WebCLGLFor.class.js",
            "WebCLGLKernel": "./WebCLGLKernel.class.js",
            "WebCLGLUtils": "./WebCLGLUtils.class.js",
            "WebCLGLVertexFragmentProgram": "./WebCLGLVertexFragmentProgram.class.js"
};

for(var key in exp)
    exports[key] = require(exp[key]);
},{}],2:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Mesh = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Utils = require("./Utils.class");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* @class
* @constructor
*/
var Mesh = exports.Mesh = function () {
	function Mesh() {
		_classCallCheck(this, Mesh);

		this._obj = {};
		this._textures = {};
		this.objIndex = null; // for store new indexes
		this.indexMax = 0;
	}

	/**
 * Load a point
 */


	_createClass(Mesh, [{
		key: "loadPoint",
		value: function loadPoint() {
			this._obj.vertexArray = [0.0, 0.0, 0.0, 0.0];
			this._obj.normalArray = [0.0, 1.0, 0.0, 0.0];
			this._obj.textureArray = [0.0, 0.0, 0.0, 0.0];
			this._obj.textureUnitArray = [0.0];
			this._obj.indexArray = [0];

			return this._obj;
		}
	}, {
		key: "loadTriangle",


		/**
  * Load a triangle
  * @param {Object} jsonIn
  * @param {number} [jsonIn.scale=1.0]
  * @param {number} [jsonIn.side=1.0]
  */
		value: function loadTriangle(jsonIn) {
			var sca = jsonIn !== undefined && jsonIn.scale !== undefined ? jsonIn.scale : 1.0;
			var side = jsonIn !== undefined && jsonIn.side !== undefined ? jsonIn.side : 1.0;

			this._obj.vertexArray = [0.0, 0.0, 0.0, 1.0, side / 2 * sca, 0.0, -1.0 * sca, 1.0, -(side / 2) * sca, 0.0, -1.0 * sca, 1.0];
			this._obj.normalArray = [0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0];
			this._obj.textureArray = [0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0];
			this._obj.textureUnitArray = [0.0, 0.0, 0.0];
			this._obj.indexArray = [0, 1, 2];

			return this._obj;
		}
	}, {
		key: "loadQuad",


		/**
  * Load a quad
  * @param {number} length
  * @param {number} height
  * @returns {Object}
  */
		value: function loadQuad(length, height) {
			var l = length === undefined ? 0.5 : length;
			var h = height === undefined ? 0.5 : height;

			this._obj = {};
			this._obj.vertexArray = [-l, -h, 0.0, 1.0, // Front face
			l, -h, 0.0, 1.0, l, h, 0.0, 1.0, -l, h, 0.0, 1.0];
			this._obj.normalArray = [0.0, 0.0, 1.0, 1.0, // Front face
			0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0];
			this._obj.textureArray = [0.0, 0.0, 0.0, 1.0, // Front face
			1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0];
			this._obj.textureUnitArray = [0.0, 0.0, 0.0, 0.0];
			this._obj.indexArray = [0, 1, 2, 0, 2, 3]; // Front face

			return this._obj;
		}
	}, {
		key: "loadCircle",


		/**
  * Load a circle
  * @param {Object} jsonIn
  * @param {int} jsonIn.segments
  * @param {number} jsonIn.radius
  * @returns {Object}
  */
		value: function loadCircle(jsonIn) {
			this._obj = { "vertexArray": [],
				"normalArray": [],
				"textureArray": [],
				"textureUnitArray": [],
				"indexArray": [] };
			this.objIndex = [];
			this.indexMax = 0;

			var segments = jsonIn !== undefined && jsonIn.segments !== undefined ? jsonIn.segments : 6;
			var rad = jsonIn !== undefined && jsonIn.radius !== undefined ? jsonIn.radius : 0.5;

			var stepAngle = 360.0 / segments;
			var numSegH = 360.0 / stepAngle;

			var cos = function (val) {
				return Math.cos(new _Utils.Utils().degToRad(val));
			}.bind(this);
			var sin = function (val) {
				return Math.sin(new _Utils.Utils().degToRad(val));
			}.bind(this);

			for (var h = 1, fh = numSegH; h <= fh; h++) {
				var currAngleH = stepAngle * h;
				// PRIMER TRIÁNGULO
				// vertices
				var vA1 = $V3([cos(currAngleH) * rad, 0.0, sin(currAngleH) * rad]);
				var vB1 = $V3([cos(currAngleH - stepAngle) * rad, 0.0, sin(currAngleH - stepAngle) * rad]);
				var vC1 = $V3([0.0, 0.0, 0.0]);
				// normales
				var norm = vB1.subtract(vA1).cross(vC1.subtract(vA1)).normalize();
				// texturas
				var tA1 = $V3([currAngleH / 360.0, 0.0, 0.0]);
				var tB1 = $V3([(currAngleH - stepAngle) / 360.0, 0.0, 0.0]);
				var tC1 = $V3([0.0, 0.0, 0.0]);
				//indices
				var indexA = this.testIfInIndices(this._obj, vA1, norm, tA1);
				var indexB = this.testIfInIndices(this._obj, vB1, norm, tB1);
				var indexC = this.testIfInIndices(this._obj, vC1, norm, tC1);

				this._obj.indexArray.push(indexA, indexB, indexC);
			}

			return this._obj;
		}
	}, {
		key: "testIfInIndices",
		value: function testIfInIndices(_obj, vA1, norm, tA1) {
			var indexA = undefined;
			for (var nB = 0, fb = this.objIndex.length; nB < fb; nB++) {
				if (this.objIndex[nB].v.e[0] === vA1.e[0] && this.objIndex[nB].v.e[1] === vA1.e[1] && this.objIndex[nB].v.e[2] === vA1.e[2]) {
					indexA = this.objIndex[nB].i;
				}
			}
			if (indexA === undefined) {
				indexA = this.indexMax;
				this.objIndex.push({ i: indexA, v: $V3([vA1.e[0], vA1.e[1], vA1.e[2]]) });
				this.indexMax++;
				_obj.vertexArray.push(vA1.e[0], vA1.e[1], vA1.e[2], 1.0);
				_obj.normalArray.push(norm.e[0], norm.e[1], norm.e[2], 1.0);
				_obj.textureArray.push(vA1.e[0] + 0.5, vA1.e[2] + 0.5, vA1.e[2] + 0.5, 1.0);
				_obj.textureUnitArray.push(0.0);
			}
			return indexA;
		}
	}, {
		key: "loadBox",


		/**
  * Load a box
  * @returns {Object}
  */
		value: function loadBox() {
			this._obj = {};

			var d = new Float32Array([0.5, 0.5, 0.5]);
			this._obj.vertexArray = [-1.0 * d[0], -1.0 * d[1], 1.0 * d[2], 1.0, // Front face
			1.0 * d[0], -1.0 * d[1], 1.0 * d[2], 1.0, 1.0 * d[0], 1.0 * d[1], 1.0 * d[2], 1.0, -1.0 * d[0], 1.0 * d[1], 1.0 * d[2], 1.0,
			// Back face
			-1.0 * d[0], -1.0 * d[1], -1.0 * d[2], 1.0, -1.0 * d[0], 1.0 * d[1], -1.0 * d[2], 1.0, 1.0 * d[0], 1.0 * d[1], -1.0 * d[2], 1.0, 1.0 * d[0], -1.0 * d[1], -1.0 * d[2], 1.0,
			// Top face
			-1.0 * d[0], 1.0 * d[1], -1.0 * d[2], 1.0, -1.0 * d[0], 1.0 * d[1], 1.0 * d[2], 1.0, 1.0 * d[0], 1.0 * d[1], 1.0 * d[2], 1.0, 1.0 * d[0], 1.0 * d[1], -1.0 * d[2], 1.0,
			// Bottom face
			-1.0 * d[0], -1.0 * d[1], -1.0 * d[2], 1.0, 1.0 * d[0], -1.0 * d[1], -1.0 * d[2], 1.0, 1.0 * d[0], -1.0 * d[1], 1.0 * d[2], 1.0, -1.0 * d[0], -1.0 * d[1], 1.0 * d[2], 1.0,
			// Right face
			1.0 * d[0], -1.0 * d[1], -1.0 * d[2], 1.0, 1.0 * d[0], 1.0 * d[1], -1.0 * d[2], 1.0, 1.0 * d[0], 1.0 * d[1], 1.0 * d[2], 1.0, 1.0 * d[0], -1.0 * d[1], 1.0 * d[2], 1.0,
			// Left face
			-1.0 * d[0], -1.0 * d[1], -1.0 * d[2], 1.0, -1.0 * d[0], -1.0 * d[1], 1.0 * d[2], 1.0, -1.0 * d[0], 1.0 * d[1], 1.0 * d[2], 1.0, -1.0 * d[0], 1.0 * d[1], -1.0 * d[2], 1.0];
			this._obj.normalArray = [0.0, 0.0, 1.0, 1.0, // Front face
			0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
			// Back face
			0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0,
			// Top face
			0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0,
			// Bottom face
			0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0,
			// Right face
			1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,
			// Left face
			-1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0];
			this._obj.textureArray = [0.0, 0.0, 0.0, 1.0, // Front face
			1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0,
			// Back face
			1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
			// Top face
			0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0,
			// Bottom face
			1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,
			// Right face
			1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
			// Left face
			0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0];
			this._obj.textureUnitArray = [0.0, 0.0, 0.0, 0.0, // Front face
			// Back face
			0.0, 0.0, 0.0, 0.0,
			// Top face
			0.0, 0.0, 0.0, 0.0,
			// Bottom face
			0.0, 0.0, 0.0, 0.0,
			// Right face
			0.0, 0.0, 0.0, 0.0,
			// Left face
			0.0, 0.0, 0.0, 0.0];
			this._obj.indexArray = [0, 1, 2, 0, 2, 3, // Front face
			4, 5, 6, 4, 6, 7, // Back face
			8, 9, 10, 8, 10, 11, // Top face
			12, 13, 14, 12, 14, 15, // Bottom face
			16, 17, 18, 16, 18, 19, // Right face
			20, 21, 22, 20, 22, 23]; // Left face

			return this._obj;
		}
	}, {
		key: "loadObj",


		/**
   * @typedef {Object} Mesh~ImageData
   * @property {int} Mesh~ImageData.fileUrl
   * @property {int} Mesh~ImageData.materialName
   */
		/**
   * This callback is displayed as part of the onSelectNode
   * @callback Mesh~loadObj~onload
   * @param {Mesh} mesh
   * @param {Mesh~ImageData} textures
   */
		/**
  * Load a object from url of obj file
  * @param {String} objUrl
  * @param {Mesh~loadObj~onload} onload
  */
		value: function loadObj(objUrl, onload) {
			var objDirectory = '';
			var expl = objUrl.split("/");
			for (var n = 0, f = expl.length - 1; n < f; n++) {
				objDirectory = objDirectory + expl[n] + '/';
			}var req = new XMLHttpRequest();
			req.open("GET", objUrl, true);
			req.responseType = "blob";
			req.onload = function (onload) {
				var filereader = new FileReader();
				filereader.onload = function (onload, event) {
					var text = event.target.result;

					this.loadObjFromSourceText({ "sourceText": text, "objDirectory": objDirectory });

					if (onload !== undefined && typeof onload === 'function') onload(this._obj, this._textures);
				}.bind(this, onload);
				filereader.readAsText(req.response);
			}.bind(this, onload);
			req.send(null);
		}
	}, {
		key: "loadObjFromSourceText",


		/**
  * Load a object from text-plain on obj format
  * @param {Object} jsonIn
  * @param {String} jsonIn.sourceText
  * @param {String} jsonIn.objDirectory
  */
		value: function loadObjFromSourceText(jsonIn) {
			this._obj = {};
			this._textures = {};

			var _node = void 0,
			    _sourceText = void 0,
			    _objDirectory = void 0;
			_sourceText = jsonIn.sourceText !== undefined ? jsonIn.sourceText : undefined;
			_objDirectory = jsonIn.objDirectory !== undefined ? jsonIn.objDirectory : undefined;

			var lines = _sourceText.split("\r\n");
			if (lines.length === 1) lines = _sourceText.split("\n");

			if (lines[0].match(/OBJ/gim) == null) {
				alert('Not OBJ file');return;
			}

			var vertexArrayX = [];var vertexArrayY = [];var vertexArrayZ = [];
			var normalArrayX = [];var normalArrayY = [];var normalArrayZ = [];
			var textureArrayX = [];var textureArrayY = [];var textureArrayZ = [];
			var textureUnitArray = [];
			var currentTextureUnit = 0;
			var indexArray = [];
			var currentIDX = 0;
			var currentIDX_INDEX = 0;

			var bufferEnCola = false;

			var vertexX = [];var vertexY = [];var vertexZ = [];
			var normalX = [];var normalY = [];var normalZ = [];
			var textureX = [];var textureY = [];var textureZ = [];
			var currentIDX_vertex = 0;var currentIDX_normal = 0;var currentIDX_texture = 0;
			var indexVNT = [];
			var currentIndex = 0;

			var groups = {};
			var currentGroup = [-1, 0];
			groups["_unnamed"] = currentGroup;

			var mtlFile = "";
			var currentMtlName = "";

			for (var n = 0, f = lines.length; n < f; n++) {
				var line = lines[n].replace(/\t+/gi, " ").replace(/\s+$/gi, "").replace(/\s+/gi, " ");
				if (line[0] === "#") continue; // ignore comments

				var array = line.split(" ");

				if (array[0] === "mtllib") {
					mtlFile = array[1];
				}
				if (array[0] === "g") {
					currentGroup = [indexArray.length, 0];
					groups[array[1]] = currentGroup;
				}
				if (array[0] === "v") {
					vertexX[currentIDX_vertex] = parseFloat(array[1]);
					vertexY[currentIDX_vertex] = parseFloat(array[2]);
					vertexZ[currentIDX_vertex] = parseFloat(array[3]);
					currentIDX_vertex++;
				}
				if (array[0] === "vn") {
					normalX[currentIDX_normal] = parseFloat(array[1]);
					normalY[currentIDX_normal] = parseFloat(array[2]);
					normalZ[currentIDX_normal] = parseFloat(array[3]);
					currentIDX_normal++;
				}
				if (array[0] === "vt") {
					textureX[currentIDX_texture] = parseFloat(array[1]);
					textureY[currentIDX_texture] = parseFloat(array[2]);
					textureZ[currentIDX_texture] = parseFloat(array[3]);
					currentIDX_texture++;
				}
				if (array[0] === "usemtl") {
					currentMtlName = array[1];

					this._textures[currentTextureUnit] = { "fileUrl": _objDirectory + mtlFile,
						"materialName": currentMtlName };

					currentTextureUnit++;
				}
				if (array[0] === "f") {
					if (array.length !== 4) console.log("*** Error: face '" + line + "' not handled");

					// recorremos cada vtx/tex/nor de la linea 'f vtxA/texA/norA vtxB/texB/norB vtxC/texC/norC'
					// puede ser tambien de tipo f vtx vtx vtx
					for (var i = 1, fi = 4; i < fi; ++i) {
						// primero vtxA/texA/norA, luego vtxB/texB/norB y luego vtxC/texC/norC
						bufferEnCola = true;
						var expl = array[i].split("/"); // array[i] = "vtxX/texX/norX"
						if (indexVNT[array[i]] === undefined) {
							//si no existe current "vtxX/texX/norX" en array indexVNT se añade nuevo indice
							var vtx = void 0,
							    nor = void 0,
							    tex = void 0;
							if (expl.length === 1) {
								// si es de tipo solo vtx
								vtx = parseInt(expl[0]) - 1; // usamos vtx en todos
								nor = vtx;
								tex = vtx;
							} else if (expl.length === 3) {
								// si es de tipo vtx/tex/nor
								vtx = parseInt(expl[0]) - 1;
								tex = parseInt(expl[1]) - 1;
								nor = parseInt(expl[2]) - 1;
								// se resta 1 por que en el formato obj el primero comienza en 1.
								// en los arrays donde hemos almacenado vertex, normal y texture el primero comienza en 0.
							} else {
								//obj.ctx.console.log("*** Error: did not understand face '"+array[i]+"'");
								return null;
							}

							textureUnitArray[currentIDX] = currentTextureUnit - 1;

							vertexArrayX[currentIDX] = 0.0;
							vertexArrayY[currentIDX] = 0.0;
							vertexArrayZ[currentIDX] = 0.0;
							if (vtx < vertexZ.length) {
								vertexArrayX[currentIDX] = vertexX[vtx];
								vertexArrayY[currentIDX] = vertexY[vtx];
								vertexArrayZ[currentIDX] = vertexZ[vtx];
							}

							textureArrayX[currentIDX] = 0.0;
							textureArrayY[currentIDX] = 0.0;
							textureArrayZ[currentIDX] = 0.0;
							if (tex < textureZ.length) {
								textureArrayX[currentIDX] = textureX[tex];
								textureArrayY[currentIDX] = textureY[tex];
								textureArrayZ[currentIDX] = textureZ[tex];
							}

							normalArrayX[currentIDX] = 0.0;
							normalArrayY[currentIDX] = 0.0;
							normalArrayZ[currentIDX] = 1.0;
							if (nor < normalZ.length) {
								normalArrayX[currentIDX] = normalX[nor];
								normalArrayY[currentIDX] = normalY[nor];
								normalArrayZ[currentIDX] = normalZ[nor];
							}
							currentIDX++;

							indexVNT[array[i]] = currentIndex; // indexVNT[vtxX/texX/norX] = currentIndex; 
							currentIndex++;
						}
						indexArray[currentIDX_INDEX] = indexVNT[array[i]];
						currentIDX_INDEX++;

						currentGroup[1]++;
					}
				}
			}

			if (bufferEnCola === true) {
				this._obj.vertexArray = new Float32Array(vertexArrayX.length * 4);
				for (var _n = 0, fn = vertexArrayX.length; _n < fn; _n++) {
					var idx = _n * 4;
					this._obj.vertexArray[idx] = vertexArrayX[_n];
					this._obj.vertexArray[idx + 1] = vertexArrayY[_n];
					this._obj.vertexArray[idx + 2] = vertexArrayZ[_n];
					this._obj.vertexArray[idx + 3] = 1.0;
				}
				this._obj.normalArray = new Float32Array(normalArrayX.length * 4);
				for (var _n2 = 0, _fn = normalArrayX.length; _n2 < _fn; _n2++) {
					var _idx = _n2 * 4;
					this._obj.normalArray[_idx] = normalArrayX[_n2];
					this._obj.normalArray[_idx + 1] = normalArrayY[_n2];
					this._obj.normalArray[_idx + 2] = normalArrayZ[_n2];
					this._obj.normalArray[_idx + 3] = 1.0;
				}
				this._obj.textureArray = new Float32Array(textureArrayX.length * 4);
				for (var _n3 = 0, _fn2 = textureArrayX.length; _n3 < _fn2; _n3++) {
					var _idx2 = _n3 * 4;
					this._obj.textureArray[_idx2] = textureArrayX[_n3];
					this._obj.textureArray[_idx2 + 1] = textureArrayY[_n3];
					this._obj.textureArray[_idx2 + 2] = textureArrayZ[_n3];
					this._obj.textureArray[_idx2 + 3] = 1.0;
				}
				this._obj.textureUnitArray = textureUnitArray;
				this._obj.indexArray = indexArray;

				// RESET
				/*let bufferEnCola = false;
    
    vertexArrayX = [];vertexArrayY = [];vertexArrayZ = [];
    normalArrayX = [];normalArrayY = [];normalArrayZ = [];
    textureArrayX = [];textureArrayY = [];textureArrayZ = [];
    textureUnitArray = [];
    //currentTextureUnit = 0;  
    indexArray = [];
    currentIDX = 0;
    currentIDX_INDEX = 0;
     
    //vertexX = [];vertexY = [];vertexZ = [];
    //normalX = [];normalY = [];normalZ = [];
    //textureX = [];textureY = [];textureZ = [];
    //currentIDX_vertex = 0;currentIDX_normal = 0;currentIDX_texture = 0;    
    indexVNT = [];
    currentIndex = 0;*/
			}
		}
	}]);

	return Mesh;
}();

global.Mesh = Mesh;
module.exports.Mesh = Mesh;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Utils.class":3}],3:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Utils = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

require("webclgl");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* @class
*/
var Utils = exports.Utils = function () {
    function Utils() {
        _classCallCheck(this, Utils);

        window.requestAnimFrame = function () {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
        }();
    }

    /**
    * Get HTMLCanvasElement from Uint8Array
    * @param {Uint8Array} uint8arr
    * @param {int} width
    * @param {int} height
     * @returns {HTMLCanvasElement}
    */


    _createClass(Utils, [{
        key: "getImageFromCanvas",

        /**
         * @callback Utils~getImageFromCanvas~onload
         * @param {HTMLImageElement} img
         */
        /**
        * Get HTMLImageElement from canvas
        * @param {HTMLCanvasElement} oldCanvas
        * @param {Utils~getImageFromCanvas~onload} onload
        */
        value: function getImageFromCanvas(oldCanvas, onload) {
            var imagen = document.createElement('img');
            imagen.onload = function () {
                onload(imagen);
            };
            imagen.src = oldCanvas.toDataURL();
        }
    }, {
        key: "pack",


        /**
         * Angle between two vectors viewing from top
         * @returns {number}
         * @param {StormV3} vectorA
         * @param {StormV3} vectorB
          Utils.prototype.angle = function(vA, vB) {
            let vAA = vA.normalize();
            let vBB = vB.normalize();
              let escalarProduct = Math.acos((vAA.e[0]*vBB.e[0])+(vAA.e[1]*vBB.e[1])+(vAA.e[2]*vBB.e[2]));
              let vCC = vAA.cross(vBB);
            //console.log(vCC.e[0]+" "+vCC.e[1]+" "+vCC.e[2]);
              if(vCC.e[1] == 1) {
                escalarProduct = (Math.PI+escalarProduct);
            }
              return escalarProduct;
        };*/

        /**
        * Pack 1float (0.0-1.0) to 4float rgba (0.0-1.0, 0.0-1.0, 0.0-1.0, 0.0-1.0)*
        * @param {number} value
        * @returns {Array<number>}
        *
        */
        value: function pack(value) {
            var bias = [1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0];

            var r = value;
            var g = Utils.fract(r * 255.0);
            var b = Utils.fract(g * 255.0);
            var a = Utils.fract(b * 255.0);
            var colour = [r, g, b, a];

            var dd = [colour[1] * bias[0], colour[2] * bias[1], colour[3] * bias[2], colour[3] * bias[3]];

            return [colour[0] - dd[0], colour[1] - dd[1], colour[2] - dd[2], colour[3] - dd[3]];
        }
    }, {
        key: "unpack",

        /**
        * Unpack 4float rgba (0.0-1.0, 0.0-1.0, 0.0-1.0, 0.0-1.0) to 1float (0.0-1.0)
        * @param {Array<number>} value
         * @returns {number}
        */
        value: function unpack(value) {
            var bitShifts = [1.0, 1.0 / 255.0, 1.0 / (255.0 * 255.0), 1.0 / (255.0 * 255.0 * 255.0)];
            return Utils.dot4(value, bitShifts);
        }
    }], [{
        key: "getCanvasFromUint8Array",
        value: function getCanvasFromUint8Array(uint8arr, width, height) {
            var e = document.createElement('canvas');
            e.width = width;
            e.height = height;
            var ctx2D = e.getContext("2d");
            var image = ctx2D.createImageData(width, height);
            for (var i = 0; i < image.data.length; i++) {
                image.data[i] = uint8arr[i];
            }ctx2D.putImageData(image, 0, 0);

            return e;
        }
    }, {
        key: "getUint8ArrayFromHTMLImageElement",


        /**
        * Get Uint8Array from HTMLImageElement
        * @param {HTMLImageElement} imageElement
         * @returns {Uint8ClampedArray}
        */
        value: function getUint8ArrayFromHTMLImageElement(imageElement) {
            var e = document.createElement('canvas');
            e.width = imageElement.width;
            e.height = imageElement.height;
            var ctx2D_tex = e.getContext("2d");
            ctx2D_tex.drawImage(imageElement, 0, 0);
            var arrayTex = ctx2D_tex.getImageData(0, 0, imageElement.width, imageElement.height);

            return arrayTex.data;
        }
    }, {
        key: "getVector",


        /**
        * Get random vector from vecNormal with deviation in degrees
        * @param {StormV3} vecNormal
        * @param {number} degrees
         * @returns {StormV3}
        */
        value: function getVector(vecNormal, degrees) {
            var ob = Utils.cartesianToSpherical(vecNormal);
            var angleLat = ob.lat;
            var angleLng = ob.lng;

            var desvLat = Math.random() * 180.0 - 90.0;
            var desvLng = Math.random() * 180.0 - 90.0;
            angleLat += degrees * desvLat;
            angleLng += degrees * desvLng;

            return Utils.sphericalToCartesian(1.0, angleLat, angleLng);
        }
    }, {
        key: "getVectorGLSLFunctionString",

        /**
        * Get random vector from vecNormal with deviation in degrees (GLSL)
        * @returns {String}
        */
        value: function getVectorGLSLFunctionString() {
            return 'vec3 getVector(vec3 vecNormal, float degrees, vec2 vecNoise) {\n' + 'vec3 ob = cartesianToSpherical(vecNormal);' + 'float angleLat = ob.y;' + 'float angleLng = ob.z;' + 'float desvLat = (vecNoise.x*180.0)-90.0;' + 'float desvLng = (vecNoise.y*180.0)-90.0;' + 'angleLat += (degrees*desvLat);' + 'angleLng += (degrees*desvLng);' + 'return sphericalToCartesian(vec3(1.0, angleLat, angleLng));' + '}\n';
        }
    }, {
        key: "cartesianToSpherical",


        /**
         * cartesianToSpherical
         * @param {StormV3} vec
         * @returns {Object}
         * @example
         * $V3([1,0,0])  return {radius: 1, lat: 90, lng: 0}
         * $V3([0,0,1])  return {radius: 1, lat: 90, lng: 90}
         * $V3([-1,0,0]) return {radius: 1, lat: 90, lng: 180}
         * $V3([0,0,-1]) return {radius: 1, lat: 90, lng: -90}
         */
        value: function cartesianToSpherical(vec) {
            var r = Math.sqrt(vec.e[0] * vec.e[0] + vec.e[1] * vec.e[1] + vec.e[2] * vec.e[2]);

            var angleLat = Utils.radToDeg(Math.acos(vec.e[1] / r));
            var angleLng = Utils.radToDeg(Math.atan2(vec.e[2], vec.e[0]));

            return { "radius": r,
                "lat": angleLat,
                "lng": angleLng };
        }
    }, {
        key: "cartesianToSphericalGLSLFunctionString",

        /**
         * cartesianToSpherical (GLSL)
        * @returns {String}
        */
        value: function cartesianToSphericalGLSLFunctionString() {
            return 'vec3 cartesianToSpherical(vec3 vect) {\n' + 'float r = sqrt(vect.x*vect.x + vect.y*vect.y + vect.z*vect.z);' + 'float angleLat = radToDeg(acos(vect.y/r));' + 'float angleLng = radToDeg(atan(vect.z, vect.x));' + 'return vec3(r, angleLat, angleLng);' + '}\n';
        }
    }, {
        key: "sphericalToCartesian",


        /**
         * sphericalToCartesian
         * @param {number} radius
         * @param {number} lat Lat in degrees
         * @param {number} lng Lng in degrees
         * @returns {StormV3}
         * @example
         * (1.0, 90.0, 0.0).e) return $V3([1,0,0])
         * (1.0, 90.0, 90.0).e) return $V3([0,0,1])
         * (1.0, 90.0, 180.0).e) return $V3([-1,0,0])
         * (1.0, 90.0, -90.0).e) return $V3([0,0,-1])
         **/
        value: function sphericalToCartesian(radius, lat, lng) {
            var r = radius;
            var angleLat = Utils.degToRad(lat);
            var angleLng = Utils.degToRad(lng);

            var x = r * Math.sin(angleLat) * Math.cos(angleLng);
            var z = r * Math.sin(angleLat) * Math.sin(angleLng);
            var y = r * Math.cos(angleLat);

            return new StormV3([x, y, z]);
        }
    }, {
        key: "sphericalToCartesianGLSLFunctionString",

        /**
         * sphericalToCartesian (GLSL)
        * @returns {String}
        */
        value: function sphericalToCartesianGLSLFunctionString() {
            return 'vec3 sphericalToCartesian(vec3 vect) {\n' + 'float r = vect.x;' + 'float angleLat = degToRad(vect.y);' + 'float angleLng = degToRad(vect.z);' + 'float x = r*sin(angleLat)*cos(angleLng);' + 'float z = r*sin(angleLat)*sin(angleLng);' + 'float y = r*cos(angleLat);' + 'return vec3(x,y,z);' + '}\n';
        }
    }, {
        key: "refract",


        /**
        * Refract
        * @param {StormV3} V
        * @param {StormV3} N
        * @param {number} n1 Refract index way 1
        * @param {number} n2 Refract index way 2
         * @returns {StormV3}
        */
        value: function refract(V, N, n1, n2) {
            var refrIndex = n1 / n2;
            var cosI = N.dot(V) * -1.0;
            var cosT2 = 1.0 - refrIndex * refrIndex * (1.0 - cosI * cosI);
            var vv = V.x(refrIndex);
            return vv.add(N.x(refrIndex * cosI - Math.sqrt(cosT2)));
        }
    }, {
        key: "degToRad",


        /**
        * Degrees to radians. Full circle = 360 degrees.
        * @param {number} degrees
         * @returns {number}
        */
        value: function degToRad(degrees) {
            return degrees * 3.14159 / 180;
        }
    }, {
        key: "degToRadGLSLFunctionString",

        /**
         * Degrees to radians. Full circle = 360 degrees. (GLSL)
        * @returns {String}
        */
        value: function degToRadGLSLFunctionString() {
            return 'float degToRad(float deg) {' + 'return (deg*3.14159)/180.0;' + '}';
        }
    }, {
        key: "radToDeg",


        /**
        * Radians to degrees
        * @param {number} radians
         * @returns {number}
        */
        value: function radToDeg(radians) {
            return radians * (180 / 3.14159);
        }
    }, {
        key: "radToDegGLSLFunctionString",

        /**
         * Radians to degrees (GLSL)
        * @returns {String}
        */
        value: function radToDegGLSLFunctionString() {
            return 'float radToDeg(float rad) {' + 'return rad*(180.0/3.14159);' + '}';
        }
    }, {
        key: "hexToRgb",


        /**
         * hexToRgb
         * @param {String} hex
         * @returns  {Array<number>} rgb values from 0 to 255
         */
        value: function hexToRgb(hex) {
            // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                return r + r + g + g + b + b;
            });

            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
    }, {
        key: "rgbToHex",

        /**
         * rgbToHex
         * @param {Array<number>} rgb values from 0 to 255
         * @returns {String}
         */
        value: function rgbToHex(rgb) {
            var rgbVal = rgb[2] | rgb[1] << 8 | rgb[0] << 16;
            return '#' + (0x1000000 + rgbVal).toString(16).slice(1);
        }
    }, {
        key: "invsqrt",


        /**
        * Inverse sqrt
        * @param {number} value
         * @returns {number}
        */
        value: function invsqrt(value) {
            return 1.0 / value;
        }
    }, {
        key: "smoothstep",


        /**
        * Smoothstep
        * @param {number} edge0
        * @param {number} edge1
        * @param {number} current
         * @returns {number}
        */
        value: function smoothstep(edge0, edge1, current) {
            if (current < edge0) return 0;
            if (current >= edge1) return 1;
            if (edge0 === edge1) return -1;
            var p = (current - edge0) / (edge1 - edge0);

            return p * p * (3 - 2 * p);
        }
    }, {
        key: "dot4",


        /**
        * Dot product vector4float
        * @param {Array<number>} vector4A Vector a
        * @param {Array<number>} vector4B Vector b
         * @returns {number}
        */
        value: function dot4(vector4A, vector4B) {
            return vector4A[0] * vector4B[0] + vector4A[1] * vector4B[1] + vector4A[2] * vector4B[2] + vector4A[3] * vector4B[3];
        }
    }, {
        key: "fract",


        /**
        * Compute the fractional part of the argument. Example: fract(pi)=0.14159265...
        * @param {number} value
         * @returns {number}
        */
        value: function fract(value) {
            return value > 0 ? value - Math.floor(value) : value - Math.ceil(value);
        }
    }, {
        key: "packGLSLFunctionString",

        /**
        * Get pack GLSL function string
        * @returns {String}
        */
        value: function packGLSLFunctionString() {
            return 'vec4 pack (float depth) {' + 'const vec4 bias = vec4( 1.0 / 255.0,' + '1.0 / 255.0,' + '1.0 / 255.0,' + '0.0);' + 'float r = depth;' + 'float g = fract(r * 255.0);' + 'float b = fract(g * 255.0);' + 'float a = fract(b * 255.0);' + 'vec4 colour = vec4(r, g, b, a);' + 'return colour - (colour.yzww * bias);' + '}';
        }
    }, {
        key: "unpackGLSLFunctionString",

        /**
        * Get unpack GLSL function string
        * @returns {String}
        */
        value: function unpackGLSLFunctionString() {
            return 'float unpack (vec4 colour) {' + 'const vec4 bitShifts = vec4(1.0,' + '1.0 / 255.0,' + '1.0 / (255.0 * 255.0),' + '1.0 / (255.0 * 255.0 * 255.0));' + 'return dot(colour, bitShifts);' + '}';
        }
    }, {
        key: "rayTraversalInitSTR",
        value: function rayTraversalInitSTR() {
            return '' + 'float wh = ceil(sqrt(uResolution*uResolution*uResolution));\n' + 'float cs = uGridsize/uResolution;\n' + // cell size
            'float chs = cs/2.0;\n' + // cell size
            'float texelSize = 1.0/(wh-1.0);\n' + // 1.0/(wh-1.0)??

            // Fast Voxel Traversal Algorithm for Ray Tracing. John Amanatides & Andrew Woo.
            // http://www.cse.chalmers.se/edu/course/TDA361/grid.pdf
            // More info:
            // http://www.clockworkcoders.com/oglsl/rt/gpurt3.htm
            'vec3 gl = vec3(-(uGridsize/2.0), -(uGridsize/2.0), -(uGridsize/2.0));\n' + 'vec3 _r = vec3(uGridsize, uGridsize, uGridsize);\n' + 'vec3 _rRes = vec3(uResolution, uResolution, uResolution);\n' + 'vec3 _len = _r/_rRes;\n' + 'vec3 worldToVoxel(vec3 world) {\n' + 'vec3 ijk = (world - gl) / _len;\n' + // (1.0-(-1.0)) / (2/64) = 64
            'ijk = vec3(floor(ijk.x), floor(ijk.y), floor(ijk.z));\n' + 'return ijk;\n' + '}\n' + 'float voxelToWorldX(float x) {return x * _len.x + gl.x;}\n' + // 64*(2/64)+(-1.0) = 1.0
            'float voxelToWorldY(float y) {return y * _len.y + gl.y;}\n' + 'float voxelToWorldZ(float z) {return z * _len.z + gl.z;}\n';
        }
    }, {
        key: "rayTraversalSTR",
        value: function rayTraversalSTR(resolution) {
            return '' + 'vec2 getId(vec3 voxel) {\n' + 'int tex3dId = (int(voxel.y)*(int(uResolution)*int(uResolution)))+(int(voxel.z)*(int(uResolution)))+int(voxel.x);\n' + 'float num = float(tex3dId)/wh;\n' + 'float col = fract(num)*wh;\n' + 'float row = floor(num);\n' + 'return vec2(col*texelSize, row*texelSize);\n' + '}\n' + 'vec4 getVoxel_Color(vec2 texVec, vec3 voxel, vec3 RayOrigin) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelColor[vec2(texVec.x, texVec.y)];\n' + 'if(texture.a/255.0 > 0.5) {\n' + // existen triángulos dentro?
            'rgba = vec4(texture.rgb/255.0,distance(vec3(voxelToWorldX(voxel.x), voxelToWorldX(voxel.y), voxelToWorldX(voxel.z)),RayOrigin));\n' + '}\n' + 'return rgba;\n' + '}\n' + 'vec4 getVoxel_Pos(vec2 texVec) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelPos[vec2(texVec.x, texVec.y)];\n' +
            //distance(vec3(voxelToWorldX(voxel.x), voxelToWorldX(voxel.y), voxelToWorldX(voxel.z)),RayOrigin)
            'rgba = vec4( ((texture.xyz/255.0)*uGridsize)-(uGridsize/2.0), 1.0);\n' + 'return rgba;\n' + '}\n' + 'vec4 getVoxel_Normal(vec2 texVec) {\n' + 'vec4 rgba = vec4(0.0,0.0,0.0,0.0);\n' + 'vec4 texture = sampler_voxelNormal[vec2(texVec.x, texVec.y)];\n' + 'rgba = vec4(((texture.rgb/255.0)*2.0)-1.0, 1.0);\n' + 'return rgba;\n' + '}\n' + 'struct RayTraversalResponse {' + 'vec4 voxelColor;' + 'vec4 voxelPos;' + 'vec4 voxelNormal;' + '};' + 'RayTraversalResponse rayTraversal(vec3 RayOrigin, vec3 RayDir) {\n' + 'vec4 fvoxelColor = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec4 fvoxelPos = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec4 fvoxelNormal = vec4(0.0, 0.0, 0.0, 0.0);' + 'vec3 voxel = worldToVoxel(RayOrigin);' + 'vec3 _dir = normalize(RayDir);' + 'vec3 tMax;' + 'if(RayDir.x < 0.0) tMax.x = (voxelToWorldX(voxel.x)-RayOrigin.x)/RayDir.x;' + 'if(RayDir.x > 0.0) tMax.x = (voxelToWorldX(voxel.x+1.0)-RayOrigin.x)/RayDir.x;' + 'if(RayDir.y < 0.0) tMax.y = (voxelToWorldY(voxel.y)-RayOrigin.y)/RayDir.y;' + 'if(RayDir.y < 0.0) tMax.y = (voxelToWorldY(voxel.y+1.0)-RayOrigin.y)/RayDir.y;' + 'if(RayDir.z < 0.0) tMax.z = (voxelToWorldZ(voxel.z)-RayOrigin.z)/RayDir.z;' + 'if(RayDir.z < 0.0) tMax.z = (voxelToWorldZ(voxel.z+1.0)-RayOrigin.z)/RayDir.z;' + 'float tDeltaX = _r.x/abs(RayDir.x);' + // hasta qué punto se debe avanzar en la dirección del rayo antes de que nos encontramos con un nuevo voxel en la dirección x
            'float tDeltaY = _r.y/abs(RayDir.y);' + 'float tDeltaZ = _r.z/abs(RayDir.z);' + 'float stepX = 1.0; float stepY = 1.0; float stepZ = 1.0;\n' + 'float outX = _r.x; float outY = _r.y; float outZ = _r.z;\n' + 'if(RayDir.x < 0.0) {stepX = -1.0; outX = -1.0;}' + 'if(RayDir.y < 0.0) {stepY = -1.0; outY = -1.0;}' + 'if(RayDir.z < 0.0) {stepZ = -1.0; outZ = -1.0;}' + 'vec4 color = vec4(0.0,0.0,0.0,0.0);\n' + 'bool c1; bool c2; bool c3; bool isOut;' + 'vec2 vid;' + 'for(int c = 0; c < ' + resolution + '*2; c++) {\n' + 'c1 = bool(tMax.x < tMax.y);' + 'c2 = bool(tMax.x < tMax.z);' + 'c3 = bool(tMax.y < tMax.z);' + 'isOut = false;' + 'if (c1 && c2) {' + 'voxel.x += stepX;' + 'if(voxel.x==outX) isOut=true;' + 'tMax.x += tDeltaX;' + '} else if(( (c1 && !c2) || (!c1 && !c3) )) {' + 'voxel.z += stepZ;' + 'if(voxel.z==outZ) isOut=true;' + 'tMax.z += tDeltaZ;' + '} else if(!c1 && c3) {' + 'voxel.y += stepY;' + 'if(voxel.y==outY) isOut=true;' + 'tMax.y += tDeltaY;' + '}' + 'if(isOut == true) break;\n' + 'else {' + 'if((voxel.x >= 0.0 && voxel.x <= _rRes.x && voxel.y >= 0.0 && voxel.y <= _rRes.y && voxel.z >= 0.0 && voxel.z <= _rRes.z)) {;\n' + 'vid = getId(voxel);' + 'vec4 vcc = getVoxel_Color(vid, voxel, RayOrigin);' + 'if(vcc.a != 0.0) {' + 'fvoxelColor = vcc;' + 'break;\n' + '}' + '}' + '}' + '}' + 'fvoxelPos = getVoxel_Pos(vid);' + 'fvoxelNormal = getVoxel_Normal(vid);' + 'return RayTraversalResponse(fvoxelColor, fvoxelPos, fvoxelNormal);' + '}\n';
        }
    }, {
        key: "isPowerOfTwo",
        value: function isPowerOfTwo(x) {
            return (x & x - 1) === 0;
        }
    }, {
        key: "nextHighestPowerOfTwo",
        value: function nextHighestPowerOfTwo(x) {
            --x;
            for (var i = 1; i < 32; i <<= 1) {
                x = x | x >> i;
            }
            return x + 1;
        }
    }, {
        key: "getElementPosition",
        value: function getElementPosition(element) {
            var elem = element,
                tagname = "",
                x = 0,
                y = 0;

            while ((typeof elem === "undefined" ? "undefined" : _typeof(elem)) === "object" && typeof elem.tagName !== "undefined") {
                y += elem.offsetTop;
                x += elem.offsetLeft;
                tagname = elem.tagName.toUpperCase();

                if (tagname === "BODY") elem = 0;

                if ((typeof elem === "undefined" ? "undefined" : _typeof(elem)) === "object") {
                    if (_typeof(elem.offsetParent) === "object") elem = elem.offsetParent;
                }
            }

            return { x: x, y: y };
        }
    }, {
        key: "getWebGLContextFromCanvas",
        value: function getWebGLContextFromCanvas(canvas, ctxOpt) {
            return WebCLGLUtils.getWebGLContextFromCanvas(canvas, ctxOpt);
        }
    }, {
        key: "fullScreen",
        value: function fullScreen() {
            if (!document.fullscreenElement && // alternative standard method
            !document.mozFullScreenElement && !document.webkitFullscreenElement) {
                // current working methods
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) {
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                }
            } else {
                if (document.cancelFullScreen) {
                    document.cancelFullScreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen();
                }
            }
        }
    }]);

    return Utils;
}();

global.Utils = Utils;
module.exports.Utils = Utils;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"webclgl":1}]},{},[2]);
