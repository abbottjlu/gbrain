import {Utils} from "../../Utils.class";
import {Constants} from "../../Constants";

/**
* @class
*/
export class Voxelizator {
    constructor(sce) {
        this._sce = sce;
        this._project = this._sce.getLoadedProject();
        this._gl = this._project.getActiveStage().getWebGLContext();
        this._utils = new Utils();



        this._makeVoxels = false;
        this._mesh = null;
        this._size = null;
        this._resolution = null;
        this._cs = null;
        this._chs = null;
        this._wh = null;
        this._arr_VoxelsColor = null;
        this._arr_VoxelsPosition = null;
        this._arr_VoxelsNormal = null;
        this._typeFillMode = null;
        this._currentHeight = null;
        this._currentOffset = null;

        this._nativePosTarget = null;
        this._nativePosGoal = null;
        this._nativeTargetDistance = null;
        this._nativeDimensions = null;
        this._ongeneratefunction = null;

        this._image3D_VoxelsColor = null;
        this._image3D_VoxelsPosition = null;
        this._image3D_VoxelsNormal = null;

        this.nodes = new Node();
        this.nodes.setName("voxelizator");
        this._project.getActiveStage().addNode(this.nodes);

        // ComponentTransform
        let comp_transform = new ComponentTransform();
        this.nodes.addComponent(comp_transform);

        // Component_GPU
        this.comp_renderer_node = new Component_GPU();
        this.nodes.addComponent(this.comp_renderer_node);


        this.comp_renderer_node.setGPUFor(this.comp_renderer_node.gl,
                                    {// VFP_RGB
                                    "float4*attr vertexPos": (function(){return null;}).bind(this),
                                    "float4*attr vertexNormal": (function(){return null;}).bind(this),
                                    "float4*attr vertexTexture": (function(){return null;}).bind(this),
                                    "float*attr vertexTextureUnit": (function(){return null;}).bind(this),
                                    "indices": (function(){return null;}).bind(this),
                                    "mat4 PMatrix": (function(){return null;}).bind(this),
                                    "mat4 cameraWMatrix": (function(){return null;}).bind(this),
                                    "mat4 nodeWMatrix": (function(){return null;}).bind(this),

                                    'float uGridsize': (function(){return null;}).bind(this),
                                    'float uResolution': (function(){return null;}).bind(this),
                                    'float uCurrentOffset': (function(){return null;}).bind(this),
                                    'float uCurrentHeight': (function(){return null;}).bind(this),
                                    'float uTypeFillMode': (function(){return null;}).bind(this),


                                    'float4* texAlbedo': (function(){return null;}).bind(this)},
                                    {"type": "GRAPHIC",
                                    "name": "VOXELIZATOR",
                                    "viewSource": false,
                                    "config": [ undefined,
                                        // vertex head
                                        'varying vec4 vVPos;\n'+
                                         'varying vec4 vVN;\n'+
                                        'varying vec4 vVT;\n'+
                                        'varying float vVTU;\n'+
                                        'mat4 lookAt(vec3 eye, vec3 center, vec3 up) {'+
                                             'vec3 zaxis = normalize(center - eye);'+
                                             'vec3 xaxis = normalize(cross(up, zaxis));'+
                                             'vec3 yaxis = cross(zaxis, xaxis);'+

                                             'mat4 matrix;'+
                                             //Column Major
                                             'matrix[0][0] = xaxis.x;'+
                                             'matrix[1][0] = yaxis.x;'+
                                             'matrix[2][0] = zaxis.x;'+
                                             'matrix[3][0] = 0.0;'+

                                             'matrix[0][1] = xaxis.y;'+
                                             'matrix[1][1] = yaxis.y;'+
                                             'matrix[2][1] = zaxis.y;'+
                                             'matrix[3][1] = 0.0;'+

                                             'matrix[0][2] = xaxis.z;'+
                                             'matrix[1][2] = yaxis.z;'+
                                             'matrix[2][2] = zaxis.z;'+
                                             'matrix[3][2] = 0.0;'+

                                             'matrix[0][3] = -dot(xaxis, eye);'+
                                             'matrix[1][3] = -dot(yaxis, eye);'+
                                             'matrix[2][3] = -dot(zaxis, eye);'+
                                             'matrix[3][3] = 1.0;'+

                                             'return matrix;'+
                                         '}'+
                                        'mat4 transpose(mat4 m) {'+
                                            'return mat4(  m[0][0], m[1][0], m[2][0], m[3][0],'+
                                            'm[0][1], m[1][1], m[2][1], m[3][1],'+
                                            'm[0][2], m[1][2], m[2][2], m[3][2],'+
                                            'm[0][3], m[1][3], m[2][3], m[3][3]);'+
                                        '}',


                                        // vertex source
                                        'float gridSize = uGridsize;'+
                                        'int maxLevelCells = int(uResolution);'+
                                        'float cs = gridSize/float(maxLevelCells);\n'+ // cell size


                                        'mat4 mCam = transpose(lookAt( 	vec3(0.0, (-(gridSize/2.0)+(uCurrentHeight*cs)), 0.0),'+
                                                                        'vec3(0.0, (-(gridSize/2.0)+(uCurrentHeight*cs))-1.0, 0.001),'+
                                                                        'vec3(0.0, 1.0, 0.0)));'+


                                        'vec3 vp = vertexPos[].xyz;\n'+
                                        'vp = vp*vec3(1.0, 1.0, 1.0);'+

                                        'vec4 vPosition = PMatrix*mCam*nodeWMatrix*vec4(vp,1.0);'+
                                        'float lengthOffs = 0.005*gridSize*vPosition.z;'+

                                        'int currOffs = int(uCurrentOffset);'+
                                        'if(currOffs == 0) vp = vp+vec3(lengthOffs,	0.0,	lengthOffs);'+
                                        'if(currOffs == 1) vp = vp+vec3(-lengthOffs,	0.0,	-lengthOffs);'+
                                        'if(currOffs == 2) vp = vp+vec3(-lengthOffs,	0.0,	lengthOffs);'+
                                        'if(currOffs == 3) vp = vp+vec3(lengthOffs,	0.0,	-lengthOffs);'+
                                        'if(currOffs == 4) vp = vp+vec3(0.0,		0.0,	lengthOffs);'+
                                        'if(currOffs == 5) vp = vp+vec3(0.0,		0.0,	-lengthOffs);'+
                                        'if(currOffs == 6) vp = vp+vec3(lengthOffs,	0.0,	0.0);'+
                                        'if(currOffs == 7) vp = vp+vec3(-lengthOffs,	0.0,	0.0);'+

                                        'gl_Position = PMatrix * mCam * nodeWMatrix * vec4(vp, 1.0);\n'+

                                        'vVPos = vec4(vertexPos[].xyz*vec3(1.0, 1.0, 1.0), 1.0);'+
                                        'vVN = vertexNormal[]*vec4(1.0, 1.0, 1.0, 1.0);\n'+
                                        'vVT = vertexTexture[];\n'+
                                        'vVTU = vertexTextureUnit[];\n',

                                        // fragment head
                                        'varying vec4 vVPos;\n'+
                                         'varying vec4 vVN;\n'+
                                         'varying vec4 vVT;\n'+
                                         'varying float vVTU;\n'+
                                        Utils.packGLSLFunctionString(),

                                        // fragment source
                                        'int fillMode = int(uTypeFillMode);'+

                                        'vec4 fColor;'+
                                        'if(fillMode == 0) {'+ // fill with albedo
                                            'fColor = texAlbedo[vVT.xy];\n'+
                                        '} else if(fillMode == 1) {'+ // fill with position
                                            'float gridSize = uGridsize;'+
                                            'int maxLevelCells = int(uResolution);'+
                                            'float cs = gridSize/float(maxLevelCells);\n'+ // cell size
                                            'float chs = cs/2.0;\n'+


                                            'vec3 p = (vVPos.xyz+(gridSize/2.0))/gridSize;'+

                                            'fColor = vec4(p, 1.0);\n'+
                                        '} else if(fillMode == 2) {'+ // fill with normal
                                            'fColor = vec4((vVN.r+1.0)/2.0,(vVN.g+1.0)/2.0,(vVN.b+1.0)/2.0, 1.0);\n'+
                                        '}'+

                                        'return fColor;'
                                    ],
                                    "drawMode": 4,
                                    "depthTest": true,
                                    "blend": true,
                                    "blendEquation": Constants.BLENDING_EQUATION_TYPES.FUNC_ADD,
                                    "blendSrcMode": Constants.BLENDING_MODES.SRC_ALPHA,
                                    "blendDstMode": Constants.BLENDING_MODES.ONE_MINUS_SRC_ALPHA});
        this.comp_renderer_node.gpufG.onPreProcessGraphic(0, (function() {
            let comp_screenEffects = this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.GPU);
            //comp_screenEffects.gl.blendFunc(this.comp_renderer_node.gl[Constants.BLENDING_MODES.ONE_MINUS_SRC_COLOR], this.comp_renderer_node.gl[Constants.BLENDING_MODES.SRC_COLOR]);

            if(this._makeVoxels === true) {
                this.comp_renderer_node.setArg("uCurrentHeight", (function(){return this._currentHeight;}).bind(this));

                let fm;
                if(this._typeFillMode[0] === "albedo") fm = 0;
                else if(this._typeFillMode[0] === "position") fm = 1;
                else if(this._typeFillMode[0] === "normal") fm = 2;
                this.comp_renderer_node.setArg("uTypeFillMode", (function(){return fm;}).bind(this));

                // CAMERA CURRENT HEIGHT POSITION
                let p = $V3([0.0,0.0,0.0]);
                let pc = p.add($V3([0.0,-1.0,0.0]));
                let comp_cam_tf_target = this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.TRANSFORM_TARGET);
                comp_cam_tf_target.setPositionTarget(p);
                comp_cam_tf_target.setPositionGoal(pc);
                comp_cam_tf_target.pitch(180);
                comp_cam_tf_target.yaw(-90);
                comp_cam_tf_target.setTargetDistance(0.00001);

                this.comp_renderer_node.setArg("uCurrentOffset", (function(){return this._currentOffset;}).bind(this));
                if(this._currentOffset === 0) {
                    //this._gl.clearColor(0.0,0.0,0.0,0.0);
                    //this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
                }
            }
        }).bind(this));
        this.comp_renderer_node.gpufG.onPostProcessGraphic(0, (function() {
            if(this._makeVoxels === true) {
                let setadd = (function(arrOrig, addarr, id) {
                    let idOrig = id/4;
                    for(let n=0; n < addarr.length/4; n++) {
                        let iddOrig = idOrig*4;
                        let iddAdd = n*4;

                        if(arrOrig[iddOrig+3] === 0) {
                            arrOrig[iddOrig] = addarr[iddAdd];
                            arrOrig[iddOrig+1] = addarr[iddAdd+1];
                            arrOrig[iddOrig+2] = addarr[iddAdd+2];
                            arrOrig[iddOrig+3] = addarr[iddAdd+3];
                        } else {
                            arrOrig[iddOrig] = arrOrig[iddOrig];
                            arrOrig[iddOrig+1] = arrOrig[iddOrig+1];
                            arrOrig[iddOrig+2] = arrOrig[iddOrig+2];
                            arrOrig[iddOrig+3] = arrOrig[iddOrig+3];
                        }

                        idOrig++;
                    }
                    return arrOrig;
                }).bind(this);


                let heightImageResult = new Uint8Array(this._resolution*this._resolution*4);
                this._gl.readPixels(0, 0, this._resolution, this._resolution, this._gl.RGBA, this._gl.UNSIGNED_BYTE, heightImageResult);

                let idx3d = (this._currentHeight*(this._resolution*this._resolution))*4;
                let num = idx3d/this._wh;
                let col = Utils.fract(num)*this._wh;
                let row = Math.floor(num);
                if(this._typeFillMode[0] === "albedo")
                    this._arr_VoxelsColor = setadd(this._arr_VoxelsColor, heightImageResult, idx3d);
                else if(this._typeFillMode[0] === "position")
                    this._arr_VoxelsPosition = setadd(this._arr_VoxelsPosition, heightImageResult, idx3d);
                else if(this._typeFillMode[0] === "normal")
                    this._arr_VoxelsNormal = setadd(this._arr_VoxelsNormal, heightImageResult, idx3d);

                if(this._currentOffset === 7) {
                    this._currentHeight++;
                    this._currentOffset = 0;
                } else {
                    this._currentOffset++;
                }

                if(this._currentHeight === this._resolution) {
                    this._currentHeight = 0;

                    if(this._typeFillMode[0] === "albedo")
                        this.setVoxels({'fillMode': 'albedo', 'arr3d':this._arr_VoxelsColor, 'wh':this._wh});
                    else if(this._typeFillMode[0] === "position")
                        this.setVoxels({'fillMode': 'position', 'arr3d':this._arr_VoxelsPosition, 'wh':this._wh});
                    else if(this._typeFillMode[0] === "normal")
                        this.setVoxels({'fillMode': 'normal', 'arr3d':this._arr_VoxelsNormal, 'wh':this._wh});

                    this._typeFillMode.shift();

                    if(this._typeFillMode.length === 0) {
                        this._makeVoxels = false;
                        this.comp_renderer_node.gpufG.disableGraphic(0);

                        let comp_projection = this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.PROJECTION);
                        comp_projection.setNear(-1000.0);
                        comp_projection.setFar(1000.0);
                        comp_projection.setProjection(Constants.PROJECTION_TYPES.PERSPECTIVE);

                        this._sce.setDimensions(this._nativeDimensions.width, this._nativeDimensions.height);

                        let comp_cam_tf_target = this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.TRANSFORM_TARGET);
                        comp_cam_tf_target.setPositionTarget(this._nativePosTarget);
                        comp_cam_tf_target.setPositionGoal(this._nativePosGoal);
                        comp_cam_tf_target.setTargetDistance(this._nativeTargetDistance);


                    }
                }
            }
        }).bind(this));
        this.comp_renderer_node.gpufG.disableGraphic(0);
    }

	setVoxels(jsonIn) {
		if(jsonIn.fillMode === "albedo") {
			let canvas = (jsonIn.arr3d instanceof Uint8Array) ? Utils.getCanvasFromUint8Array(jsonIn.arr3d,jsonIn.wh,jsonIn.wh) : Utils.getCanvasFromUint8Array(Utils.getUint8ArrayFromHTMLImageElement(jsonIn.arr3d),jsonIn.wh,jsonIn.wh);
            this._utils.getImageFromCanvas(canvas, (function(img) {
                this._image3D_VoxelsColor = img;
			}).bind(this));
		} else if(jsonIn.fillMode === "position") {
			let canvas = (jsonIn.arr3d instanceof Uint8Array) ? Utils.getCanvasFromUint8Array(jsonIn.arr3d,jsonIn.wh,jsonIn.wh) : Utils.getCanvasFromUint8Array(Utils.getUint8ArrayFromHTMLImageElement(jsonIn.arr3d),jsonIn.wh,jsonIn.wh);
            this._utils.getImageFromCanvas(canvas, (function(img) {
                this._image3D_VoxelsPosition = img;
			}).bind(this));
		} else if(jsonIn.fillMode === "normal") {
			let canvas = (jsonIn.arr3d instanceof Uint8Array) ? Utils.getCanvasFromUint8Array(jsonIn.arr3d,jsonIn.wh,jsonIn.wh) : Utils.getCanvasFromUint8Array(Utils.getUint8ArrayFromHTMLImageElement(jsonIn.arr3d),jsonIn.wh,jsonIn.wh);
            this._utils.getImageFromCanvas(canvas, (function(img) {
                this._image3D_VoxelsNormal = img;
				if(this._ongeneratefunction !== undefined)
                    this._ongeneratefunction();
			}).bind(this));
		}
	};
	
	
	
	/**
	* setMesh
	* @param {Mesh} mesh
	*/
	setMesh(mesh) {
        this._mesh = mesh;

        this.comp_renderer_node.setArg("vertexPos", (function(){return this._mesh.vertexArray;}).bind(this));
        this.comp_renderer_node.setArg("vertexNormal", (function(){return this._mesh.normalArray;}).bind(this));
        this.comp_renderer_node.setArg("vertexTexture", (function(){return this._mesh.textureArray;}).bind(this));
        this.comp_renderer_node.setArg("vertexTextureUnit", (function(){return this._mesh.textureUnitArray;}).bind(this));

        this.comp_renderer_node.setArg("indices", (function(){return this._mesh.indexArray;}).bind(this));

        this.comp_renderer_node.setArg("PMatrix", (function(){return this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.PROJECTION).getMatrix().transpose().e;}).bind(this));
        this.comp_renderer_node.setArgUpdatable("PMatrix", true);
        this.comp_renderer_node.setArg("cameraWMatrix", (function(){return this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.TRANSFORM_TARGET).getMatrix().transpose().e;}).bind(this));
        this.comp_renderer_node.setArgUpdatable("cameraWMatrix", true);
        this.comp_renderer_node.setArg("nodeWMatrix", (function(){return this.nodes.getComponent(Constants.COMPONENT_TYPES.TRANSFORM).getMatrixPosition().transpose().e;}).bind(this));
        this.comp_renderer_node.setArgUpdatable("nodeWMatrix", true);

        this.comp_renderer_node.setArg("texAlbedo", (function(){return this._mesh.vertexArray;}).bind(this));
	};
	
	/**
	* setImage
	* @param {String} url
	*/
	setImage(url) {
		let image = new Image();
		image.onload = () => {
            this.comp_renderer_node.setArg("texAlbedo", () => {return image;});
		};
		image.src = url;
	};
	
	/**
	* Generate the voxelizator
	* @param	{Object} jsonIn
	* @param {number} [jsonIn.size=2.1] Grid size.
	* @param {int} [jsonIn.resolution=32] Grid resolution.
	* @param {Array<String>} [jsonIn.fillmode=["albedo"]] Modes of data fill. "albedo"|"position"|"normal"
	* @param {Function} [jsonIn.ongenerate] On generate event.
	*/
	generate(jsonIn) {
        this._ongeneratefunction = jsonIn.ongenerate;

        this._size = (jsonIn.size !== undefined) ? jsonIn.size: 2.1;
        this._resolution = (jsonIn.resolution !== undefined) ? jsonIn.resolution: 32;
        this._cs = this._size/this._resolution;
        this._chs = this._cs/2.0;
        this._wh = Math.ceil(Math.sqrt(this._resolution*this._resolution*this._resolution));

        this._typeFillMode = (jsonIn.fillmode === undefined) ? ["albedo"] : jsonIn.fillmode;
        this._currentHeight = 0;
        this._currentOffset = 0;
		
		let comp_projection = this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.PROJECTION);
		comp_projection.setProjection(Constants.PROJECTION_TYPES.ORTHO); 
		comp_projection.setFov(this._size/2);
		comp_projection.setNear(-this._chs);
		comp_projection.setFar(this._cs);

        this.comp_renderer_node.setArg("uGridsize", (function(){return this._size;}).bind(this));
        this.comp_renderer_node.setArg("uResolution", (function(){return this._resolution;}).bind(this));


        this._arr_VoxelsColor = new Uint8Array(this._wh*this._wh*4);
        this._arr_VoxelsPosition = new Uint8Array(this._wh*this._wh*4);
        this._arr_VoxelsNormal = new Uint8Array(this._wh*this._wh*4);
		
		let comp_cam_tf_target = this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.TRANSFORM_TARGET);
        this._nativePosTarget = comp_cam_tf_target.getPositionTarget();
        this._nativePosGoal = comp_cam_tf_target.getPositionGoal();
        this._nativeTargetDistance = comp_cam_tf_target.getTargetDistance();
        this._nativeDimensions = this._sce.getDimensions();

        this._sce.setDimensions(this._resolution, this._resolution);

        this._makeVoxels = true;
        this.comp_renderer_node.gpufG.enableGraphic(0);
	};
	
	/**
	 * @typedef {Object} Voxelizator~getGeneratedArrays
	 * @property {Array<Uint8Array>} Voxelizator~getGeneratedArrays.albedo
	 * @property {Array<Uint8Array>} Voxelizator~getGeneratedArrays.position
	 * @property {Array<Uint8Array>} Voxelizator~getGeneratedArrays.normal
	 */
	/**
	 * @returns {Voxelizator~getGeneratedArrays}
	 */
	getGeneratedArrays() {
		return {	"albedo": this._arr_VoxelsColor,
					"position": this._arr_VoxelsPosition,
					"normal": this._arr_VoxelsNormal};
	};
	
	/**
	 * @typedef {Object} Voxelizator~getGeneratedImages
	 * @property {HTMLImageElement} Voxelizator~getGeneratedImages.albedo
	 * @property {HTMLImageElement} Voxelizator~getGeneratedImages.position
	 * @property {HTMLImageElement} Voxelizator~getGeneratedImages.normal
	 */
	/**
	 * @returns {Voxelizator~getGeneratedImages}
	 */
	getGeneratedImages() {
		return {	"albedo": this._image3D_VoxelsColor,
					"position": this._image3D_VoxelsPosition,
					"normal": this._image3D_VoxelsNormal};
	};

	disable() {
        this.comp_renderer_node.gpufG.disableGraphic(0);
    };

}
global.Voxelizator = Voxelizator;
module.exports.Voxelizator = Voxelizator;