import {Utils} from "../../Utils.class";
import {ComponentTransform} from "../../ComponentTransform.class";
import {Component_GPU} from "../../Component_GPU.class";
import {Mesh} from "../../Mesh.class";
import {Constants} from "../../Constants";
/**
* @class
*/
export class Grid {
    constructor(sce) {
        this._sce = sce;
        this._project = this._sce.getLoadedProject();
        this._gl = this._project.getActiveStage().getWebGLContext();
        this._utils = new Utils();

        this.node = new Node();
        this.node.setName("grid");
        this._project.getActiveStage().addNode(this.node);

        this.mesh = new Mesh().loadBox();

        // ComponentTransform
        this.comp_transform = new ComponentTransform();
        this.node.addComponent(this.comp_transform);

        // Component_GPU
        this.comp_renderer = new Component_GPU();
        this.node.addComponent(this.comp_renderer);

        this.gridColor = $V3([0.3,0.3,0.3]);
    }

	/**
	* Show the grid
     * @param {number} gridsize
	* @param {number} [separation=1.0] separation of the grid
	*/
	generate(gridsize, separation) {
		this.gridEnabled = true;
		
		this.size = (gridsize !== undefined && gridsize !== null) ? gridsize : this.size;
		this.separation = (separation !== undefined && separation !== null) ? separation : this.separation;
		
		this.countLines = (this.size/this.separation)+1;
		this.countLines *= 2;
		
		let startX = -(this.size/2);
		let endX = (this.size/2);
		
		let startZ = -(this.size/2);
		let endZ = (this.size/2);
		
		let currentX = startX;
		let currentZ = startZ;
		
		
		// generate lines for the grid
		let linesVertexArray = [];
		let linesVertexLocArray = [];
		let linesIndexArray = [];
		this.id = 0;
		for(let n = 0, f = this.countLines; n < f; n++) {
			
			
			if(currentZ <= endZ) {
				// generate lines in Z
				linesVertexArray.push(	startX, 0.0, currentZ, 1.0,
										endX, 0.0, currentZ, 1.0);	
				
				currentZ += this.separation;
			} else {
				// generate lines in X
				linesVertexArray.push(	currentX, 0.0, startZ, 1.0,
										currentX, 0.0, endZ, 1.0);
					
				currentX += this.separation;
			}
			
			linesVertexLocArray.push(this.gridColor.e[0], this.gridColor.e[1], this.gridColor.e[2], 1.0,
									this.gridColor.e[0], this.gridColor.e[1], this.gridColor.e[2], 1.0);
			linesIndexArray.push(this.id, this.id+1);
			
			this.id += 2;
		}
		
		// generate lines for axis
		// X
		linesVertexArray.push(	0.0, 0.0, 0.0, 1.0,
								10.0, 0.0, 0.0, 1.0);
		linesVertexLocArray.push(1.0, 0.0, 0.0, 1.0,
								1.0, 0.0, 0.0, 1.0);
		linesIndexArray.push(this.id, this.id+1);
		this.id += 2;
		
		// Y
		linesVertexArray.push(	0.0, 0.0, 0.0, 1.0,
								0.0, 10.0, 0.0, 1.0);
		linesVertexLocArray.push(0.0, 1.0, 0.0, 1.0,
								0.0, 1.0, 0.0, 1.0);
		linesIndexArray.push(this.id, this.id+1);
		this.id += 2;
		
		// Z
		linesVertexArray.push(	0.0, 0.0, 0.0, 1.0,
								0.0, 0.0, 10.0, 1.0);
		linesVertexLocArray.push(0.0, 0.0, 1.0, 1.0,
								0.0, 0.0, 1.0, 1.0);
		linesIndexArray.push(this.id, this.id+1);



        this.comp_renderer.setGPUFor( this.comp_renderer.gl,
                                {   "float4*attr vertexPos": (function(){return linesVertexArray;}).bind(this),
                                    "float4*attr vertexColor": (function(){return linesVertexLocArray;}).bind(this),
                                    "indices": (function(){return linesIndexArray;}).bind(this),

                                    "mat4 PMatrix": (function(){return this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.PROJECTION).getMatrix().transpose().e;}).bind(this),
                                    "mat4 cameraWMatrix": (function(){return this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.TRANSFORM_TARGET).getMatrix().transpose().e;}).bind(this),
                                    "mat4 nodeWMatrix": (function(){return this.node.getComponent(Constants.COMPONENT_TYPES.TRANSFORM).getMatrixPosition().transpose().e;}).bind(this)
                                },

                                // GRAPHIC PROGRAM
                                {"type": "GRAPHIC",
                                "config": [["RGB"],
                                    // vertex head
                                    'varying vec4 vVC;\n',

                                    // vertex source
                                    'vec4 vp = vertexPos[];\n'+
                                    'vec4 vc = vertexColor[];\n'+

                                    'vVC = vc;'+

                                    'gl_Position = PMatrix * cameraWMatrix * nodeWMatrix * vp;\n',

                                    // fragment head
                                    'varying vec4 vVC;\n',

                                    // fragment source
                                    'return [vVC];\n'
                                ],
                                "drawMode": 1,
                                "depthTest": true,
                                "blend": true,
                                "blendEquation": Constants.BLENDING_EQUATION_TYPES.FUNC_ADD,
                                "blendSrcMode": Constants.BLENDING_MODES.SRC_ALPHA,
                                "blendDstMode": Constants.BLENDING_MODES.ONE_MINUS_SRC_ALPHA});
        this.comp_renderer.setArgUpdatable("PMatrix", true);
        this.comp_renderer.setArgUpdatable("cameraWMatrix", true);
        this.comp_renderer.setArgUpdatable("nodeWMatrix", true);
        this.comp_renderer.getComponentBufferArg("RGB", this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.GPU));
	};
}
global.Grid = Grid;
module.exports.Grid = Grid;