import {Utils} from "../../Utils.class";
import {Constants} from "../../Constants";

/**
* @class
*/
export class GI {
    constructor(sce) {
        this._sce = sce;
        this._project = this._sce.getLoadedProject();
        this._gl = this._project.getActiveStage().getWebGLContext();
        this._utils = new Utils();


        this.nodes = new Node();
        this.nodes.setName("GI");
        this._project.getActiveStage().addNode(this.nodes);

        // ComponentTransform
        let comp_transform = new ComponentTransform();
        this.nodes.addComponent(comp_transform);

        // Component_GPU
        this.comp_renderer_node = new Component_GPU();
        this.nodes.addComponent(this.comp_renderer_node);


        this._runGI = false;
    }
		
	/**
	* setResolution
	* @param {number} resolution
	*/
	setResolution(resolution) {
        this.comp_renderer_node.setGPUFor(this.comp_renderer_node.gl,
                                    {// VFP_RGB
                                    "float4*attr vertexPos": (function(){return null;}).bind(this),
                                    "float4*attr vertexNormal": (function(){return null;}).bind(this),
                                    "float4*attr vertexTexture": (function(){return null;}).bind(this),
                                    "float*attr vertexTextureUnit": (function(){return null;}).bind(this),
                                    "indices": (function(){return null;}).bind(this),
                                    "mat4 PMatrix": (function(){return null;}).bind(this),
                                    "mat4 cameraWMatrix": (function(){return null;}).bind(this),
                                    "mat4 nodeWMatrix": (function(){return null;}).bind(this),
                                    'float nodesSize': (function(){return null;}).bind(this),
                                    'float4* texAlbedo': (function(){return null;}).bind(this),

                                    // VFP_GI
                                    'float4* sampler_voxelColor': (function(){return null;}).bind(this),
                                    'float4* sampler_voxelPos': (function(){return null;}).bind(this),
                                    'float4* sampler_voxelNormal': (function(){return null;}).bind(this),

                                    'float4* sampler_screenColor': (function(){return null;}).bind(this),
                                    'float4* sampler_screenPos': (function(){return null;}).bind(this),
                                    'float4* sampler_screenNormal': (function(){return null;}).bind(this),

                                    'float4* sampler_GIVoxel': (function(){return null;}).bind(this),

                                    'float randX1': (function(){return null;}).bind(this),
                                    'float randY1': (function(){return null;}).bind(this),
                                    'float uTypePass': (function(){return null;}).bind(this),

                                    'float uGridsize': (function(){return null;}).bind(this),
                                    'float uResolution': (function(){return null;}).bind(this)},
                                    {"type": "GRAPHIC",
                                    "name": "GI_VFP_RGB",
                                    "viewSource": false,
                                    "config": new VFP_RGB(1).getSrc(),
                                    "drawMode": 4,
                                    "depthTest": true,
                                    "blend": true,
                                    "blendEquation": Constants.BLENDING_EQUATION_TYPES.FUNC_ADD,
                                    "blendSrcMode": Constants.BLENDING_MODES.SRC_ALPHA,
                                    "blendDstMode": Constants.BLENDING_MODES.ONE_MINUS_SRC_ALPHA},
                                    {"type": "GRAPHIC",
                                    "name": "GI_CALC",
                                    "viewSource": false,
                                    "config": [["sampler_screenColor","sampler_screenPos","sampler_screenNormal","sampler_GIVoxel"],
                                        // vertex head
                                        'varying vec4 vposition;\n'+
                                        'varying vec4 vnormal;\n'+
                                        'varying vec4 vposScreen;\n'+
                                        'const mat4 ScaleMatrix = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);',

                                        // vertex source
                                        'vec3 vp = vec3(vertexPos[].x, vertexPos[].y, vertexPos[].z);\n'+
                                        'vposition = nodeWMatrix * vec4(vp*vec3(1.0,1.0,1.0), 1.0);\n'+
                                        'vnormal = vec4(vertexNormal[].xyz*vec3(1.0,1.0,1.0), 1.0);\n'+

                                        'vec4 pos = PMatrix * cameraWMatrix * nodeWMatrix * vec4(vp, 1.0);'+
                                        'vposScreen = ScaleMatrix * pos;\n'+

                                        'gl_Position = pos;\n',


                                        // fragment head
                                        'varying vec4 vposition;\n'+
                                        'varying vec4 vnormal;\n'+
                                        'varying vec4 vposScreen;\n'+

                                        Utils.degToRadGLSLFunctionString()+
                                        Utils.radToDegGLSLFunctionString()+
                                        Utils.cartesianToSphericalGLSLFunctionString()+
                                        Utils.sphericalToCartesianGLSLFunctionString()+
                                        Utils.getVectorGLSLFunctionString()+

                                        Utils.unpackGLSLFunctionString()+

                                        Utils.rayTraversalInitSTR()+
                                        Utils.rayTraversalSTR(resolution),

                                        // fragment source
                                        'vec3 pixelCoord = vposScreen.xyz / vposScreen.w;'+

                                        'float maxang=0.7;'+
                                        'float maxBounds = 1.0;'+

                                        'vec4 texScreenColor = sampler_screenColor[vec2(pixelCoord.x,pixelCoord.y)];\n'+
                                        'vec4 texScreenPos = sampler_screenPos[vec2(pixelCoord.x,pixelCoord.y)];\n'+
                                        'vec4 texScreenNormal = sampler_screenNormal[vec2(pixelCoord.x,pixelCoord.y)];\n'+
                                        'vec4 texScreenGIVoxel = sampler_GIVoxel[vec2(pixelCoord.x,pixelCoord.y)];\n'+

                                        'vec4 f_sampler_screenColor;'+
                                        'vec4 f_sampler_screenPos;'+
                                        'vec4 f_sampler_screenNormal;'+
                                        'vec4 f_sampler_GIVoxel;'+
                                        'vec3 ro; vec3 rd; RayTraversalResponse rayT;'+


                                        'if(texScreenNormal.a == 0.0) {'+ // start
                                            'ro = vposition.xyz*vec3(1.0,1.0,1.0);'+
                                            'rd = vnormal.xyz*vec3(1.0,1.0,1.0);'+

                                            'vec3 vectorRandom = getVector(rd, maxang, vec2(randX1,randY1));'+
                                            'rayT = rayTraversal(ro+(rd*(cs+cs)), vectorRandom);\n'+
                                        '} else if(texScreenNormal.a == 1.0) {'+
                                            'ro = texScreenPos.xyz;'+
                                            'rd = texScreenNormal.xyz;'+
                                            //'rd = reflect(normalize(ro),rd);'+

                                            'vec3 vectorRandom = getVector(rd, maxang, vec2(randX1,randY1));'+
                                            'rayT = rayTraversal(ro+(rd*(cs)), vectorRandom);\n'+
                                        '}'+

                                        'if(rayT.voxelColor.a > 0.0) {'+ // hit in solid
                                            'vec4 rtColor = rayT.voxelColor;'+
                                            'vec4 rtPos = rayT.voxelPos;'+
                                            'vec4 rtNormal = rayT.voxelNormal;'+

                                            'f_sampler_screenColor = vec4(texScreenColor.r*rtColor.r,texScreenColor.g*rtColor.g,texScreenColor.b*rtColor.b, texScreenColor.a+(rtColor.a/uGridsize));\n'+ // -(rtColor.a/uGridsize)

                                            'float aum = (texScreenNormal.a == 0.0) ? 1.0 : texScreenPos.a+1.0;'+
                                            'f_sampler_screenPos = vec4(rtPos.r,rtPos.g,rtPos.b, aum);\n'+

                                            'float proc = (aum == maxBounds) ? 0.0 : 1.0;'+
                                            'f_sampler_screenNormal = vec4(rtNormal.r,rtNormal.g,rtNormal.b, proc);\n'+
                                        '} else {'+ // hit in light
                                            'f_sampler_screenColor = vec4(texScreenColor.r,texScreenColor.g,texScreenColor.b, texScreenColor.a);\n'+

                                            'float aum = (texScreenNormal.a == 0.0) ? 0.0 : texScreenPos.a+1.0;'+
                                            'f_sampler_screenPos = vec4(1.0,1.0,1.0, aum);\n'+

                                            'f_sampler_screenNormal = vec4(1.0,1.0,1.0, 0.0);\n'+ // (make process and return to origin alpha 0.0).
                                        '}'+


                                        'if(f_sampler_screenNormal.a == 0.0) {'+ // make process
                                            'float cum = texScreenGIVoxel.r+(1.0-(f_sampler_screenPos.a/maxBounds));'+
                                            'f_sampler_GIVoxel = vec4(cum, cum, cum, texScreenGIVoxel.a+1.0);'+
                                        '} else {'+ // hit in solid. do nothing
                                            'f_sampler_GIVoxel = texScreenGIVoxel;'+
                                        '}'+

                                        'return [f_sampler_screenColor, f_sampler_screenPos, f_sampler_screenNormal, f_sampler_GIVoxel];\n'
                                     ],
                                    "drawMode": 4,
                                    "depthTest": true,
                                    "blend": false,
                                    "blendEquation": Constants.BLENDING_EQUATION_TYPES.FUNC_ADD,
                                    "blendSrcMode": Constants.BLENDING_MODES.ONE,
                                    "blendDstMode": Constants.BLENDING_MODES.ZERO});
        this.comp_renderer_node.getComponentBufferArg("RGB", this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.GPU));
        this.comp_renderer_node.gpufG.onPreProcessGraphic(0, (function() {
            //comp_screenEffects.gl.clear(comp_screenEffects.gl.COLOR_BUFFER_BIT | comp_screenEffects.gl.DEPTH_BUFFER_BIT);
            //this.comp_renderer_node.gl.blendFunc(this.comp_renderer_node.gl[Constants.BLENDING_MODES.SRC_ALPHA], this.comp_renderer_node.gl[Constants.BLENDING_MODES.ONE_MINUS_SRC_ALPHA]);
        }).bind(this));
        this.comp_renderer_node.gpufG.onPreProcessGraphic(1, (function() {
            //this.comp_renderer_node.gl.blendFunc(this.comp_renderer_node.gl[Constants.BLENDING_MODES.SRC_ALPHA], this.comp_renderer_node.gl[Constants.BLENDING_MODES.ONE_MINUS_SRC_ALPHA]);
            if(this._runGI === true) {
                this.comp_renderer_node.setArg("randX1", (function(){return Math.random();}).bind(this));
                this.comp_renderer_node.setArg("randY1", (function(){return Math.random();}).bind(this));
            }
        }).bind(this));
        this.comp_renderer_node.gpufG.disableGraphic(1);

        this.comp_renderer_node.setArg("uResolution", (function(){return resolution;}).bind(this));
	};
	
	/**
	* setGridSize
	* @param {number} size
	*/
	setGridSize(size) {
        this.comp_renderer_node.setArg("uGridsize", (function(){return size;}).bind(this));
	}; 
	
	/**
	* setMesh
	* @param {Mesh} mesh
	*/
	setMesh(mesh) {
        this.comp_renderer_node.setArg("vertexPos", (function(){return mesh.vertexArray;}).bind(this));
        this.comp_renderer_node.setArg("vertexNormal", (function(){return mesh.normalArray;}).bind(this));
        this.comp_renderer_node.setArg("vertexTexture", (function(){return mesh.textureArray;}).bind(this));
        this.comp_renderer_node.setArg("vertexTextureUnit", (function(){return mesh.textureUnitArray;}).bind(this));

        this.comp_renderer_node.setArg("indices", (function(){return mesh.indexArray;}).bind(this));

        this.comp_renderer_node.setArg("PMatrix", (function(){return this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.PROJECTION).getMatrix().transpose().e;}).bind(this));
        this.comp_renderer_node.setArgUpdatable("PMatrix", true);
        this.comp_renderer_node.setArg("cameraWMatrix", (function(){return this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.TRANSFORM_TARGET).getMatrix().transpose().e;}).bind(this));
        this.comp_renderer_node.setArgUpdatable("cameraWMatrix", true);
        this.comp_renderer_node.setArg("nodeWMatrix", () => {return this.nodes.getComponent(Constants.COMPONENT_TYPES.TRANSFORM).getMatrixPosition().transpose().e;});
        this.comp_renderer_node.setArgUpdatable("nodeWMatrix", true);

        this.comp_renderer_node.setArg("texAlbedo", (function(){return mesh.vertexArray;}).bind(this));
	};
	
	/**
	* setImage
	* @param {String} url
	*/
	setImage(url) {
		let image = new Image();
		image.onload = () => {
            this.comp_renderer_node.setArg("texAlbedo", () => {return image;});
		};
		image.src = url;
	};
	
	/**
	* setVoxelsArrays
	* @param {Object} jsonIn
	* @param {Array<number>|Float32Array|Uint8Array|WebGLTexture|HTMLImageElement} [jsonIn.albedo=undefined]
	* @param {Array<number>|Float32Array|Uint8Array|WebGLTexture|HTMLImageElement} [jsonIn.position=undefined]
	* @param {Array<number>|Float32Array|Uint8Array|WebGLTexture|HTMLImageElement} [jsonIn.normal=undefined]
	*/
	setVoxelsArrays(jsonIn) {
		if(jsonIn.hasOwnProperty("albedo") === true)
            this.comp_renderer_node.setArg("sampler_voxelColor", (function(){return jsonIn.albedo;}).bind(this));
		
		if(jsonIn.hasOwnProperty("position") === true)
            this.comp_renderer_node.setArg("sampler_voxelPos", (function(){return jsonIn.position;}).bind(this));
		
		if(jsonIn.hasOwnProperty("normal") === true)
            this.comp_renderer_node.setArg("sampler_voxelNormal", (function(){return jsonIn.normal;}).bind(this));
	};
	
	/**
	* runGI
	*/
	runGI() {
//        this.comp_renderer_node.addArgument("float4* sampler_GIVoxel", (function(){return null;}).bind(this), null ,"FLOAT4");

        let comp_screenEffects = this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.GPU);
        comp_screenEffects.getComponentBufferArg("sampler_GIVoxel", this.comp_renderer_node);
        comp_screenEffects.gpufG.addKernel({
            "type": "KERNEL",
            "name": "GIsum",
            "viewSource": false,
            "config": ["x", undefined,
                // head
                '',
                // source
                // GI
                'vec4 textureFBGIVoxel = sampler_GIVoxel[x];\n'+
                'vec3 GIweight = vec3((textureFBGIVoxel.r/textureFBGIVoxel.a), (textureFBGIVoxel.g/textureFBGIVoxel.a), (textureFBGIVoxel.b/textureFBGIVoxel.a));'+

                'return vec4(GIweight, 1.0);'+

                //'return vec4(textureFBGIVoxel.xyz, 1.0);'+
                ''],
            "drawMode": 4,
            "depthTest": false,
            "blend": false,
            "blendEquation": Constants.BLENDING_EQUATION_TYPES.FUNC_ADD,
            "blendSrcMode": Constants.BLENDING_MODES.ONE,
            "blendDstMode": Constants.BLENDING_MODES.ZERO});

        let arr = new Float32Array(this._sce.getDimensions().width*this._sce.getDimensions().height*4);
        this.comp_renderer_node.setArg("sampler_screenColor", (function() {return arr;}).bind(this));
        this.comp_renderer_node.setArg("sampler_screenPos", (function() {return arr;}).bind(this));
        this.comp_renderer_node.setArg("sampler_screenNormal", (function() {return arr;}).bind(this));
        this.comp_renderer_node.setArg("sampler_GIVoxel", (function() {return arr;}).bind(this));

        this.comp_renderer_node.gpufG.fillArg("sampler_screenColor", [1.0, 1.0, 1.0, 1.0]);
        this.comp_renderer_node.gpufG.fillArg("sampler_screenPos", [1.0, 1.0, 1.0, 1.0]);
        this.comp_renderer_node.gpufG.fillArg("sampler_screenNormal", [1.0, 1.0, 1.0, 0.0]);
        this.comp_renderer_node.gpufG.fillArg("sampler_GIVoxel", [1.0, 1.0, 1.0, 1.0]);

        this.comp_renderer_node.gpufG.enableGraphic(1);
        this._runGI = true;
	};

	getComponentRendererNode() {
	    return this.comp_renderer_node;
    };

	/**
	* isRunned
	* @returns {boolean}
	*/
	isRunned() {
		return this._runGI;
	};
	
	/**
	* stop
	*/
	stop() {
		let comp_screenEffects = this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.GPU);
	};
	
	/**
	* resume
	*/
	resume() {
        this.comp_renderer_node.gpufG.fillArg("sampler_screenColor", [1.0, 1.0, 1.0, 1.0]);
        this.comp_renderer_node.gpufG.fillArg("sampler_screenPos", [1.0, 1.0, 1.0, 1.0]);
        this.comp_renderer_node.gpufG.fillArg("sampler_screenNormal", [1.0, 1.0, 1.0, 0.0]);
        this.comp_renderer_node.gpufG.fillArg("sampler_GIVoxel", [1.0, 1.0, 1.0, 1.0]);

		
		let comp_screenEffects = this._project.getActiveStage().getActiveCamera().getComponent(Constants.COMPONENT_TYPES.GPU);
	};
}
global.GI = GI;
module.exports.GI = GI;