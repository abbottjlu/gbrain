import {ComponentTransformTarget} from "../../ComponentTransformTarget.class";
import {ComponentProjection} from "../../ComponentProjection.class";
import {ComponentControllerTransformTarget} from "../../ComponentControllerTransformTarget.class";
import {Component_GPU} from "../../Component_GPU.class";
import {ComponentKeyboardEvents} from "../../ComponentKeyboardEvents.class";
import {ComponentMouseEvents} from "../../ComponentMouseEvents.class";
import {Node} from "../../Node.class";
import {Constants} from "../../Constants";

/**
* @class
*/
export class SimpleCamera {
    constructor(sce, jsonIn) {
        let _sce = sce;
        let _project = _sce.getLoadedProject();


        this._onkeydown = (jsonIn !== undefined && jsonIn.onkeydown !== undefined && jsonIn.onkeydown !== null) ? jsonIn.onkeydown: null;
        this._onkeyup = (jsonIn !== undefined && jsonIn.onkeyup !== undefined && jsonIn.onkeyup !== null) ? jsonIn.onkeyup: null;

        this._onmousedown = (jsonIn !== undefined && jsonIn.onmousedown !== undefined && jsonIn.onmousedown !== null) ? jsonIn.onmousedown: null;
        this._onmouseup = (jsonIn !== undefined && jsonIn.onmouseup !== undefined && jsonIn.onmouseup !== null) ? jsonIn.onmouseup: null;
        this._onmousemove = (jsonIn !== undefined && jsonIn.onmousemove !== undefined && jsonIn.onmousemove !== null) ? jsonIn.onmousemove: null;
        this._onmousewheel = (jsonIn !== undefined && jsonIn.onmousewheel !== undefined && jsonIn.onmousewheel !== null) ? jsonIn.onmousewheel: null;

        this._useAltKey = true;
        this.altKeyPressed = false;
        this._preventMove = false;

        this.camera = new Node();
        this.camera.setName("simple camera");
        _project.getActiveStage().addNode(this.camera);
        _project.getActiveStage().setActiveCamera(this.camera);

        // ComponentTransformTarget
        this.comp_transformTarget = new ComponentTransformTarget();
        this.camera.addComponent(this.comp_transformTarget);
        this.comp_transformTarget.setTargetDistance(0.5);

        // ComponentProjection
        this.comp_projection = new ComponentProjection();
        this.camera.addComponent(this.comp_projection);

        // ComponentControllerTransformTarget
        this.comp_controllerTransformTarget = new ComponentControllerTransformTarget();
        this.camera.addComponent(this.comp_controllerTransformTarget);

        // ComponentScreenEffects
        this.comp_screenEffects = new Component_GPU();
        this.camera.addComponent(this.comp_screenEffects);

        this.comp_screenEffects.setGPUFor( this.comp_screenEffects.gl,
                                    {"float4* RGB": () => {return new Float32Array(_sce.getCanvas().width*_sce.getCanvas().width*4);}},
                                    {"type": "KERNEL",
                                    "name": "CAMERA_RGB_KERNEL",
                                    "viewSource": false,
                                    "config": [ "n", undefined,
                                                // head
                                                '',
                                                // source
                                                'vec4 color = RGB[n];\n'+
                                                'return color;\n'],
                                    "drawMode": 4,
                                    "depthTest": false,
                                    "blend": false,
                                    "blendEquation": Constants.BLENDING_EQUATION_TYPES.FUNC_ADD,
                                    "blendSrcMode": Constants.BLENDING_MODES.ONE,
                                    "blendDstMode": Constants.BLENDING_MODES.ZERO});
        this.comp_screenEffects.gpufG.onPostProcessKernel(0, () => {
            //this.comp_screenEffects.gpufG.fillPointerArg("RGB", [0.0, 0.0, 0.0, 1.0]);
        });
        //this.comp_screenEffects.setArg("RGB", () => {return new Float32Array(_sce.getCanvas().width*_sce.getCanvas().width*4);});

        // ComponentKeyboardEvents
        this.comp_keyboardEvents = new ComponentKeyboardEvents();
        this.camera.addComponent(this.comp_keyboardEvents);
        this.comp_keyboardEvents.onkeydown((evt) => {
            let key = String.fromCharCode(evt.keyCode);

            if(key === "W")
                this.comp_controllerTransformTarget.forward();
            if(key === "S")
                this.comp_controllerTransformTarget.backward();
            if(key === "A" || key === "%")
                this.comp_controllerTransformTarget.strafeLeft();
            if(key === "D" || key === "'")
                this.comp_controllerTransformTarget.strafeRight();
            if(key === "E" || key === "&")
                this.comp_controllerTransformTarget.strafeFront();
            if(key === "C" || key === "(")
                this.comp_controllerTransformTarget.strafeBack();

            if(key === "L")
                this.setView(Constants.VIEW_TYPES.LEFT);
            if(key === "R")
                this.setView(Constants.VIEW_TYPES.RIGHT);
            if(key === "F")
                this.setView(Constants.VIEW_TYPES.FRONT);
            if(key === "B")
                this.setView(Constants.VIEW_TYPES.BACK);
            if(key === "T")
                this.setView(Constants.VIEW_TYPES.TOP);

            if(key === "P")
                this.comp_projection.setProjection(Constants.PROJECTION_TYPES.PERSPECTIVE);
            if(key === "O")
                this.comp_projection.setProjection(Constants.PROJECTION_TYPES.ORTHO);

            if(evt.altKey === true)
                this.altKeyPressed = true;

            if(this._onkeydown != null)
                this._onkeydown();
        });
        this.comp_keyboardEvents.onkeyup((evt) => {
            let key = String.fromCharCode(evt.keyCode);

            if(key === "W")
                this.comp_controllerTransformTarget.stopForward();
            if(key === "S")
                this.comp_controllerTransformTarget.stopBackward();
            if(key === "A" || key === "%")
                this.comp_controllerTransformTarget.stopStrafeLeft();
            if(key === "D" || key === "'")
                this.comp_controllerTransformTarget.stopStrafeRight();
            if(key === "E" || key === "&")
                this.comp_controllerTransformTarget.stopStrafeFront();
            if(key === "C" || key === "(")
                this.comp_controllerTransformTarget.stopStrafeBack();

            if(evt.altKey === false)
                this.altKeyPressed = false;

            if(this._onkeyup != null)
                this._onkeyup();
        });

        // ComponentMouseEvents
        let comp_mouseEvents = new ComponentMouseEvents();
        this.camera.addComponent(comp_mouseEvents);
        comp_mouseEvents.onmousedown((evt) => {
            this.comp_controllerTransformTarget.mouseDown(evt);

            if(evt.altKey === true)
                this.altKeyPressed = true;

            if(this._onmousedown != null)
                this._onmousedown();
        });
        comp_mouseEvents.onmouseup((evt) => {
            this.comp_controllerTransformTarget.mouseUp(evt);

            if(evt.altKey === false)
                this.altKeyPressed = false;

            if(this._onmouseup != null)
                this._onmouseup();
        });
        comp_mouseEvents.onmousemove((evt, dir) => {
            if(this._onmousemove != null)
                this._onmousemove();

            if(this._preventMove === false) {
                if(this.comp_projection.getProjection() === Constants.PROJECTION_TYPES.PERSPECTIVE || (((this._useAltKey === true && this.altKeyPressed === true) || this._useAltKey === false)))
                    this.comp_controllerTransformTarget.mouseMove(evt);


                if(this.comp_controllerTransformTarget.isRightBtnActive() === true && this.comp_projection.getProjection() === Constants.PROJECTION_TYPES.ORTHO && this.altKeyPressed === true) {
                    if(dir.e[2] > 0) {
                        this.comp_projection.setFov(this.comp_projection.getFov()*(1.0+Math.abs(dir.e[2]*0.005)));
                    } else {
                        this.comp_projection.setFov(this.comp_projection.getFov()/(1.0+Math.abs(dir.e[2]*0.005)));
                    }
                    //this.comp_transformTarget.setPositionTarget(this.comp_transformTarget.getPositionTarget().add(dir.x(dir.e[2])));
                    //this.comp_transformTarget.setPositionGoal(this.comp_transformTarget.getPositionGoal().add(dir.x(dir.e[2])));
                }
            }
        });
        comp_mouseEvents.onmousewheel((evt, dir) => {
            if((evt.wheelDeltaY !== undefined && evt.wheelDeltaY >= 0) || (evt.deltaY !== undefined && evt.deltaY <= 0))
                this.comp_projection.setFov(this.comp_projection.getFov()/1.1);
            else
                this.comp_projection.setFov(this.comp_projection.getFov()*1.1);

            if(this.comp_projection.getProjection() === Constants.PROJECTION_TYPES.ORTHO) {
                this.comp_transformTarget.setPositionTarget(this.comp_transformTarget.getPositionTarget().add(dir));
                this.comp_transformTarget.setPositionGoal(this.comp_transformTarget.getPositionGoal().add(dir));
            }

            if(this._onmousewheel != null)
                this._onmousewheel();
        });
    }
	
	/**
	* Set side view. This change the projection to orthographic.
	* @param {int|Constants.VIEW_TYPES} view
	 */
	setView(view) {
        this.comp_projection.setProjection(Constants.PROJECTION_TYPES.ORTHO);
        this.comp_transformTarget.reset();
		switch(view) {
			case Constants.VIEW_TYPES.LEFT:
                this.comp_transformTarget.yaw(90);
				break;
			case Constants.VIEW_TYPES.RIGHT:
                this.comp_transformTarget.yaw(-90);
				break;
			case Constants.VIEW_TYPES.FRONT:
				//this.comp_transformTarget.getMatrix().setRotation(new Utils().degToRad(0),false,$V3([0.0,1.0,0.0]));
				break;
			case Constants.VIEW_TYPES.BACK:			
				//this.comp_transformTarget.getMatrix().setRotation(new Utils().degToRad(180),false,$V3([0.0,1.0,0.0]));
				break;
			case Constants.VIEW_TYPES.TOP:
                this.comp_transformTarget.pitch(-89.9);
				break;
			case Constants.VIEW_TYPES.BOTTOM:
                this.comp_transformTarget.pitch(90);
				break;
		}
	};
	
	/**
	 * setLeftButtonAction
	 * @param {String} [action="ORBIT"]
	 */
	setLeftButtonAction(action) {
        this.comp_controllerTransformTarget.setLeftButtonAction(action);
	};
	
	/**
	 * setMiddleButtonAction
	 * @param {String} [action="PAN"]
	 */
	setMiddleButtonAction(action) {
        this.comp_controllerTransformTarget.setMiddleButtonAction(action);
	};
	
	/**
	 * setRightButtonAction
	 * @param {String} [action="ZOOM"]
	 */
	setRightButtonAction(action) {
        this.comp_controllerTransformTarget.setRightButtonAction(action);
	};
	
	/**
	 * preventMove
	 * @param {boolean} preventMove
	 */
    static preventMove(preventMove) {
        this._preventMove = preventMove;
	};
	
	/**
	 * isAltKeyEnabled
	 * @returns {boolean}
	 */
	isAltKeyEnabled() {
		return this._useAltKey;
	};
	
	/**
	 * isAltKeyPressed
	 * @returns {boolean}
	 */
	isAltKeyPressed() {
		return this.altKeyPressed;
	};
	
	/**
	 * useAltKey
	 * @param {boolean} useAltKey
	 */
	static useAltKey(useAltKey) {
        this._useAltKey = useAltKey;
	};
	
	/**
	 * setVelocity
	 * @param {number} velocity
	 */
	setVelocity(velocity) {
        this.comp_controllerTransformTarget.setVelocity(velocity);
	};
	
	/**
	 * setFov
	 * @param {number} fov
	 */
	setFov(fov) {
        this.comp_projection.setFov(fov);
	};
	/**
	 * getFov
	 * @returns {number}
	 */
	getFov() {
		return this.comp_projection.getFov();
	};
}
global.SimpleCamera = SimpleCamera;
module.exports.SimpleCamera = SimpleCamera;