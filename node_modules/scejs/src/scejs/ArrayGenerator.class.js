import {Utils} from "./Utils.class";

/**
* @class
* @constructor
*/
export class ArrayGenerator {
    constructor() {

    }
	
	/**
	* @param {Object} jsonIn
	* @param {int} jsonIn.count - count
	* @param {number} jsonIn.offset - Offset
	* @param {String} jsonIn.type - "float" | "float4"
	* @param {number} [jsonIn.spacing=0.01] - Spacing
	* @return {Array<number>}
	*/
	static randomArray(jsonIn) {
		let arr = [];
		for(let n=0; n < jsonIn.count; n++) {
			if(jsonIn.type === "float") arr.push(-(jsonIn.offset/2)+(Math.random()*jsonIn.offset));
			else arr.push(-(jsonIn.offset/2)+(Math.random()*jsonIn.offset), -(jsonIn.offset/2)+(Math.random()*jsonIn.offset), -(jsonIn.offset/2)+(Math.random()*jsonIn.offset), -(jsonIn.offset/2)+(Math.random()*jsonIn.offset));
		}
		
		return arr;
	};			
	/**
	* @param {Object} jsonIn
	* @param {int} jsonIn.count - count
	* @param {number} jsonIn.width - width
	* @param {number} jsonIn.height - height
	* @param {number} [jsonIn.spacing=0.01] - Spacing
	* @return {Array<number>}
	*/
    static widthHeightArray(jsonIn) {
        let arr = [];

        let totalDestinations = jsonIn.width*jsonIn.height;
        let nodesPerCell = jsonIn.count/totalDestinations;
        let nodesInCell = 0;
        let x = 0;
        let z = 0;
        let spacing = (jsonIn.spacing !== undefined && jsonIn.spacing !== null) ? jsonIn.spacing : 0.01;
		for(let n=0; n < jsonIn.count; n++) {
			if(nodesInCell >= nodesPerCell) {				
				x++;
				if(x > jsonIn.width-1) {
					x = 0;
					z++;
				}
				nodesInCell -= nodesPerCell;
			}
			nodesInCell += 1;
			
			arr.push(x*spacing, 0, z*spacing, 1.0);
		}
		
		return arr;
	};
	/**
	* @param {Object} jsonIn
	* @param {int} jsonIn.count - count
	* @param {Array<number>} jsonIn.float4 - direction
	* @return {Array<number>}
	*/
    static float4Array(jsonIn) {
        let arr = [];
		for(let n=0; n < jsonIn.count; n++) {
			arr.push(jsonIn.float4[0], jsonIn.float4[1], jsonIn.float4[2], jsonIn.float4[3]);
		}
		
		return arr;
	};
	/**
	* @param {Object} jsonIn
	* @param {int} jsonIn.count - count
	* @param {number} [jsonIn.radius=1.0] - radius
	* @return {Array<number>}
	*/
    static sphericalArray(jsonIn) {
        let arr = [];
        let rad = (jsonIn === undefined) ? 1.0 : jsonIn.radius;
		
		for(let n=0; n < jsonIn.count; n++) {
            let currAngleH = Math.random()*360.0;
            let currAngleV = Math.random()*180.0;
			arr.push(	Math.cos(currAngleH) * Math.abs(Math.sin(currAngleV)) * rad,  
						Math.cos(currAngleV) * rad * Math.random(),
						Math.sin(currAngleH) * Math.abs(Math.sin(currAngleV)) * rad,
						1.0);
		}
		
		return arr;
	};	
	/**
	 * hemArray
	 * @param {Object} jsonIn
	 * @param {int} jsonIn.count - count
	 * @param {number} [jsonIn.radius=1.0] - radius
	 * @param {StormV3} jsonIn.normalVector
	 * @param {number} jsonIn.degrees
	 */
	static hemArray(jsonIn) {
        let arr = [];
        let rad = (jsonIn === undefined) ? 1.0 : jsonIn.radius;
		
		for(let n=0; n < jsonIn.count; n++) {
            let v3 = new Utils().getVector(jsonIn.normalVector, jsonIn.degrees);
			
			arr.push(v3.e[0]*rad, v3.e[1]*rad, v3.e[2]*rad, 1.0);
		}
		
		return arr;
	};
	/**
	* @param {Object} jsonIn
	* @param {int} jsonIn.count - count
	* @param {HTMLImageElement} jsonIn.image - image
	* @return {Array<number>}
	*/
	static imageArray(jsonIn) {
        let imgarr = Utils.getUint8ArrayFromHTMLImageElement(jsonIn.image);
        let arr = [];
		for(let n=0; n < jsonIn.count; n++) {
            let id = n*4;
			arr.push(	parseFloat(imgarr[id]/255),  
						parseFloat(imgarr[id+1]/255),
						parseFloat(imgarr[id+2]/255),
						parseFloat(imgarr[id+3]/255));
		}
		
		return arr;
	};
	/**
	* @param {StormVoxelizator} voxelizator
	*/
	volumeArray(voxelizator) {
		this.arrayNodeDestination = [];	
		this.arrayNodeVertexColor = [];
		
		this.vo = voxelizator;
		if(this.vo instanceof StormVoxelizator === false) { alert("You must select a voxelizator object with albedo fillmode enabled."); return false;}
		if(this.vo.image3D_VoxelsColor === undefined || this.vo.image3D_VoxelsColor === null) { alert("You must select a voxelizator object with albedo fillmode enabled."); return false;}
		this.data = this.vo.clglBuff_VoxelsColor.items[0].inData;

        let numActCells = 0;
		for(let n = 0, f = this.data.length/4; n < f; n++) { // num of active cells
            let id = n*4;
			//if(data[id] > 30 && data[id+1] > 30 && data[id+2] > 30)
			if(this.data[id+3] > 0) {
				numActCells++;
			}
		}
        let totalNodes = this.currentNodeId-1;
        let nodesPerCell = totalNodes/numActCells;
		
		this.incremNodesCell = 0;
        let currentNodeId = -1;
		
		this.currentVoxelCell = null;
		this.CCX=0;
		this.CCY=0;
		this.CCZ=0;
		this.CCXMAX=this.vo.resolution-1, this.CCYMAX=this.vo.resolution-1, this.CCZMAX=this.vo.resolution-1;
        let separation = 1.0;
        let p;
        let c;
        let make = false;

        let next = (function() {
			while(true) {
				if(this.CCX === this.CCXMAX && this.CCZ === this.CCZMAX && this.CCY === this.CCYMAX) {
					break;
				} else {
					if(this.CCX === this.CCXMAX && this.CCZ === this.CCZMAX) {
						this.CCX=0;this.CCZ=0;this.CCY++;
					} else {
						if(this.CCX === this.CCXMAX) {
							this.CCX=0;this.CCZ++;
						} else {
							this.CCX++;
						}
					}
				}
				
				this.currentVoxelCell = (this.CCY*(this.vo.resolution*this.vo.resolution)) + (this.CCZ*(this.vo.resolution)) + this.CCX;
				
				if(this.data[(this.currentVoxelCell*4)+3] > 0) {
					this.incremNodesCell += nodesPerCell;
					if(this.incremNodesCell >= 1.0) {
						this.incremNodesCell -= 1.0;
						break;
					}
				}
			}
		}).bind(this);
		
		for(let n=0; n < this.arrayNodeId.length; n++) {
			if(currentNodeId !== this.arrayNodeId[n]) {
				currentNodeId = this.arrayNodeId[n];
									
				if(this.incremNodesCell >= 1.0) {
					this.incremNodesCell -= 1.0;
				} else {
					next();
				}
				
				// position
				p = $V3([0.0,0.0,0.0]).add($V3([-(this.vo.size/2.0), -(this.vo.size/2.0), -(this.vo.size/2.0)]));  
				p = p.add($V3([ this.vo.cs*this.CCX*separation, this.vo.cs*this.CCY*separation, this.vo.cs*(this.CCZMAX-this.CCZ)*separation ])); 
				p = p.add($V3([ this.vo.cs*Math.random(), this.vo.cs*Math.random(), this.vo.cs*Math.random() ]));
				
				// color
				c = $V3([ this.data[(this.currentVoxelCell*4)]/255, this.data[(this.currentVoxelCell*4)+1]/255, this.data[(this.currentVoxelCell*4)+2]/255 ]);
				
				this.arrayNodeDestination.push(p.e[0], p.e[1], p.e[2], 1.0);	
				this.arrayNodeVertexColor.push(c.e[0], c.e[1], c.e[2], 1.0);
			} else {
				this.arrayNodeDestination.push(p.e[0], p.e[1], p.e[2], 1.0);
				this.arrayNodeVertexColor.push(c.e[0], c.e[1], c.e[2], 1.0);
			}
		}
		comp_renderer_nodes.setArg("dest", (function() {return this.arrayNodeDestination;}).bind(this), this.splitNodes);
		comp_renderer_nodes.setArg("nodeVertexCol", (function() {return this.arrayNodeVertexColor;}).bind(this), this.splitNodes);

	};
}
global.ArrayGenerator = ArrayGenerator;
module.exports.ArrayGenerator = ArrayGenerator;