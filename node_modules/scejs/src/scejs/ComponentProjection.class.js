import {Component} from "./Component.class";
import {StormM16} from "./StormMath.class";
import {Constants} from "./Constants";

/**
* @class
* @constructor
*/
export class ComponentProjection extends Component {
    constructor() {
        super();
	
        this.type = Constants.COMPONENT_TYPES.PROJECTION;
        this.node = null;
        this.gl = null;


        this.mProjectionMatrix = $M16([1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0]);

        this.proy = Constants.PROJECTION_TYPES.PERSPECTIVE;
        this._width = 512;
        this._height = 512;

        this._fov = 45;
        this._fovOrtho = 20;

        this._near = 0.1;
        this._far = 10000;

        this._nearOrtho = -100000;
        this._farOrtho = 100000;
    }
	
	/**
	 * initialize
	 * @param {Node} nod
	 * @param {WebGLRenderingContext} glCtx.
	 * @override
	 */
	initialize(nod, glCtx) {
        this.node = nod;
        this.gl = glCtx;
		
		this.updateProjectionMatrix();
	};	
	
	/**
	 * getMatrix
	 * @returns {StormM16}
	 */
	getMatrix() {
		return this.mProjectionMatrix;
	};
	
	/**
	 * getProjection
	 * @returns {Constants.PROJECTION_TYPES|number}
	 */
	getProjection() {
		return this.proy;
	};	
	
	/**
	 * setProjection
	 * @param {int|Constants.PROJECTION_TYPES} projection_type
	 */
	setProjection(projection_type) {
        this.proy = projection_type;
        this.updateProjectionMatrix();
	};	
	
	/**
	 * setResolution
	 * @param {int} width
	 * @param {int} height
	 */
	setResolution(width, height) {
        this._width = width;
        this._height = height;
        this.updateProjectionMatrix();
	};

	/**
	 * getResolution
	 * @returns {Object}
	 */
	getResolution() {
		return {"width": this._width,
				"height": this._height};
	};

	/**
	 * setFov
	 * @param {number} fov
	 */
	setFov(fov) {
		if(this.proy === Constants.PROJECTION_TYPES.PERSPECTIVE) this._fov = fov;
		else this._fovOrtho = fov;

        this.updateProjectionMatrix();
	};

	/**
	 * getFov
	 * @returns {number}
	 */
	getFov() {
		if(this.proy === Constants.PROJECTION_TYPES.PERSPECTIVE) return this._fov;
		else return this._fovOrtho;
	};

	/**
	 * setNear
	 * @param {number} near
	 */
	setNear(near) {
		if(this.proy === Constants.PROJECTION_TYPES.PERSPECTIVE) this._near = near;
		else this._nearOrtho = near;

        this.updateProjectionMatrix();
	};

	/**
	 * getNear
	 * @returns {number}
	 */
	getNear() {
		if(this.proy === Constants.PROJECTION_TYPES.PERSPECTIVE) return this._near;
		else return this._nearOrtho;
	};

	/**
	 * setFar
	 * @param {number} far
	 */
	setFar(far) {
		if(this.proy === Constants.PROJECTION_TYPES.PERSPECTIVE) this._far = far;
		else this._farOrtho = far;

		this.updateProjectionMatrix();
	};

	/**
	 * getFar
	 * @returns {number}
	 */
	getFar() {
		if(this.proy === Constants.PROJECTION_TYPES.PERSPECTIVE) return this._far;
		else return this._farOrtho;
	};
	
	/**
	 * updateProjectionMatrix
	 * @private
	 */
	updateProjectionMatrix() {
		let fovy = (this.proy === Constants.PROJECTION_TYPES.PERSPECTIVE) ? this._fov : this._fovOrtho;
        let aspect = this._width / this._height;
		
		if(this.proy === Constants.PROJECTION_TYPES.PERSPECTIVE)
            this.mProjectionMatrix = StormM16.setPerspectiveProjection(fovy, aspect, this._near, this._far);
		else
            this.mProjectionMatrix = StormM16.setOrthographicProjection(-aspect*fovy, aspect*fovy, -aspect*fovy, aspect*fovy, this._nearOrtho, this._farOrtho);
	};
}
global.ComponentProjection = ComponentProjection;
module.exports.ComponentProjection = ComponentProjection;