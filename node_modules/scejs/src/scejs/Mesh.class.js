import {Utils} from "./Utils.class";
/**
* @class
* @constructor
*/
export class Mesh {
    constructor() {
        this._obj = {};
        this._textures = {};
        this.objIndex = null; // for store new indexes
        this.indexMax=0;
    }

	/**
	* Load a point
	*/
	loadPoint() {
        this._obj.vertexArray = [0.0, 0.0, 0.0, 0.0];
        this._obj.normalArray = [0.0, 1.0, 0.0, 0.0];
        this._obj.textureArray = [0.0, 0.0, 0.0, 0.0];
        this._obj.textureUnitArray = [0.0];
        this._obj.indexArray = [0];
		
		return this._obj;
	};
	
	/**
	* Load a triangle
	* @param {Object} jsonIn
	* @param {number} [jsonIn.scale=1.0]
	* @param {number} [jsonIn.side=1.0]
	*/
	loadTriangle(jsonIn) {
		let sca = (jsonIn !== undefined && jsonIn.scale !== undefined) ? jsonIn.scale : 1.0;
        let side = (jsonIn !== undefined && jsonIn.side !== undefined) ? jsonIn.side : 1.0 ;

        this._obj.vertexArray = [   0.0, 0.0, 0.0, 1.0,
                                    (side/2)*sca, 0.0, -1.0*sca, 1.0,
                                    -(side/2)*sca, 0.0, -1.0*sca, 1.0];
        this._obj.normalArray = [   0.0, 0.0, 1.0, 1.0,
                                    0.0, 0.0, 1.0, 1.0,
                                    0.0, 0.0, 1.0, 1.0];
        this._obj.textureArray = [  0.0, 0.0, 0.0, 1.0,
                                     1.0, 0.0, 0.0, 1.0,
                                     1.0, 1.0, 0.0, 1.0];
        this._obj.textureUnitArray = [0.0, 0.0, 0.0];
        this._obj.indexArray = [0, 1, 2];
		
		return this._obj;
	};
	
	/**
	* Load a quad
	* @param {number} length
	* @param {number} height
	* @returns {Object}
	*/
	loadQuad(length, height) {
        let l=(length===undefined)?0.5:length;
        let h=(height===undefined)?0.5:height;

        this._obj = {};
        this._obj.vertexArray = [   -l, -h, 0.0, 1.0,// Front face
                                   l, -h, 0.0, 1.0,
                                   l, h, 0.0, 1.0,
                                   -l, h, 0.0, 1.0];
        this._obj.normalArray = [	0.0, 0.0, 1.0, 1.0,// Front face
                                    0.0, 0.0, 1.0, 1.0,
                                    0.0, 0.0, 1.0, 1.0,
                                    0.0, 0.0, 1.0, 1.0];
        this._obj.textureArray = [  0.0, 0.0, 0.0, 1.0,// Front face
                                    1.0, 0.0, 0.0, 1.0,
                                    1.0, 1.0, 0.0, 1.0,
                                    0.0, 1.0, 0.0, 1.0];
        this._obj.textureUnitArray = [0.0,0.0,0.0,0.0];
        this._obj.indexArray = [0, 1, 2,	 	0, 2, 3];// Front face
		
		return this._obj;
	};
	
	/**
	* Load a circle
	* @param {Object} jsonIn
	* @param {int} jsonIn.segments
	* @param {number} jsonIn.radius
	* @returns {Object}
	*/
	loadCircle(jsonIn) {
        this._obj = {   "vertexArray": [],
                        "normalArray": [],
                        "textureArray": [],
                        "textureUnitArray": [],
                        "indexArray": []};
        this.objIndex = [];
        this.indexMax=0;

        let segments = (jsonIn !== undefined && jsonIn.segments !== undefined) ? jsonIn.segments : 6;
        let rad = (jsonIn !== undefined && jsonIn.radius !== undefined) ? jsonIn.radius : 0.5;

        let stepAngle = 360.0/(segments);
        let numSegH = 360.0/stepAngle;

        let cos = (function(val) {return Math.cos(new Utils().degToRad(val))}).bind(this);
        let sin = (function(val) {return Math.sin(new Utils().degToRad(val))}).bind(this);
		
		
		for(let h=1, fh = numSegH; h <= fh; h++) {
            let currAngleH = stepAngle*h;
			// PRIMER TRIÁNGULO
			// vertices
            let vA1 = $V3([	cos(currAngleH) *rad,
							0.0,
							sin(currAngleH) *rad]);
            let vB1 = $V3([	cos(currAngleH-stepAngle) *rad,
							0.0,
							sin(currAngleH-stepAngle) *rad]);
            let vC1 = $V3([	0.0, 0.0, 0.0]);
			// normales
            let norm = vB1.subtract(vA1).cross(vC1.subtract(vA1)).normalize();
			// texturas
            let tA1 = $V3([currAngleH/360.0, 0.0, 0.0]);
            let tB1 = $V3([(currAngleH-stepAngle)/360.0, 0.0, 0.0]);
            let tC1 = $V3([0.0, 0.0, 0.0]);
			//indices
            let indexA = this.testIfInIndices(this._obj, vA1, norm, tA1);
            let indexB = this.testIfInIndices(this._obj, vB1, norm, tB1);
            let indexC = this.testIfInIndices(this._obj, vC1, norm, tC1);

            this._obj.indexArray.push(indexA,indexB,indexC);
		}	
		
		return this._obj;
	};
	
	testIfInIndices(_obj, vA1, norm, tA1) {
        let indexA = undefined;
		for(let nB = 0, fb = this.objIndex.length; nB < fb; nB++) {
			if(this.objIndex[nB].v.e[0] === vA1.e[0] && this.objIndex[nB].v.e[1] === vA1.e[1] && this.objIndex[nB].v.e[2] === vA1.e[2]) {
				indexA = this.objIndex[nB].i;
			}
		}
		if(indexA === undefined) {
			indexA = this.indexMax;
            this.objIndex.push({i:indexA,v:$V3([vA1.e[0],vA1.e[1],vA1.e[2]])});
            this.indexMax++;
			_obj.vertexArray.push(vA1.e[0],vA1.e[1],vA1.e[2], 1.0);
			_obj.normalArray.push(norm.e[0],norm.e[1],norm.e[2], 1.0);
			_obj.textureArray.push((vA1.e[0]+0.5),(vA1.e[2]+0.5),vA1.e[2]+0.5, 1.0);
			_obj.textureUnitArray.push(0.0);
		}
		return indexA;
	};
	
	/**
	* Load a box
	* @returns {Object}
	*/
	loadBox() {
        this._obj = {};

        let d = new Float32Array([0.5,0.5,0.5]);
        this._obj.vertexArray = [   -1.0*d[0], -1.0*d[1],  1.0*d[2], 1.0,// Front face
                                     1.0*d[0], -1.0*d[1],  1.0*d[2], 1.0,
                                     1.0*d[0],  1.0*d[1],  1.0*d[2], 1.0,
                                    -1.0*d[0],  1.0*d[1],  1.0*d[2], 1.0,
                                    // Back face
                                    -1.0*d[0], -1.0*d[1], -1.0*d[2], 1.0,
                                    -1.0*d[0],  1.0*d[1], -1.0*d[2], 1.0,
                                     1.0*d[0],  1.0*d[1], -1.0*d[2], 1.0,
                                     1.0*d[0], -1.0*d[1], -1.0*d[2], 1.0,
                                    // Top face
                                    -1.0*d[0],  1.0*d[1], -1.0*d[2], 1.0,
                                    -1.0*d[0],  1.0*d[1],  1.0*d[2], 1.0,
                                     1.0*d[0],  1.0*d[1],  1.0*d[2], 1.0,
                                     1.0*d[0],  1.0*d[1], -1.0*d[2], 1.0,
                                    // Bottom face
                                    -1.0*d[0], -1.0*d[1], -1.0*d[2], 1.0,
                                     1.0*d[0], -1.0*d[1], -1.0*d[2], 1.0,
                                     1.0*d[0], -1.0*d[1],  1.0*d[2], 1.0,
                                    -1.0*d[0], -1.0*d[1],  1.0*d[2], 1.0,
                                    // Right face
                                     1.0*d[0], -1.0*d[1], -1.0*d[2], 1.0,
                                     1.0*d[0],  1.0*d[1], -1.0*d[2], 1.0,
                                     1.0*d[0],  1.0*d[1],  1.0*d[2], 1.0,
                                     1.0*d[0], -1.0*d[1],  1.0*d[2], 1.0,
                                    // Left face
                                    -1.0*d[0], -1.0*d[1], -1.0*d[2], 1.0,
                                    -1.0*d[0], -1.0*d[1],  1.0*d[2], 1.0,
                                    -1.0*d[0],  1.0*d[1],  1.0*d[2], 1.0,
                                    -1.0*d[0],  1.0*d[1], -1.0*d[2], 1.0];
        this._obj.normalArray = [   0.0,  0.0,  1.0, 1.0,// Front face
                                    0.0,  0.0,  1.0, 1.0,
                                    0.0,  0.0,  1.0, 1.0,
                                    0.0,  0.0,  1.0, 1.0,
                                   // Back face
                                    0.0,  0.0, -1.0, 1.0,
                                    0.0,  0.0, -1.0, 1.0,
                                    0.0,  0.0, -1.0, 1.0,
                                    0.0,  0.0, -1.0, 1.0,
                                   // Top face
                                    0.0,  1.0,  0.0, 1.0,
                                    0.0,  1.0,  0.0, 1.0,
                                    0.0,  1.0,  0.0, 1.0,
                                    0.0,  1.0,  0.0, 1.0,
                                   // Bottom face
                                    0.0, -1.0,  0.0, 1.0,
                                    0.0, -1.0,  0.0, 1.0,
                                    0.0, -1.0,  0.0, 1.0,
                                    0.0, -1.0,  0.0, 1.0,
                                   // Right face
                                    1.0,  0.0,  0.0, 1.0,
                                    1.0,  0.0,  0.0, 1.0,
                                    1.0,  0.0,  0.0, 1.0,
                                    1.0,  0.0,  0.0, 1.0,
                                   // Left face
                                   -1.0,  0.0,  0.0, 1.0,
                                   -1.0,  0.0,  0.0, 1.0,
                                   -1.0,  0.0,  0.0, 1.0,
                                   -1.0,  0.0,  0.0, 1.0];
        this._obj.textureArray = [  0.0, 0.0, 0.0, 1.0,// Front face
                                     1.0, 0.0, 0.0, 1.0,
                                     1.0, 1.0, 0.0, 1.0,
                                     0.0, 1.0, 0.0, 1.0,
                                     // Back face
                                     1.0, 0.0, 0.0, 1.0,
                                     1.0, 1.0, 0.0, 1.0,
                                     0.0, 1.0, 0.0, 1.0,
                                     0.0, 0.0, 0.0, 1.0,
                                     // Top face
                                     0.0, 1.0, 0.0, 1.0,
                                     0.0, 0.0, 0.0, 1.0,
                                     1.0, 0.0, 0.0, 1.0,
                                     1.0, 1.0, 0.0, 1.0,
                                     // Bottom face
                                     1.0, 1.0, 0.0, 1.0,
                                     0.0, 1.0, 0.0, 1.0,
                                     0.0, 0.0, 0.0, 1.0,
                                     1.0, 0.0, 0.0, 1.0,
                                     // Right face
                                     1.0, 0.0, 0.0, 1.0,
                                     1.0, 1.0, 0.0, 1.0,
                                     0.0, 1.0, 0.0, 1.0,
                                     0.0, 0.0, 0.0, 1.0,
                                     // Left face
                                     0.0, 0.0, 0.0, 1.0,
                                     1.0, 0.0, 0.0, 1.0,
                                     1.0, 1.0, 0.0, 1.0,
                                     0.0, 1.0, 0.0, 1.0];
        this._obj.textureUnitArray = [  0.0,0.0,0.0,0.0,// Front face
                                         // Back face
                                         0.0,0.0,0.0,0.0,
                                         // Top face
                                         0.0,0.0,0.0,0.0,
                                         // Bottom face
                                         0.0,0.0,0.0,0.0,
                                         // Right face
                                         0.0,0.0,0.0,0.0,
                                         // Left face
                                         0.0,0.0,0.0,0.0];
        this._obj.indexArray = [    0, 1, 2,      0, 2, 3,    // Front face
                                   4, 5, 6,      4, 6, 7,    // Back face
                                   8, 9, 10,     8, 10, 11,  // Top face
                                   12, 13, 14,   12, 14, 15, // Bottom face
                                   16, 17, 18,   16, 18, 19, // Right face
                                   20, 21, 22,   20, 22, 23];  // Left face
		
		return this._obj;
	};
	
	/**
	 * @typedef {Object} Mesh~ImageData
	 * @property {int} Mesh~ImageData.fileUrl
	 * @property {int} Mesh~ImageData.materialName
	 */
	/**
	 * This callback is displayed as part of the onSelectNode
	 * @callback Mesh~loadObj~onload
	 * @param {Mesh} mesh
	 * @param {Mesh~ImageData} textures
	 */
	/**
	* Load a object from url of obj file
	* @param {String} objUrl
	* @param {Mesh~loadObj~onload} onload
	*/
	loadObj(objUrl, onload) {
        let objDirectory = '';
        let expl = objUrl.split("/");
	    for(let n = 0, f = expl.length-1; n < f; n++)
	    	objDirectory = objDirectory+expl[n]+'/';


        let req = new XMLHttpRequest();
		req.open("GET", objUrl, true);
		req.responseType = "blob";		
		req.onload = (function(onload) {
            let filereader = new FileReader();
			filereader.onload = (function(onload, event) {
                let text = event.target.result;
				
				this.loadObjFromSourceText({"sourceText": text, "objDirectory": objDirectory});
												
				if(onload !== undefined && typeof(onload) === 'function')
					onload(this._obj, this._textures);
			}).bind(this, onload);
			filereader.readAsText(req.response);
		}).bind(this, onload);
	    req.send(null);
	};

	/**
	* Load a object from text-plain on obj format
	* @param {Object} jsonIn
	* @param {String} jsonIn.sourceText
	* @param {String} jsonIn.objDirectory
	*/
	loadObjFromSourceText(jsonIn) {
        this._obj = {};
        this._textures = {};

        let _node,_sourceText,_objDirectory;
		_sourceText = (jsonIn.sourceText !== undefined) ? jsonIn.sourceText : undefined;
		_objDirectory = (jsonIn.objDirectory !== undefined) ? jsonIn.objDirectory : undefined;

        let lines = _sourceText.split("\r\n");
		if(lines.length === 1) lines = _sourceText.split("\n");
		
		if(lines[0].match(/OBJ/gim) == null) {alert('Not OBJ file');	return;}
		
		
		let vertexArrayX = [];let vertexArrayY = [];let vertexArrayZ = [];
		let normalArrayX = [];let normalArrayY = [];let normalArrayZ = [];
		let textureArrayX = [];let textureArrayY = [];let textureArrayZ = [];
		let textureUnitArray = [];
		let currentTextureUnit = 0;
		let indexArray = [];
		let currentIDX = 0;
		let currentIDX_INDEX = 0;
		
		let bufferEnCola = false;
		
		let vertexX = [];let vertexY = [];let vertexZ = [];
		let normalX = [];let normalY = [];let normalZ = [];
		let textureX = [];let textureY = [];let textureZ = [];
		let currentIDX_vertex = 0;let currentIDX_normal = 0;let currentIDX_texture = 0;
		let indexVNT = [];
		let currentIndex = 0;
		
		
		let groups = {};
		let currentGroup = [-1, 0];
		groups["_unnamed"] = currentGroup;

		let mtlFile = "";
		let currentMtlName = "";
		
		for(let n = 0, f = lines.length; n < f; n++) {
			let line = lines[n].replace(/\t+/gi, " ").replace(/\s+$/gi, "").replace(/\s+/gi, " ");
			if(line[0] === "#") continue;// ignore comments
			
			let array = line.split(" ");
			
			if(array[0] === "mtllib") {
				mtlFile = array[1];
			}
			if(array[0] === "g") {
				currentGroup = [indexArray.length, 0];
				groups[array[1]] = currentGroup;
			}
			if(array[0] === "v") {
				vertexX[currentIDX_vertex] = parseFloat(array[1]); 
				vertexY[currentIDX_vertex] = parseFloat(array[2]);
				vertexZ[currentIDX_vertex] = parseFloat(array[3]);
				currentIDX_vertex++; 
			}
			if(array[0] === "vn") {
				normalX[currentIDX_normal] = parseFloat(array[1]);
				normalY[currentIDX_normal] = parseFloat(array[2]);
				normalZ[currentIDX_normal] = parseFloat(array[3]);
				currentIDX_normal++;
			}
			if(array[0] === "vt") {
				textureX[currentIDX_texture] = parseFloat(array[1]);
				textureY[currentIDX_texture] = parseFloat(array[2]);
				textureZ[currentIDX_texture] = parseFloat(array[3]);
				currentIDX_texture++;
			}
			if(array[0] === "usemtl") {
				currentMtlName = array[1];

                this._textures[currentTextureUnit] = {  "fileUrl": _objDirectory+mtlFile,
                                                        "materialName": currentMtlName};
				
				currentTextureUnit++;
			}
			if(array[0] === "f") {
				if(array.length !== 4)
					console.log("*** Error: face '"+line+"' not handled");

				// recorremos cada vtx/tex/nor de la linea 'f vtxA/texA/norA vtxB/texB/norB vtxC/texC/norC'
				// puede ser tambien de tipo f vtx vtx vtx
				for(let i = 1, fi = 4; i < fi; ++i) { // primero vtxA/texA/norA, luego vtxB/texB/norB y luego vtxC/texC/norC
					bufferEnCola = true;
					let expl = array[i].split("/"); // array[i] = "vtxX/texX/norX"
					if(indexVNT[array[i]] === undefined) {  //si no existe current "vtxX/texX/norX" en array indexVNT se añade nuevo indice
						let vtx, nor, tex;
						if(expl.length === 1) { // si es de tipo solo vtx
							vtx = parseInt(expl[0]) - 1; // usamos vtx en todos
							nor = vtx;
							tex = vtx;
						} else if(expl.length === 3) { // si es de tipo vtx/tex/nor
							vtx = parseInt(expl[0]) - 1;
							tex = parseInt(expl[1]) - 1;
							nor = parseInt(expl[2]) - 1;
							// se resta 1 por que en el formato obj el primero comienza en 1.
							// en los arrays donde hemos almacenado vertex, normal y texture el primero comienza en 0.
						} else {
							//obj.ctx.console.log("*** Error: did not understand face '"+array[i]+"'");
							return null;
						}
						
						textureUnitArray[currentIDX] = (currentTextureUnit-1);
						
						vertexArrayX[currentIDX] = 0.0;
						vertexArrayY[currentIDX] = 0.0;
						vertexArrayZ[currentIDX] = 0.0;
						if(vtx < vertexZ.length) { 
							vertexArrayX[currentIDX] = vertexX[vtx];
							vertexArrayY[currentIDX] = vertexY[vtx];
							vertexArrayZ[currentIDX] = vertexZ[vtx];
						}
						
						textureArrayX[currentIDX] = 0.0;
						textureArrayY[currentIDX] = 0.0;
						textureArrayZ[currentIDX] = 0.0;
						if(tex < textureZ.length) { 
							textureArrayX[currentIDX] = textureX[tex];
							textureArrayY[currentIDX] = textureY[tex];
							textureArrayZ[currentIDX] = textureZ[tex];
						}
						
						normalArrayX[currentIDX] = 0.0;
						normalArrayY[currentIDX] = 0.0;
						normalArrayZ[currentIDX] = 1.0;
						if(nor < normalZ.length) { 
							normalArrayX[currentIDX] = normalX[nor];
							normalArrayY[currentIDX] = normalY[nor];
							normalArrayZ[currentIDX] = normalZ[nor];
						}
						currentIDX++;
						
						indexVNT[array[i]] = currentIndex; // indexVNT[vtxX/texX/norX] = currentIndex; 
						currentIndex++;
					}
					indexArray[currentIDX_INDEX] = indexVNT[array[i]];
					currentIDX_INDEX++;
					
					currentGroup[1]++;
				}
				
			}
		}
		
		if(bufferEnCola === true) {
            this._obj.vertexArray = new Float32Array(vertexArrayX.length*4);
			for(let n = 0, fn = vertexArrayX.length; n < fn; n++) {
				let idx = n*4;
                this._obj.vertexArray[idx] = vertexArrayX[n];
                this._obj.vertexArray[idx+1] = vertexArrayY[n];
                this._obj.vertexArray[idx+2] = vertexArrayZ[n];
                this._obj.vertexArray[idx+3] = 1.0;
			}
            this._obj.normalArray = new Float32Array(normalArrayX.length*4);
			for(let n = 0, fn = normalArrayX.length; n < fn; n++) {
				let idx = n*4;
                this._obj.normalArray[idx] = normalArrayX[n];
                this._obj.normalArray[idx+1] = normalArrayY[n];
                this._obj.normalArray[idx+2] = normalArrayZ[n];
                this._obj.normalArray[idx+3] = 1.0;
			}
            this._obj.textureArray = new Float32Array(textureArrayX.length*4);
			for(let n = 0, fn = textureArrayX.length; n < fn; n++) {
				let idx = n*4;
                this._obj.textureArray[idx] = textureArrayX[n];
                this._obj.textureArray[idx+1] = textureArrayY[n];
                this._obj.textureArray[idx+2] = textureArrayZ[n];
                this._obj.textureArray[idx+3] = 1.0;
			}
            this._obj.textureUnitArray = textureUnitArray;
            this._obj.indexArray = indexArray;
			
			// RESET
			/*let bufferEnCola = false;
			
			vertexArrayX = [];vertexArrayY = [];vertexArrayZ = [];
			normalArrayX = [];normalArrayY = [];normalArrayZ = [];
			textureArrayX = [];textureArrayY = [];textureArrayZ = [];
			textureUnitArray = [];
			//currentTextureUnit = 0;  
			indexArray = [];
			currentIDX = 0;
			currentIDX_INDEX = 0;
			 
			//vertexX = [];vertexY = [];vertexZ = [];
			//normalX = [];normalY = [];normalZ = [];
			//textureX = [];textureY = [];textureZ = [];
			//currentIDX_vertex = 0;currentIDX_normal = 0;currentIDX_texture = 0;    
			indexVNT = [];
			currentIndex = 0;*/
		}     
	};
}
global.Mesh = Mesh;
module.exports.Mesh = Mesh;